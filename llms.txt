Project Structure:
ğŸ“ ragie-php
â”œâ”€â”€ ğŸ“ benchmarks
â”‚   â””â”€â”€ ğŸ“„ RetrievalBenchmark.php
â”œâ”€â”€ ğŸ“ dev
â”‚   â””â”€â”€ ğŸ“ Coverage
â”‚       â””â”€â”€ ğŸ“„ CoverageThresholdChecker.php
â”œâ”€â”€ ğŸ“ docs
â”‚   â””â”€â”€ ğŸ“„ COOKBOOK.md
â”œâ”€â”€ ğŸ“ examples
â”‚   â”œâ”€â”€ ğŸ“„ error_handling.php
â”‚   â”œâ”€â”€ ğŸ“„ input_validation.php
â”‚   â”œâ”€â”€ ğŸ“„ interactive-demo.php
â”‚   â”œâ”€â”€ ğŸ“„ retrieve.php
â”‚   â”œâ”€â”€ ğŸ“„ retrieve_advanced.php
â”‚   â”œâ”€â”€ ğŸ“„ retrieve_concurrent.php
â”‚   â””â”€â”€ ğŸ“„ retrieve_with_cache.php
â”œâ”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ Benchmark
â”‚   â”‚   â””â”€â”€ ğŸ“„ TimingSummary.php
â”‚   â”œâ”€â”€ ğŸ“ Cache
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ InMemoryCache.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ QueryCacheInterface.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ SimpleCacheQueryCache.php
â”‚   â”œâ”€â”€ ğŸ“ Examples
â”‚   â”‚   â””â”€â”€ ğŸ“„ ChunkFormatter.php
â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ConfigurationException.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ InvalidParameterException.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ InvalidQueryException.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ RagieException.php
â”‚   â”œâ”€â”€ ğŸ“ Http
â”‚   â”‚   â””â”€â”€ ğŸ“„ ResponseFormatter.php
â”‚   â”œâ”€â”€ ğŸ“ Legacy
â”‚   â”œâ”€â”€ ğŸ“ Logging
â”‚   â”‚   â””â”€â”€ ğŸ“„ StructuredLogger.php
â”‚   â”œâ”€â”€ ğŸ“ Metrics
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ CostTracker.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ MetricsCollector.php
â”‚   â”œâ”€â”€ ğŸ“ Ragie
â”‚   â”‚   â””â”€â”€ ğŸ“ Api
â”‚   â”‚       â”œâ”€â”€ ğŸ“ docs
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Api
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Model
â”‚   â”‚       â”œâ”€â”€ ğŸ“ lib
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Api
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Model
â”‚   â”‚       â””â”€â”€ ğŸ“ test
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Api
â”‚   â”‚           â””â”€â”€ ğŸ“ Model
â”‚   â”œâ”€â”€ ğŸ“ Retry
â”‚   â”‚   â””â”€â”€ ğŸ“„ RetryPolicy.php
â”‚   â”œâ”€â”€ ğŸ“ Validation
â”‚   â”‚   â””â”€â”€ ğŸ“„ InputSanitizer.php
â”‚   â”œâ”€â”€ ğŸ“„ Client.php
â”‚   â”œâ”€â”€ ğŸ“„ RetrievalOptions.php
â”‚   â””â”€â”€ ğŸ“„ RetrievalResult.php
â”œâ”€â”€ ğŸ“ tests
â”‚   â”œâ”€â”€ ğŸ“ Compliance
â”‚   â”‚   â””â”€â”€ ğŸ“„ NamespaceIsolationTest.php
â”‚   â”œâ”€â”€ ğŸ“ fixtures
â”‚   â”‚   â””â”€â”€ ğŸ“ coverage
â”‚   â”‚       â”œâ”€â”€ ğŸ“„ empty.xml
â”‚   â”‚       â”œâ”€â”€ ğŸ“„ high.xml
â”‚   â”‚       â””â”€â”€ ğŸ“„ low.xml
â”‚   â”œâ”€â”€ ğŸ“ Integration
â”‚   â”‚   â””â”€â”€ ğŸ“„ RetryIntegrationTest.php
â”‚   â”œâ”€â”€ ğŸ“ Legacy
â”‚   â”œâ”€â”€ ğŸ“ Logging
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ SpyLogger.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ StructuredLoggerTest.php
â”‚   â”œâ”€â”€ ğŸ“ Retry
â”‚   â”‚   â””â”€â”€ ğŸ“„ RetryPolicyTest.php
â”‚   â””â”€â”€ ğŸ“ unit
â”‚       â”œâ”€â”€ ğŸ“ Benchmark
â”‚       â”‚   â”œâ”€â”€ ğŸ“„ RetrievalBenchmarkScriptTest.php
â”‚       â”‚   â””â”€â”€ ğŸ“„ TimingSummaryTest.php
â”‚       â”œâ”€â”€ ğŸ“ Cache
â”‚       â”‚   â”œâ”€â”€ ğŸ“„ InMemoryCacheTest.php
â”‚       â”‚   â””â”€â”€ ğŸ“„ SimpleCacheAdapterTest.php
â”‚       â”œâ”€â”€ ğŸ“ Dev
â”‚       â”‚   â””â”€â”€ ğŸ“ Coverage
â”‚       â”‚       â””â”€â”€ ğŸ“„ CoverageThresholdCheckerTest.php
â”‚       â”œâ”€â”€ ğŸ“ Examples
â”‚       â”‚   â””â”€â”€ ğŸ“„ ChunkFormatterTest.php
â”‚       â”œâ”€â”€ ğŸ“ Http
â”‚       â”‚   â””â”€â”€ ğŸ“„ ResponseFormatterTest.php
â”‚       â”œâ”€â”€ ğŸ“ Metrics
â”‚       â”‚   â”œâ”€â”€ ğŸ“„ CostTrackerTest.php
â”‚       â”‚   â””â”€â”€ ğŸ“„ MetricsCollectorTest.php
â”‚       â”œâ”€â”€ ğŸ“ Validation
â”‚       â”‚   â””â”€â”€ ğŸ“„ InputSanitizerTest.php
â”‚       â”œâ”€â”€ ğŸ“„ ClientLoggingTest.php
â”‚       â”œâ”€â”€ ğŸ“„ ClientTest.php
â”‚       â”œâ”€â”€ ğŸ“„ ClientValidationTest.php
â”‚       â”œâ”€â”€ ğŸ“„ OpenApiArtifactsTest.php
â”‚       â”œâ”€â”€ ğŸ“„ RetrievalOptionsTest.php
â”‚       â””â”€â”€ ğŸ“„ RetrievalResultTest.php
â”œâ”€â”€ ğŸ“ vendor
â”‚   â”œâ”€â”€ ğŸ“ amphp
â”‚   â”‚   â”œâ”€â”€ ğŸ“ amp
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Future
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚   â”œâ”€â”€ ğŸ“ byte-stream
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Base64
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Compression
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚   â”œâ”€â”€ ğŸ“ cache
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ dns
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚   â”œâ”€â”€ ğŸ“ parallel
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Context
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Internal
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Ipc
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Worker
â”‚   â”‚   â”‚           â””â”€â”€ ğŸ“ Internal
â”‚   â”‚   â”œâ”€â”€ ğŸ“ parser
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ pipeline
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚   â”œâ”€â”€ ğŸ“ process
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ bin
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ windows
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Posix
â”‚   â”‚   â”‚           â””â”€â”€ ğŸ“ Windows
â”‚   â”‚   â”œâ”€â”€ ğŸ“ serialization
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ socket
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Internal
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ SocketAddress
â”‚   â”‚   â””â”€â”€ ğŸ“ sync
â”‚   â”‚       â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â””â”€â”€ ğŸ“ Internal
â”‚   â”œâ”€â”€ ğŸ“ bin
â”‚   â”œâ”€â”€ ğŸ“ clue
â”‚   â”‚   â””â”€â”€ ğŸ“ ndjson-react
â”‚   â”‚       â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ composer
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 0255826d
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ phpDocumentor-ReflectionDocBlock-94f8051
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ DocBlock
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Tags
â”‚   â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Factory
â”‚   â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Formatter
â”‚   â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ Reference
â”‚   â”‚   â”‚           â””â”€â”€ ğŸ“ Exception
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 033e0a08
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 0a26529e
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 14388646
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 17b201e8
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ PHP-CS-Fixer-PHP-CS-Fixer-a8d1558
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Cache
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ ConfigurationException
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Console
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Command
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Output
â”‚   â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Progress
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Report
â”‚   â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ FixReport
â”‚   â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ ListSetsReport
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ SelfUpdate
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Differ
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ DocBlock
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Doctrine
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Annotation
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Documentation
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Error
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Fixer
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Alias
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ArrayNotation
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ AttributeNotation
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Basic
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Casing
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ CastNotation
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ClassNotation
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ClassUsage
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Comment
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ConstantNotation
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ControlStructure
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ DoctrineAnnotation
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ FunctionNotation
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Import
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ LanguageConstruct
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ListNotation
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ NamespaceNotation
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Naming
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Operator
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Phpdoc
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ PhpTag
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ PhpUnit
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ReturnNotation
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Semicolon
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Strict
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ StringNotation
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Whitespace
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ FixerConfiguration
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ FixerDefinition
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Linter
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ RuleSet
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Sets
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Runner
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Event
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Parallel
â”‚   â”‚   â”‚           â””â”€â”€ ğŸ“ Tokenizer
â”‚   â”‚   â”‚               â”œâ”€â”€ ğŸ“ Analyzer
â”‚   â”‚   â”‚               â”‚   â””â”€â”€ ğŸ“ Analysis
â”‚   â”‚   â”‚               â”œâ”€â”€ ğŸ“ Processor
â”‚   â”‚   â”‚               â””â”€â”€ ğŸ“ Transformer
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 1a34818a
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 1bfda51b
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 1ecf1afe
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 24718d76
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 25fd5263
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 2ac29b77
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 30fd0943
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 32de3a4d
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 41b2b4ef
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 43a3352f
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 4c268d9d
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ phpstan-phpstan-2770dcd
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ conf
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 586fef72
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ phpstan-phpdoc-parser-1e0cd53
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Ast
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ConstExpr
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ NodeVisitor
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ PhpDoc
â”‚   â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Doctrine
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Type
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Lexer
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Parser
â”‚   â”‚   â”‚           â””â”€â”€ ğŸ“ Printer
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 682705a0
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 6e905185
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 73333a09
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 7a1e38e4
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 7e879b1f
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ phpDocumentor-TypeResolver-679e3ce
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ docs
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ PseudoTypes
â”‚   â”‚   â”‚           â””â”€â”€ ğŸ“ Types
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 808a603a
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 8091d750
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 87d5ca8b
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 94c8c8ba
â”‚   â”‚   â”œâ”€â”€ ğŸ“ 95302519
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ sebastianbergmann-type-462699a
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ exception
â”‚   â”‚   â”‚           â””â”€â”€ ğŸ“ type
â”‚   â”‚   â”œâ”€â”€ ğŸ“ a00d52a4
â”‚   â”‚   â”œâ”€â”€ ğŸ“ ada3b2a4
â”‚   â”‚   â”œâ”€â”€ ğŸ“ b0319bdd
â”‚   â”‚   â”œâ”€â”€ ğŸ“ bbe2c5ec
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ sebastianbergmann-recursion-context-47e3421
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ bdb4ce1a
â”‚   â”‚   â”œâ”€â”€ ğŸ“ d7c0a4ec
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ sebastianbergmann-version-c51fa83
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ dfae04b7
â”‚   â”‚   â”œâ”€â”€ ğŸ“ e74f709e
â”‚   â”‚   â”œâ”€â”€ ğŸ“ e7dbc155
â”‚   â”‚   â”œâ”€â”€ ğŸ“ fcf78585
â”‚   â”‚   â”œâ”€â”€ ğŸ“ pcre
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ PHPStan
â”‚   â”‚   â”œâ”€â”€ ğŸ“ semver
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Constraint
â”‚   â”‚   â””â”€â”€ ğŸ“ xdebug-handler
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ danog
â”‚   â”‚   â””â”€â”€ ğŸ“ advanced-json-rpc
â”‚   â”‚       â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚       â””â”€â”€ ğŸ“ lib
â”‚   â”œâ”€â”€ ğŸ“ daverandom
â”‚   â”‚   â””â”€â”€ ğŸ“ libdns
â”‚   â”‚       â”œâ”€â”€ ğŸ“ examples
â”‚   â”‚       â”œâ”€â”€ ğŸ“ src
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Decoder
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Encoder
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Messages
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Packets
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Records
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ TypeDefinitions
â”‚   â”‚       â”‚       â””â”€â”€ ğŸ“ Types
â”‚   â”‚       â””â”€â”€ ğŸ“ tools
â”‚   â”œâ”€â”€ ğŸ“ dnoegel
â”‚   â”‚   â””â”€â”€ ğŸ“ php-xdg-base-dir
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ doctrine
â”‚   â”‚   â””â”€â”€ ğŸ“ deprecations
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â””â”€â”€ ğŸ“ PHPUnit
â”‚   â”œâ”€â”€ ğŸ“ evenement
â”‚   â”‚   â””â”€â”€ ğŸ“ evenement
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ felixfbecker
â”‚   â”‚   â””â”€â”€ ğŸ“ language-server-protocol
â”‚   â”‚       â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ fidry
â”‚   â”‚   â””â”€â”€ ğŸ“ cpu-core-counter
â”‚   â”‚       â”œâ”€â”€ ğŸ“ bin
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Executor
â”‚   â”‚           â””â”€â”€ ğŸ“ Finder
â”‚   â”œâ”€â”€ ğŸ“ friendsofphp
â”‚   â”‚   â””â”€â”€ ğŸ“ php-cs-fixer
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Cache
â”‚   â”‚           â”œâ”€â”€ ğŸ“ ConfigurationException
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Console
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Command
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Output
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Progress
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Report
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ FixReport
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ ListSetsReport
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ SelfUpdate
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Differ
â”‚   â”‚           â”œâ”€â”€ ğŸ“ DocBlock
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Doctrine
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Annotation
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Documentation
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Error
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Fixer
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Alias
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ArrayNotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ AttributeNotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Basic
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Casing
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ CastNotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ClassNotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ClassUsage
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Comment
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ConstantNotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ControlStructure
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ DoctrineAnnotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ FunctionNotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Import
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ LanguageConstruct
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ListNotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ NamespaceNotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Naming
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Operator
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Phpdoc
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ PhpTag
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ PhpUnit
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ReturnNotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Semicolon
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Strict
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ StringNotation
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Whitespace
â”‚   â”‚           â”œâ”€â”€ ğŸ“ FixerConfiguration
â”‚   â”‚           â”œâ”€â”€ ğŸ“ FixerDefinition
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Linter
â”‚   â”‚           â”œâ”€â”€ ğŸ“ RuleSet
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Sets
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Runner
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Event
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Parallel
â”‚   â”‚           â””â”€â”€ ğŸ“ Tokenizer
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Analyzer
â”‚   â”‚               â”‚   â””â”€â”€ ğŸ“ Analysis
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Processor
â”‚   â”‚               â””â”€â”€ ğŸ“ Transformer
â”‚   â”œâ”€â”€ ğŸ“ guzzlehttp
â”‚   â”‚   â”œâ”€â”€ ğŸ“ guzzle
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Cookie
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Handler
â”‚   â”‚   â”œâ”€â”€ ğŸ“ promises
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â””â”€â”€ ğŸ“ psr7
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â””â”€â”€ ğŸ“ Exception
â”‚   â”œâ”€â”€ ğŸ“ kelunik
â”‚   â”‚   â””â”€â”€ ğŸ“ certificate
â”‚   â”‚       â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ league
â”‚   â”‚   â”œâ”€â”€ ğŸ“ uri
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ UriTemplate
â”‚   â”‚   â””â”€â”€ ğŸ“ uri-interfaces
â”‚   â”‚       â”œâ”€â”€ ğŸ“ Contracts
â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exceptions
â”‚   â”‚       â”œâ”€â”€ ğŸ“ Idna
â”‚   â”‚       â”œâ”€â”€ ğŸ“ IPv4
â”‚   â”‚       â”œâ”€â”€ ğŸ“ IPv6
â”‚   â”‚       â””â”€â”€ ğŸ“ KeyValuePair
â”‚   â”œâ”€â”€ ğŸ“ myclabs
â”‚   â”‚   â””â”€â”€ ğŸ“ deep-copy
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â””â”€â”€ ğŸ“ DeepCopy
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Filter
â”‚   â”‚               â”‚   â””â”€â”€ ğŸ“ Doctrine
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Matcher
â”‚   â”‚               â”‚   â””â”€â”€ ğŸ“ Doctrine
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Reflection
â”‚   â”‚               â”œâ”€â”€ ğŸ“ TypeFilter
â”‚   â”‚               â”‚   â”œâ”€â”€ ğŸ“ Date
â”‚   â”‚               â”‚   â””â”€â”€ ğŸ“ Spl
â”‚   â”‚               â””â”€â”€ ğŸ“ TypeMatcher
â”‚   â”œâ”€â”€ ğŸ“ netresearch
â”‚   â”‚   â””â”€â”€ ğŸ“ jsonmapper
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â””â”€â”€ ğŸ“ JsonMapper
â”‚   â”œâ”€â”€ ğŸ“ nikic
â”‚   â”‚   â””â”€â”€ ğŸ“ php-parser
â”‚   â”‚       â”œâ”€â”€ ğŸ“ bin
â”‚   â”‚       â””â”€â”€ ğŸ“ lib
â”‚   â”‚           â””â”€â”€ ğŸ“ PhpParser
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Builder
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Comment
â”‚   â”‚               â”œâ”€â”€ ğŸ“ ErrorHandler
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Internal
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Lexer
â”‚   â”‚               â”‚   â””â”€â”€ ğŸ“ TokenEmulator
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Node
â”‚   â”‚               â”‚   â”œâ”€â”€ ğŸ“ Expr
â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ ğŸ“ AssignOp
â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ ğŸ“ BinaryOp
â”‚   â”‚               â”‚   â”‚   â””â”€â”€ ğŸ“ Cast
â”‚   â”‚               â”‚   â”œâ”€â”€ ğŸ“ Name
â”‚   â”‚               â”‚   â”œâ”€â”€ ğŸ“ Scalar
â”‚   â”‚               â”‚   â”‚   â””â”€â”€ ğŸ“ MagicConst
â”‚   â”‚               â”‚   â””â”€â”€ ğŸ“ Stmt
â”‚   â”‚               â”‚       â””â”€â”€ ğŸ“ TraitUseAdaptation
â”‚   â”‚               â”œâ”€â”€ ğŸ“ NodeVisitor
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Parser
â”‚   â”‚               â””â”€â”€ ğŸ“ PrettyPrinter
â”‚   â”œâ”€â”€ ğŸ“ phar-io
â”‚   â”‚   â”œâ”€â”€ ğŸ“ manifest
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ src
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ exceptions
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ values
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ xml
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ tools
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ php-cs-fixer.d
â”‚   â”‚   â””â”€â”€ ğŸ“ version
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ constraints
â”‚   â”‚           â””â”€â”€ ğŸ“ exceptions
â”‚   â”œâ”€â”€ ğŸ“ php-http
â”‚   â”œâ”€â”€ ğŸ“ phpdocumentor
â”‚   â”‚   â”œâ”€â”€ ğŸ“ reflection-common
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ reflection-docblock
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ DocBlock
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Tags
â”‚   â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Factory
â”‚   â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Formatter
â”‚   â”‚   â”‚       â”‚       â””â”€â”€ ğŸ“ Reference
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Exception
â”‚   â”‚   â””â”€â”€ ğŸ“ type-resolver
â”‚   â”‚       â”œâ”€â”€ ğŸ“ docs
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ PseudoTypes
â”‚   â”‚           â””â”€â”€ ğŸ“ Types
â”‚   â”œâ”€â”€ ğŸ“ phpstan
â”‚   â”‚   â”œâ”€â”€ ğŸ“ phpdoc-parser
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Ast
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ ConstExpr
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ NodeVisitor
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ PhpDoc
â”‚   â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Doctrine
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Type
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Lexer
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Parser
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Printer
â”‚   â”‚   â””â”€â”€ ğŸ“ phpstan
â”‚   â”‚       â””â”€â”€ ğŸ“ conf
â”‚   â”œâ”€â”€ ğŸ“ phpunit
â”‚   â”‚   â”œâ”€â”€ ğŸ“ php-code-coverage
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Data
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Driver
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Node
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Report
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Html
â”‚   â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Renderer
â”‚   â”‚   â”‚       â”‚   â”‚       â””â”€â”€ ğŸ“ Template
â”‚   â”‚   â”‚       â”‚   â”‚           â”œâ”€â”€ ğŸ“ css
â”‚   â”‚   â”‚       â”‚   â”‚           â”œâ”€â”€ ğŸ“ icons
â”‚   â”‚   â”‚       â”‚   â”‚           â””â”€â”€ ğŸ“ js
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Xml
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ StaticAnalysis
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ TestSize
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ TestStatus
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Util
â”‚   â”‚   â”œâ”€â”€ ğŸ“ php-file-iterator
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ php-invoker
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚   â”œâ”€â”€ ğŸ“ php-text-template
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚   â”œâ”€â”€ ğŸ“ php-timer
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚   â””â”€â”€ ğŸ“ phpunit
â”‚   â”‚       â”œâ”€â”€ ğŸ“ schema
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Event
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Dispatcher
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Emitter
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Events
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Application
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Test
â”‚   â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Assertion
â”‚   â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ HookMethod
â”‚   â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Issue
â”‚   â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Lifecycle
â”‚   â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Outcome
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ TestDouble
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ TestRunner
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ TestSuite
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Value
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Runtime
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Telemetry
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Test
â”‚   â”‚           â”‚       â”‚   â””â”€â”€ ğŸ“ TestData
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ TestSuite
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Framework
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Assert
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Attributes
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Constraint
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Boolean
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Cardinality
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Equality
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Filesystem
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Math
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Object
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Operator
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ String
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Traversable
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Type
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Incomplete
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ ObjectEquals
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Skipped
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ MockObject
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Generator
â”‚   â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ templates
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Runtime
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Api
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Builder
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Interface
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Rule
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Stub
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ TestSize
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ TestStatus
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Logging
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ JUnit
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ TeamCity
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ TestDox
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ TestResult
â”‚   â”‚           â”‚           â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Metadata
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Api
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Parser
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Annotation
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Version
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Runner
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Baseline
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Extension
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Filter
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ GarbageCollection
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ResultCache
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ TestResult
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”œâ”€â”€ ğŸ“ TextUI
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Command
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Commands
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Configuration
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Cli
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Value
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Xml
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ CodeCoverage
â”‚   â”‚           â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Report
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Logging
â”‚   â”‚           â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ TestDox
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Migration
â”‚   â”‚           â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Migrations
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ SchemaDetector
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Validator
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Output
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Default
â”‚   â”‚           â”‚       â”‚   â””â”€â”€ ğŸ“ ProgressPrinter
â”‚   â”‚           â”‚       â”‚       â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Printer
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ TestDox
â”‚   â”‚           â””â”€â”€ ğŸ“ Util
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Http
â”‚   â”‚               â”œâ”€â”€ ğŸ“ PHP
â”‚   â”‚               â”‚   â””â”€â”€ ğŸ“ Template
â”‚   â”‚               â””â”€â”€ ğŸ“ Xml
â”‚   â”œâ”€â”€ ğŸ“ psr
â”‚   â”‚   â”œâ”€â”€ ğŸ“ container
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ event-dispatcher
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ http-client
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ http-factory
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ http-message
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ docs
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ log
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â””â”€â”€ ğŸ“ simple-cache
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ ralouphie
â”‚   â”‚   â””â”€â”€ ğŸ“ getallheaders
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ react
â”‚   â”‚   â”œâ”€â”€ ğŸ“ cache
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ child-process
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ dns
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Config
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Model
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Protocol
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Query
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Resolver
â”‚   â”‚   â”œâ”€â”€ ğŸ“ event-loop
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Tick
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Timer
â”‚   â”‚   â”œâ”€â”€ ğŸ“ promise
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚   â”œâ”€â”€ ğŸ“ socket
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â””â”€â”€ ğŸ“ stream
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ revolt
â”‚   â”‚   â””â”€â”€ ğŸ“ event-loop
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â””â”€â”€ ğŸ“ EventLoop
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Driver
â”‚   â”‚               â””â”€â”€ ğŸ“ Internal
â”‚   â”œâ”€â”€ ğŸ“ sebastian
â”‚   â”‚   â”œâ”€â”€ ğŸ“ cli-parser
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚   â”œâ”€â”€ ğŸ“ code-unit
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚   â”œâ”€â”€ ğŸ“ code-unit-reverse-lookup
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ comparator
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚   â”œâ”€â”€ ğŸ“ complexity
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Complexity
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Visitor
â”‚   â”‚   â”œâ”€â”€ ğŸ“ diff
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Output
â”‚   â”‚   â”œâ”€â”€ ğŸ“ environment
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ exporter
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ global-state
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚   â”œâ”€â”€ ğŸ“ lines-of-code
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Exception
â”‚   â”‚   â”œâ”€â”€ ğŸ“ object-enumerator
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ object-reflector
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ recursion-context
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ type
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ exception
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ type
â”‚   â”‚   â””â”€â”€ ğŸ“ version
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ spatie
â”‚   â”‚   â””â”€â”€ ğŸ“ array-to-xml
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ symfony
â”‚   â”‚   â”œâ”€â”€ ğŸ“ console
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Attribute
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ CI
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Command
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ CommandLoader
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Completion
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Output
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ DataCollector
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Debug
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ DependencyInjection
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Descriptor
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Event
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ EventListener
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Formatter
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Helper
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Input
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Logger
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Messenger
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Output
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Question
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Resources
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ bin
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ SignalRegistry
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Style
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Tester
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Constraint
â”‚   â”‚   â”œâ”€â”€ ğŸ“ deprecation-contracts
â”‚   â”‚   â”œâ”€â”€ ğŸ“ event-dispatcher
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Attribute
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Debug
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ DependencyInjection
â”‚   â”‚   â”œâ”€â”€ ğŸ“ event-dispatcher-contracts
â”‚   â”‚   â”œâ”€â”€ ğŸ“ filesystem
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Exception
â”‚   â”‚   â”œâ”€â”€ ğŸ“ finder
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Comparator
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Iterator
â”‚   â”‚   â”œâ”€â”€ ğŸ“ options-resolver
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Debug
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Exception
â”‚   â”‚   â”œâ”€â”€ ğŸ“ polyfill-ctype
â”‚   â”‚   â”œâ”€â”€ ğŸ“ polyfill-intl-grapheme
â”‚   â”‚   â”œâ”€â”€ ğŸ“ polyfill-intl-normalizer
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ stubs
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ unidata
â”‚   â”‚   â”œâ”€â”€ ğŸ“ polyfill-mbstring
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ unidata
â”‚   â”‚   â”œâ”€â”€ ğŸ“ polyfill-php80
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ stubs
â”‚   â”‚   â”œâ”€â”€ ğŸ“ polyfill-php81
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ stubs
â”‚   â”‚   â”œâ”€â”€ ğŸ“ polyfill-php84
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ stubs
â”‚   â”‚   â”œâ”€â”€ ğŸ“ process
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Messenger
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Pipes
â”‚   â”‚   â”œâ”€â”€ ğŸ“ service-contracts
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Attribute
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Test
â”‚   â”‚   â”œâ”€â”€ ğŸ“ stopwatch
â”‚   â”‚   â””â”€â”€ ğŸ“ string
â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚       â”œâ”€â”€ ğŸ“ Inflector
â”‚   â”‚       â”œâ”€â”€ ğŸ“ Resources
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ bin
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ data
â”‚   â”‚       â””â”€â”€ ğŸ“ Slugger
â”‚   â”œâ”€â”€ ğŸ“ theseer
â”‚   â”‚   â””â”€â”€ ğŸ“ tokenizer
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ vimeo
â”‚   â”‚   â””â”€â”€ ğŸ“ psalm
â”‚   â”‚       â”œâ”€â”€ ğŸ“ dictionaries
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ autogen
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ override
â”‚   â”‚       â”œâ”€â”€ ğŸ“ docs
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ annotating_code
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ type_syntax
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ contributing
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ manipulating_code
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ running_psalm
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ issues
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ plugins
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ security_analysis
â”‚   â”‚       â”œâ”€â”€ ğŸ“ src
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Psalm
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ CodeLocation
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Config
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Internal
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Algebra
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Analyzer
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ FunctionLike
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Statements
â”‚   â”‚       â”‚       â”‚   â”‚       â”œâ”€â”€ ğŸ“ Block
â”‚   â”‚       â”‚       â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ IfElse
â”‚   â”‚       â”‚       â”‚   â”‚       â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚       â”‚       â”‚   â”‚       â””â”€â”€ ğŸ“ Expression
â”‚   â”‚       â”‚       â”‚   â”‚           â”œâ”€â”€ ğŸ“ Assignment
â”‚   â”‚       â”‚       â”‚   â”‚           â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚       â”‚       â”‚   â”‚           â”œâ”€â”€ ğŸ“ BinaryOp
â”‚   â”‚       â”‚       â”‚   â”‚           â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚       â”‚       â”‚   â”‚           â”œâ”€â”€ ğŸ“ Call
â”‚   â”‚       â”‚       â”‚   â”‚           â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚       â”‚       â”‚   â”‚           â””â”€â”€ ğŸ“ Fetch
â”‚   â”‚       â”‚       â”‚   â”‚               â””â”€â”€ ... (depth limit reached)
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Cli
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Codebase
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ DataFlow
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Diff
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ ExecutionEnvironment
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ FileManipulation
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Fork
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Json
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ LanguageServer
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ Client
â”‚   â”‚       â”‚       â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Progress
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ Provider
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Server
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ PhpTraverser
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ PhpVisitor
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Reflector
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ PluginManager
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Command
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Provider
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ AddRemoveTaints
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ ParamsProvider
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ PropertyTypeProvider
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ ReturnTypeProvider
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Scanner
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ UnresolvedConstant
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Scope
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Stubs
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Generator
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Type
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ Comparator
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ ParseTree
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ TypeAlias
â”‚   â”‚       â”‚       â”‚   â””â”€â”€ ğŸ“ TypeVisitor
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Issue
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Node
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Expr
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ AssignOp
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ BinaryOp
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Cast
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Name
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Scalar
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ MagicConst
â”‚   â”‚       â”‚       â”‚   â””â”€â”€ ğŸ“ Stmt
â”‚   â”‚       â”‚       â”‚       â””â”€â”€ ğŸ“ TraitUseAdaptation
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Plugin
â”‚   â”‚       â”‚       â”‚   â””â”€â”€ ğŸ“ EventHandler
â”‚   â”‚       â”‚       â”‚       â””â”€â”€ ğŸ“ Event
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Progress
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Report
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ SourceControl
â”‚   â”‚       â”‚       â”‚   â””â”€â”€ ğŸ“ Git
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Storage
â”‚   â”‚       â”‚       â”‚   â””â”€â”€ ğŸ“ Assertion
â”‚   â”‚       â”‚       â””â”€â”€ ğŸ“ Type
â”‚   â”‚       â”‚           â””â”€â”€ ğŸ“ Atomic
â”‚   â”‚       â””â”€â”€ ğŸ“ stubs
â”‚   â”‚           â””â”€â”€ ğŸ“ extensions
â”‚   â””â”€â”€ ğŸ“ webmozart
â”‚       â””â”€â”€ ğŸ“ assert
â”‚           â””â”€â”€ ğŸ“ src
â”œâ”€â”€ ğŸ“„ .gitignore
â”œâ”€â”€ ğŸ“„ build_generatapi.sh
â”œâ”€â”€ ğŸ“„ composer.json
â”œâ”€â”€ ğŸ“„ coverage-checker.php
â”œâ”€â”€ ğŸ“„ DEPENDENCIES.md
â”œâ”€â”€ ğŸ“„ LICENSE
â”œâ”€â”€ ğŸ“„ llms.sh
â”œâ”€â”€ ğŸ“„ openapi.json
â”œâ”€â”€ ğŸ“„ openapi.sha256
â”œâ”€â”€ ğŸ“„ openapitools.json
â”œâ”€â”€ ğŸ“„ phpstan-baseline.neon
â”œâ”€â”€ ğŸ“„ phpstan.neon.dist
â”œâ”€â”€ ğŸ“„ phpunit.xml.dist
â”œâ”€â”€ ğŸ“„ psalm.xml
â”œâ”€â”€ ğŸ“„ README.md
â”œâ”€â”€ ğŸ“„ test.sh
â””â”€â”€ ğŸ“„ verify-deployment.php


<documents>
<document index="1">
<source>.editorconfig</source>
<document_content>
; this_file: .editorconfig
root = true

[*]
charset = utf-8
end_of_line = lf
insert_final_newline = true
indent_style = space
indent_size = 4
trim_trailing_whitespace = true

[*.md]
indent_size = 2
trim_trailing_whitespace = false

[*.{yml,yaml,json}]
indent_size = 2

[*.php]
indent_size = 4
</document_content>
</document>

<document index="2">
<source>.gitattributes</source>
<document_content>
# this_file: .gitattributes
* text=auto eol=lf

/docs export-ignore
/tests export-ignore
/.github export-ignore
/build_generatapi.sh export-ignore
/openapi.json export-ignore
/openapi.sha256 export-ignore
</document_content>
</document>

<document index="3">
<source>.gitignore</source>
<document_content>
# this_file: .gitignore
/vendor/
/.phpunit.result.cache
/.phpunit.cache/
/.php-cs-fixer.cache
/.psalm-cache/
external/
</document_content>
</document>

<document index="4">
<source>.php-cs-fixer.dist.php</source>
<document_content>
<?php

// this_file: .php-cs-fixer.dist.php

/**
 * @generated
 * @link https://github.com/FriendsOfPHP/PHP-CS-Fixer/blob/HEAD/doc/config.rst
 */
$finder = PhpCsFixer\Finder::create()
    ->in(__DIR__)
    ->exclude('vendor')
    ->exclude('test')
    ->exclude('tests')
    ->exclude('src/Ragie/Api/lib')
    ->exclude('src/Ragie/Api/docs')
    ->exclude('src/Ragie/Api/test')
;

$config = new PhpCsFixer\Config();

return $config
    ->setRules([
        '@PSR12' => true,
        'phpdoc_order' => true,
        'array_syntax' => ['syntax' => 'short'],
        'strict_comparison' => true,
        'strict_param' => true,
        'no_trailing_whitespace' => false,
        'no_trailing_whitespace_in_comment' => false,
        'braces' => false,
        'single_blank_line_at_eof' => false,
        'blank_line_after_namespace' => false,
        'no_leading_import_slash' => false,
    ])
    ->setFinder($finder);
</document_content>
</document>

<document index="5">
<source>DEPENDENCIES.md</source>
<document_content>
---
this_file: DEPENDENCIES.md
---

# Dependencies

| Package | Why it is included |
| --- | --- |
| `guzzlehttp/guzzle` | PSR-18 HTTP client used by the generated Ragie API bindings. |
| `psr/http-client` | Interface so consumers can supply their own PSR-18 HTTP client. |
| `psr/log` | Standard logging interfaces consumed by `Client::withLogger()` / `StructuredLogger`. |
| `psr/simple-cache` | PSR-16 cache contract for the optional query cache adapters. |
| `phpunit/phpunit` | Test runner for the unit + integration suites. |
| `phpstan/phpstan` | Static analysis to catch type and logic issues early in CI. |
| `vimeo/psalm` | Complements PHPStan with additional static analysis coverage. |
| `friendsofphp/php-cs-fixer` | Enforces consistent coding style across the repository. |
</document_content>
</document>

<document index="6">
<source>LICENSE</source>
<document_content>
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</document_content>
</document>

<document index="7">
<source>README.md</source>
<document_content>
# Ragie PHP Client

[![PHP Version](https://img.shields.io/badge/php-%3E%3D8.1-blue)](https://php.net)
[![License](https://img.shields.io/badge/license-MIT-green)](LICENSE)

A modern PHP client for the [Ragie AI](https://ragie.ai/) API, providing both a high-level convenience interface and full access to the underlying generated API client.

## Features

- **ğŸš€ Simple High-Level API** â€“ Dead-simple methods for common retrieval tasks
- **ğŸ“¦ Batch Processing** â€“ Process multiple queries efficiently with `retrieveBatch()`
- **âš¡ Async Retrieval** â€“ Fire off concurrent lookups with `retrieveAsync()` / `retrieveConcurrent()`
- **âš™ï¸ Fluent Configuration** â€“ Set defaults once with `withDefaultTopK()` and `withDefaultRerank()`
- **ğŸ’¾ Query Caching** â€“ Drop in any PSR-16 cache via `withCache()` to reduce duplicate calls
- **ğŸ“Š Retrieval Telemetry** â€“ Built-in metrics + cost trackers quantify throughput and spend
- **ğŸ“ Structured Logging** â€“ Pipe retrieval events into your PSR-3 logger for observability
- **ğŸ”§ Full API Access** â€“ Direct access to every Ragie REST endpoint through the generated client
- **ğŸ’ª Type-Safe** â€“ Full PHP 8.1+ type hints and strict typing
- **ğŸ§ª Well-Tested** â€“ Comprehensive PHPUnit suite covering retrieval, caching, and retries
- **ğŸ“š Fully Documented** â€“ Inline PHPDoc with code examples
- **ğŸ¯ Fluent Interface** â€“ Chainable methods for clean, readable code
- **Need LLM orchestration?** â€“ Pair this library with [`vexy/paragra-php`](../paragra-php) for moderation, OpenAI/AskYoda fallbacks, and multi-provider RAG flows

## Table of Contents

- [Installation](#installation)
- [Quick Start](#quick-start)
- [High-Level Client](#high-level-client)
- [Advanced Usage](#advanced-usage)
- [Low-Level API Access](#low-level-api-access)
- [Work with Orchestrators (e.g., ParaGra)](#work-with-orchestrators-eg-paragra)
- [Upgrading to v0.4.0](#upgrading-to-v040)
- [Examples](#examples)
- [Testing](#testing)
- [Documentation](#documentation)
- [Architecture](#architecture)
- [Error Handling](#error-handling)
- [Environment Variables Reference](#environment-variables-reference)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)

## Installation

Install via Composer:

```bash
composer require ragie/ragie-php
```

**Requirements:** PHP 8.1 or higher

## Quick Start

```php
<?php
require_once 'vendor/autoload.php';

use Ragie\Client;

// Initialize the client
$ragie = new Client('your-api-key');

// Perform a simple retrieval
$result = $ragie->retrieve('What is machine learning?');

// Access results
foreach ($result->getChunks() as $chunk) {
    echo $chunk->getText() . "\n";
}
```

## High-Level Client

The high-level client provides simplified methods for the most common RAG operations:

### Initialization

```php
use Ragie\Client;

// With default base URL (https://api.ragie.ai)
$ragie = new Client('your-api-key');

// With custom base URL
$ragie = new Client('your-api-key', 'https://custom.api.url');

// With custom HTTP client
$ragie = new Client('your-api-key', null, new GuzzleHttp\Client([
    'timeout' => 30,
]));
```

### Basic Retrieval

```php
// Simple retrieval with defaults
$result = $ragie->retrieve('What is RAG?');

// Check if results were found
if ($result->isEmpty()) {
    echo "No results found\n";
    exit;
}

// Get result count
echo "Found {$result->count()} chunks\n";

// Get the top result
$topChunk = $result->getTopChunk();
echo "Best match: {$topChunk->getText()}\n";
echo "Score: {$topChunk->getScore()}\n";
```

### Working with Results

The `RetrievalResult` class provides convenient methods for accessing retrieval data:

```php
$result = $ragie->retrieve('query');

// Get all chunks
$chunks = $result->getChunks();

// Get just the text from all chunks
$texts = $result->getChunkTexts();

// Get unique document IDs
$documentIds = $result->getDocumentIds();

// Check if empty
if ($result->isEmpty()) {
    // Handle no results
}

// Use Countable interface
echo count($result) . " results found\n";

// Access underlying API response if needed
$rawRetrieval = $result->getUnderlyingRetrieval();
```

## Advanced Usage

### Using RetrievalOptions

Customize retrieval behavior with the fluent `RetrievalOptions` builder:

```php
use Ragie\RetrievalOptions;

$options = RetrievalOptions::create()
    ->withTopK(20)                    // Get top 20 results
    ->withRerank()                    // Enable reranking
    ->withMaxChunksPerDocument(3)     // Max 3 chunks per document
    ->withRecencyBias()               // Prefer recent documents
    ->withPartition('customer-123')   // Scope to partition
    ->withFilter([                    // Apply metadata filter
        'category' => 'documentation',
        'priority' => ['$gt' => 5]
    ]);

$result = $ragie->retrieve('sales strategy', $options);
```

### Metadata Filters

RetrievalOptions supports powerful metadata filtering:

```php
// Simple equality
$options = RetrievalOptions::create()
    ->withFilter(['category' => 'docs']);

// In array operator
$options = RetrievalOptions::create()
    ->withFilter([
        'department' => ['$in' => ['sales', 'marketing']]
    ]);

// Greater than operator
$options = RetrievalOptions::create()
    ->withFilter([
        'priority' => ['$gt' => 5]
    ]);

// Complex filters
$options = RetrievalOptions::create()
    ->withFilter([
        'status' => 'published',
        'category' => ['$in' => ['blog', 'article']],
        'views' => ['$gte' => 1000]
    ]);
```

### Inline Options

For quick customization, options can be built inline:

```php
$result = $ragie->retrieve(
    'machine learning best practices',
    RetrievalOptions::create()
        ->withTopK(15)
        ->withRerank(true)
        ->withFilter(['type' => 'guide'])
);
```

### Fluent Configuration

Set default retrieval parameters once and apply them to all subsequent calls:

```php
// Configure defaults
$ragie = (new Client('your-api-key'))
    ->withDefaultTopK(20)
    ->withDefaultRerank(true);

// All subsequent calls use these defaults
$result1 = $ragie->retrieve('What is RAG?');  // Uses top_k=20, rerank=true
$result2 = $ragie->retrieve('Explain vectors');  // Uses top_k=20, rerank=true

// Explicit options override defaults
$result3 = $ragie->retrieve(
    'Special query',
    RetrievalOptions::create()->withTopK(50)  // Overrides default of 20
);
```

### Optional Query Cache

Avoid duplicate API calls for identical queries by pairing the client with a cache:

```php
use Ragie\Cache\InMemoryCache;
use Ragie\Cache\SimpleCacheQueryCache;

$ragie = (new Client('your-api-key'))
    ->withDefaultTopK(20)
    ->withCache(new InMemoryCache(), ttlSeconds: 300);

$first = $ragie->retrieve('Explain retrievers');
$second = $ragie->retrieve('Explain retrievers'); // Served from cache
```

Already have Redis, Memcached, or Symfony cache pools? Bridge any PSR-16 cache through the adapter:

```php
use Psr\SimpleCache\CacheInterface;
use Ragie\Cache\SimpleCacheQueryCache;

/** @var CacheInterface $redisCache */
$redisCache = $container->get(CacheInterface::class);

$ragie = (new Client('api-key'))
    ->withCache(new SimpleCacheQueryCache($redisCache), ttlSeconds: 600);
```

Each entry is automatically scoped by query, retrieval options, and base URL so different settings never collide.

### Batch Retrieval

Process multiple queries efficiently:

```php
$queries = [
    'What is machine learning?',
    'Explain neural networks',
    'How does gradient descent work?'
];

// Process all queries
$results = $ragie->retrieveBatch($queries);

// Access results in same order as queries
foreach ($results as $i => $result) {
    echo "Query: {$queries[$i]}\n";
    echo "Top result: {$result->getTopChunk()->getText()}\n\n";
}

// Apply options to all queries in batch
$options = RetrievalOptions::create()
    ->withTopK(10)
    ->withRerank();

$results = $ragie->retrieveBatch($queries, $options);

// Batch also respects fluent defaults
$ragie->withDefaultTopK(15)->withDefaultRerank();
$results = $ragie->retrieveBatch($queries);  // All use top_k=15, rerank=true
```

### Asynchronous Retrieval

Need to overlap outbound requests or keep your worker free while Ragie searches? Every retrieval helper now has a promise-based counterpart.

- `retrieveAsync()` sanitizes, applies defaults, and returns a `PromiseInterface` that resolves to `RetrievalResult`
- `retrieveConcurrent()` fans out queries via Guzzle promises and unwraps them in original order
- Metrics, caching, cost tracking, and structured logging behave exactly like the synchronous path

```php
use Ragie\Client;

$client = (new Client('your-api-key'))
    ->withDefaultTopK(12);

// Kick off a single query and wait later
$promise = $client->retrieveAsync('Explain embeddings vs dense vector search');
$result = $promise->wait();

// Fan out three lookups concurrently
$concurrent = $client->retrieveConcurrent([
    'What is retrieval augmented generation?',
    'How does reranking help?',
    'Give me a refresher on chunking strategies',
]);

foreach ($concurrent as $i => $retrieval) {
    $topChunk = $retrieval->getTopChunk();
    echo "Query {$i}: " . ($topChunk?->getText() ?? 'No results') . PHP_EOL;
}
```

### Structured Logging (PSR-3)

Need structured telemetry without building another logging stack? `Client::withLogger()` accepts any PSR-3 logger and `Ragie\Logging\StructuredLogger` emits stable events for retrieval start/success/failure so you can centralise observability.

```php
use Monolog\Handler\StreamHandler;
use Monolog\Logger;
use Ragie\Client;
use Ragie\Logging\StructuredLogger;

$logger = new Logger('ragie');
$logger->pushHandler(new StreamHandler('php://stdout'));

$client = (new Client($_ENV['RAGIE_API_KEY']))
    ->withLogger(new StructuredLogger($logger));

$client->retrieve('Explain the latest release notes');
```

Event names stay stable, which makes downstream filtering trivial:

- `ragie.retrieve.start`
- `ragie.retrieve.success`
- `ragie.retrieve.failure`

Call `Client::getStructuredLogger()` when you need to re-use the configured logger elsewhere (for example, to pipe the same instance into ParaGra or another orchestrator).

## Low-Level API Access

For document management and other operations, access the underlying generated API:

### Document Management

```php
// Create a document from file
$document = $ragie->getDocumentsApi()->createDocument([
    'file' => new \SplFileObject('/path/to/file.pdf'),
    'metadata' => ['category' => 'manual']
]);

// Create from URL
$document = $ragie->getDocumentsApi()->createDocumentFromUrl([
    'url' => 'https://example.com/document.pdf',
    'name' => 'Example Document'
]);

// Create from raw text
$document = $ragie->getDocumentsApi()->createDocumentRaw([
    'text' => 'This is the document content...',
    'name' => 'Text Document'
]);

// List documents
$documents = $ragie->getDocumentsApi()->listDocuments();

// Delete a document
$ragie->getDocumentsApi()->deleteDocument($documentId);
```

### Other API Operations

```php
// Access Retrievals API (same as high-level retrieve() but lower level)
$retrieval = $ragie->getRetrievalsApi()->retrieve($retrieveParams);

// Access Responses API (for AI response generation)
$response = $ragie->getResponsesApi()->createResponseResponsesPost($request);

// Access Configuration
$config = $ragie->getConfiguration();
```

## Work with Orchestrators (e.g., ParaGra)

Version 0.5 cements **ragie-php** as a Ragie-only SDK: retrieval, caching, retries, and instrumentation. LLM sessions, moderation guards, AskYoda fallbacks, and config factories now belong to orchestration layers such as [`vexy/paragra-php`](../paragra-php).

Those orchestrators sit on top of ragie-php and typically provide:

- Shared prompt builders plus wrappers for OpenAI/Cerebras/Gemini/AskYoda.
- Pool-based fallback + key rotation so free/paid tiers rotate predictably.
- Optional moderation middleware before Ragie retrieval happens.
- Configuration builders (`fromEnv()`, `fromConfig()`) that wire Ragie + LLM secrets at once.

If you previously used `RagAnswerer::fromEnv()` or the AskYoda fallback scripts, add your orchestrator alongside ragie-php:

```bash
composer require ragie/ragie-php vexy/paragra-php
```

```php
use ParaGra\ParaGra;

$config = require __DIR__ . '/paragra.php'; // Pools + API keys, built via ParaGra tools
$paragra = ParaGra::fromConfig($config);

$answer = $paragra->answer('Summarise the changelog', [
    'retrieval' => ['top_k' => 6],
]);

echo $answer['answer'];
```

ask.vexy.art already consumes ParaGra, so you can copy its configuration approach when you are ready to adopt a richer multi-provider stack. ragie-php deliberately remains a single-provider SDK.

## Upgrading After the Namespace Cleanup

`ragie-php` v0.5 removes the temporary proxy layer that used to emit â€œinstall ParaGraâ€ warnings. Any references to the old namespaces below now result in a regular PHP â€œclass not foundâ€ error until you install a third-party orchestrator:

- `Ragie\Assistant\{RagAnswerer,RagAnswer}`
- `Ragie\Llm\{OpenAiChatClient,OpenAiChatConfig,PromptBuilder,AskYodaClient,AskYodaResponse,ChatResponse,ChatRequestOptions,ChatUsage}`
- `Ragie\Moderation\{OpenAiModerator,ModerationException,ModerationResult}`
- `Ragie\ConfigValidator` and `Ragie\ExceptionEnhancer`

To upgrade older projects:

1. Install ParaGra next to ragie-php: `composer require vexy/paragra-php`.
2. Update imports from the removed Ragie namespaces to their ParaGra equivalents.
3. Remove moderation/chat/config helpers from your codebase unless they live inside ParaGra (or another orchestrator).
4. Run your PHPUnit/CI suite to confirm no files still reference the removed namespaces before bumping ragie-php.

## Examples

Each example is a runnable PHP script inside `examples/` so you can see the client in action with minimal setup.

### Basic Retrieval ([examples/retrieve.php](examples/retrieve.php))
```bash
RAGIE_API_KEY=your-key php examples/retrieve.php
```
Covers the core `Client::retrieve()` call, iterating chunks, and inspecting document metadata.

### Advanced Retrieval ([examples/retrieve_advanced.php](examples/retrieve_advanced.php))
```bash
RAGIE_API_KEY=your-key php examples/retrieve_advanced.php
```
Shows reranking toggles, metadata filters, partitions, and fluent option composition.

### Input Validation ([examples/input_validation.php](examples/input_validation.php))
```bash
RAGIE_API_KEY=your-key php examples/input_validation.php
```
Demonstrates how `InputSanitizer::sanitizeAndValidate()` guards against empty or overlong queries, plus how to handle validation errors in web controllers.

### Error Handling ([examples/error_handling.php](examples/error_handling.php))
```bash
RAGIE_API_KEY=your-key php examples/error_handling.php
```
Walks through structured try/catch blocks, HTTP status inspection, exponential backoff retries, and production logging without relying on the old ExceptionEnhancer helper.

### Interactive CLI ([examples/interactive-demo.php](examples/interactive-demo.php))
```bash
RAGIE_API_KEY=your-key php examples/interactive-demo.php
```
Launches a readline-powered CLI that streams retrieval timing, chunk previews, and lets you tweak chunk limits via `RAGIE_INTERACTIVE_MAX_*` env vars.

### Cached Retrieval ([examples/retrieve_with_cache.php](examples/retrieve_with_cache.php))
```bash
RAGIE_API_KEY=your-key php examples/retrieve_with_cache.php "Summarize Ragie caching"
```
Shows how to pass the bundled `InMemoryCache` into `Client::withCache()` so identical questions resolve instantly from memory. Adjust `RAGIE_CACHE_TTL` or change the question text to observe cache invalidation.

### Concurrent Retrieval ([examples/retrieve_concurrent.php](examples/retrieve_concurrent.php))
```bash
RAGIE_API_KEY=your-key php examples/retrieve_concurrent.php
```
Runs the same set of queries via `retrieveBatch()` and `retrieveConcurrent()` while timing both approaches, highlighting when to reach for promises to fan out Ragie API calls.

## Testing

Run the test suite:

```bash
# Run all tests
./test.sh

# Run specific test suites
vendor/bin/phpunit tests/ClientTest.php
vendor/bin/phpunit tests/RetrievalOptionsTest.php
vendor/bin/phpunit tests/RetrievalResultTest.php

# Run with detailed output
vendor/bin/phpunit --testdox
```

Quality assurance:

```bash
# Code style check
composer lint

# Static analysis (PHPStan level 9)
composer stan

# Psalm static analysis
composer psalm

# Run all QA checks
composer qa

# Generate HTML/text coverage reports
composer coverage

# Enforce minimum coverage (80% line coverage)
composer coverage-check
```

### Benchmarking Retrieval Latency

Measure end-to-end retrieval timings against your live Ragie workspace using the optional benchmark script:

```bash
cd ragie-php
RAGIE_API_KEY=sk-xxx php benchmarks/RetrievalBenchmark.php
```

Available knobs (all optional, set as environment variables):

| Variable | Default | Description |
| --- | --- | --- |
| `RAGIE_BENCH_ITERATIONS` | `3` | Number of retrievals per query |
| `RAGIE_BENCH_QUERIES` | `What is Ragie AI? \| ...` | Pipe-separated list of questions to run |
| `RAGIE_BENCH_DELAY` | `0` | Seconds to wait between iterations (helps dodge rate limits) |

Each query logs individual runs plus a `TimingSummary` (avg, min, max, p95, success ratio, chunk count). The script exits with a non-zero code if every iteration for a query fails so CI can catch upstream outages.

## Documentation

### Cookbook

- [docs/COOKBOOK.md](docs/COOKBOOK.md) â€” Pragmatic recipes for one-liner setups, caching, fallback orchestration, error handling, and batch retrieval patterns.

### API Documentation

- [High-Level Client Classes](src/)
  - `Ragie\Client` - Main entry point
  - `Ragie\RetrievalOptions` - Fluent options builder
  - `Ragie\RetrievalResult` - Result wrapper

- [Generated API Documentation](src/Ragie/Api/docs/)
  - Full OpenAPI-generated documentation
  - All available endpoints and models

### Additional Resources

- [Ragie AI Documentation](https://docs.ragie.ai/)
- [API Reference](https://docs.ragie.ai/api-reference)
- [Metadata Filters Guide](https://docs.ragie.ai/docs/metadata-filters)

## Architecture

The client has two layers:

1. **High-Level Layer** (`src/`)
   - Simple, opinionated API for common tasks
   - Focuses on retrieval operations (most common RAG use case)
   - Fluent interfaces and convenience methods

2. **Generated Layer** (`src/Ragie/Api/`)
   - Complete, low-level access to all API endpoints
   - Auto-generated from OpenAPI specification
   - Never manually edited (regenerated when API updates)

This design gives you:
- **Simplicity** for common operations
- **Power** for advanced use cases
- **Future-proof** as API evolves

## Error Handling

```php
use Ragie\Client;

try {
    $ragie = new Client('your-api-key');
    $result = $ragie->retrieve('query');

    // Work with results...

} catch (\InvalidArgumentException $e) {
    // Invalid input (empty query, invalid options, etc.)
    echo "Invalid input: {$e->getMessage()}\n";

} catch (\Ragie\Api\ApiException $e) {
    // API error (network, auth, rate limit, etc.)
    echo "API error: {$e->getMessage()}\n";
    echo "HTTP code: {$e->getCode()}\n";

} catch (\Exception $e) {
    // Other errors
    echo "Error: {$e->getMessage()}\n";
}
```

## Environment Variables Reference

### Core Configuration

| Variable | Required | Default | Description |
|----------|----------|---------|-------------|
| `RAGIE_API_KEY` | Yes | - | Your Ragie API key from https://ragie.ai/ |

Need OpenAI/AskYoda/Gemini credentials, moderation toggles, or fallback knobs? Those belong to your orchestrator (for example, [`../paragra-php/README.md`](../paragra-php/README.md) covers ParaGraâ€™s env matrix).

### Example .env File

```bash
RAGIE_API_KEY=your_ragie_api_key_here
```

## Troubleshooting

### "API key is required"

**Cause:** Missing or invalid `RAGIE_API_KEY` environment variable.

**Solution:**
```php
// Check if environment variable is set
if (!getenv('RAGIE_API_KEY')) {
    die("Error: RAGIE_API_KEY environment variable not set\n");
}

$ragie = new Client(getenv('RAGIE_API_KEY'));
```

### "HTTP 401 Unauthorized"

**Cause:** Invalid API key or incorrect authentication.

**Solutions:**
1. Verify your API key is correct
2. Check for extra whitespace in the key
3. Ensure the key hasn't expired
4. Generate a new key from https://ragie.ai/

```php
try {
    $ragie = new Client(trim(getenv('RAGIE_API_KEY')));
    $result = $ragie->retrieve('test');
} catch (\Ragie\Api\ApiException $e) {
    if ($e->getCode() === 401) {
        echo "Authentication failed. Please check your API key.\n";
    }
}
```

### "HTTP 429 Rate Limit Exceeded"

**Cause:** Too many requests to Ragie API.

**Solutions:**

1. **Delegate fallback to an orchestrator (e.g., ParaGra)** â€“ ParaGraâ€™s `PriorityPool` automatically rotates across free-tier and paid providers (Ragie, Cerebras, AskYoda, etc.). See [Work with Orchestrators (e.g., ParaGra)](#work-with-orchestrators-eg-paragra) for installation details.

2. **Implement retry logic with exponential backoff**:
```php
function retrieveWithRetry($ragie, $query, $maxRetries = 3) {
    $attempt = 0;
    $delay = 1; // Start with 1 second

    while ($attempt < $maxRetries) {
        try {
            return $ragie->retrieve($query);
        } catch (\Ragie\Api\ApiException $e) {
            if ($e->getCode() === 429 && $attempt < $maxRetries - 1) {
                echo "Rate limited. Retrying in {$delay}s...\n";
                sleep($delay);
                $delay *= 2; // Exponential backoff
                $attempt++;
            } else {
                throw $e;
            }
        }
    }
}
```

3. **Add delay between requests**:
```php
$queries = ['query1', 'query2', 'query3'];
foreach ($queries as $query) {
    $result = $ragie->retrieve($query);
    sleep(1); // 1 second delay between requests
}
```

### "Connection timeout" or "Network errors"

**Cause:** Network connectivity issues or slow API responses.

**Solutions:**

1. **Increase timeout**:
```php
use GuzzleHttp\Client as GuzzleClient;

$httpClient = new GuzzleClient([
    'timeout' => 60,          // 60 seconds request timeout
    'connect_timeout' => 10,  // 10 seconds connection timeout
]);

$ragie = new Client('your-api-key', null, $httpClient);
```

2. **Enable connection keep-alive** (already configured by default):
```php
// The client automatically uses keep-alive for better performance
// Connections are reused for up to 300 seconds
```

### "Empty results" or "No chunks found"

**Cause:** Query doesn't match any documents or filters are too restrictive.

**Solutions:**

1. **Check if documents exist**:
```php
$documents = $ragie->getDocumentsApi()->listDocuments();
if (empty($documents)) {
    echo "No documents found. Please upload documents first.\n";
}
```

2. **Broaden your search**:
```php
// Instead of:
$result = $ragie->retrieve('very specific technical term',
    RetrievalOptions::create()->withTopK(3)
);

// Try:
$result = $ragie->retrieve('general topic',
    RetrievalOptions::create()->withTopK(20)
);
```

3. **Remove filters**:
```php
// If using filters, try without them first
$result = $ragie->retrieve('your query');  // No filters
```

4. **Check document content**:
```php
$result = $ragie->retrieve('test query');
if ($result->isEmpty()) {
    echo "No results. This might mean:\n";
    echo "- No documents uploaded\n";
    echo "- Query doesn't match document content\n";
    echo "- Filters are too restrictive\n";
}
```

### "Content flagged by moderation"

**Cause:** Your own moderation guard rejected the query.

**Solution:** ragie-php no longer bundles OpenAI moderation wrappers. Either:

1. Use your orchestratorâ€™s moderation middleware (ParaGra ships `ParaGra\Moderation\OpenAiModerator`, for example) before calling its `answer()` helper, or
2. Call the OpenAI Moderation API (or another provider) directly in your application. If the response is flagged, short-circuit before handing the query to Ragie; otherwise call `$client->retrieve($query)` as usual.

### "Memory exhausted" with batch operations

**Cause:** Processing too many results at once.

**Solution:**

1. **Process in smaller batches**:
```php
$allQueries = [...]; // Large array
$batchSize = 10;

foreach (array_chunk($allQueries, $batchSize) as $batch) {
    $results = $ragie->retrieveBatch($batch);
    // Process results
    unset($results); // Free memory
}
```

2. **Use generators for large result sets**:
```php
function processQueries($ragie, $queries) {
    foreach ($queries as $query) {
        yield $ragie->retrieve($query);
    }
}

foreach (processQueries($ragie, $queries) as $result) {
    // Process one result at a time
}
```

### Performance is slow

**Solutions:**

1. **Use batch retrieval** instead of individual calls:
```php
// Slow:
foreach ($queries as $query) {
    $result = $ragie->retrieve($query);
}

// Faster:
$results = $ragie->retrieveBatch($queries);
```

2. **Enable connection pooling** (enabled by default):
```php
// Already configured - connections are reused automatically
```

3. **Use fluent defaults** to avoid rebuilding options:
```php
// Configure once
$ragie->withDefaultTopK(15)->withDefaultRerank(true);

// All subsequent calls reuse these settings
$result1 = $ragie->retrieve('query1');  // Fast
$result2 = $ragie->retrieve('query2');  // Fast
```

4. **Reduce top_k if you don't need many results**:
```php
$result = $ragie->retrieve('query',
    RetrievalOptions::create()->withTopK(5)  // Instead of default 10
);
```

## Contributing

This is an auto-generated client with a manually crafted high-level layer.

- **High-Level Code** (`src/*.php`): Contributions welcome
- **Generated Code** (`src/Ragie/Api/`): Do not edit - regenerated from OpenAPI spec

### Regenerating the OpenAPI client

Keep the generated layer current whenever Ragie ships a new spec:

1. **Download the latest spec** into the repo root (never point the generator at the remote URL directly):
   ```bash
   curl -sS https://api.ragie.ai/openapi.json -o openapi.json
   ```
2. **Run the generator** to refresh `src/Ragie/Api`, `.regen-stamp`, and the checksum:
   ```bash
   ./build_generatapi.sh
   ```
3. **Run the verification tests** (they confirm `openapi.json`, `openapi.sha256`, and `.regen-stamp` stay in sync):
   ```bash
   ./test.sh -- tests/unit/OpenApiArtifactsTest.php
   # or just run ./test.sh for the full suite
   ```
4. **Commit the artifacts**: include `openapi.json`, `openapi.sha256`, `src/Ragie/Api/`, and `src/Ragie/Api/.regen-stamp`.

`tests/unit/OpenApiArtifactsTest.php` enforces these steps, so CI will fail if the spec, checksum, or stamp drift apart.

## License

This project is licensed under the MIT License.

## Support

- **Issues**: [GitHub Issues](https://github.com/ragie/ragie-php/issues)
- **Documentation**: [Ragie Docs](https://docs.ragie.ai/)
- **API Support**: support@ragie.ai

## Changelog

See [CHANGELOG.md](CHANGELOG.md) for version history and updates.
</document_content>
</document>

<document index="8">
<source>benchmarks/RetrievalBenchmark.php</source>
<document_content>
#!/usr/bin/env php
<?php

// this_file: benchmarks/RetrievalBenchmark.php

declare(strict_types=1);

use Ragie\Benchmark\TimingSummary;
use Ragie\Client;

require __DIR__ . '/../vendor/autoload.php';

$apiKey = getenv('RAGIE_API_KEY') ?: ($_ENV['RAGIE_API_KEY'] ?? null);

if ($apiKey === null) {
    fwrite(
        STDERR,
        "Missing RAGIE_API_KEY. Set the variable before running the benchmark.\n"
    );
    exit(1);
}

$iterations = (int) (getenv('RAGIE_BENCH_ITERATIONS') ?? ($_ENV['RAGIE_BENCH_ITERATIONS'] ?? 3));

if ($iterations < 1) {
    $iterations = 3;
}

$delaySeconds = (float) (getenv('RAGIE_BENCH_DELAY') ?? ($_ENV['RAGIE_BENCH_DELAY'] ?? 0));

$queriesEnv = getenv('RAGIE_BENCH_QUERIES') ?? ($_ENV['RAGIE_BENCH_QUERIES'] ?? '');
$queries = array_values(array_filter(array_map('trim', explode('|', $queriesEnv))));

if ($queries === []) {
    $queries = [
        'What is Ragie AI?',
        'How does the AskYoda fallback behave?',
        'Summarize the Ragie PHP caching layer.',
    ];
}

printf(
    "\nRunning Ragie retrieval benchmark with %d iteration(s) per query...\n\n",
    $iterations
);

$client = new Client($apiKey);
$overallSuccess = true;

foreach ($queries as $query) {
    printf("Query: %s\n", $query);

    $timings = [];
    $chunkCounts = [];
    $errors = [];

    for ($i = 1; $i <= $iterations; $i++) {
        $start = microtime(true);

        try {
            $result = $client->retrieve($query);
            $duration = (microtime(true) - $start) * 1000;
            $timings[] = $duration;
            $chunkCounts[] = count($result->getChunks());

            printf(
                "  #%d success in %6.1f ms (%d chunks)\n",
                $i,
                $duration,
                end($chunkCounts)
            );
        } catch (Throwable $exception) {
            $duration = (microtime(true) - $start) * 1000;
            $errors[] = [
                'iteration' => $i,
                'code' => $exception->getCode(),
                'message' => $exception->getMessage(),
                'duration' => $duration,
            ];

            printf(
                "  #%d error after %6.1f ms: %s\n",
                $i,
                $duration,
                $exception->getMessage()
            );
        }

        if ($delaySeconds > 0 && $i < $iterations) {
            usleep((int) ($delaySeconds * 1_000_000));
        }
    }

    if ($timings !== []) {
        $summary = TimingSummary::fromTimings($timings);
        $avgChunks = $chunkCounts === [] ? 0.0 : array_sum($chunkCounts) / count($chunkCounts);

        printf(
            "  Summary: avg=%6.1f ms | p95=%6.1f ms | min=%6.1f ms | max=%6.1f ms | successes=%d/%d | chunksâ‰ˆ%.1f\n",
            $summary->getAverageMs(),
            $summary->getPercentileMs(95),
            $summary->getMinMs(),
            $summary->getMaxMs(),
            count($timings),
            $iterations,
            $avgChunks
        );
    } else {
        $overallSuccess = false;
        echo "  No successful runs recorded for this query.\n";
    }

    if ($errors !== []) {
        echo "  Failures:\n";
        foreach ($errors as $error) {
            printf(
                "    #%d code:%s after %6.1f ms -> %s\n",
                $error['iteration'],
                (string) $error['code'],
                $error['duration'],
                $error['message']
            );
        }
    }

    echo "\n";
}

if (!$overallSuccess) {
    fwrite(STDERR, "One or more queries failed completely. Check credentials and retry later.\n");
    exit(2);
}
</document_content>
</document>

<document index="9">
<source>build_generatapi.sh</source>
<document_content>
#!/usr/bin/env bash
# this_file: build_generatapi.sh

set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SPEC_FILE="${ROOT_DIR}/openapi.json"
CHECKSUM_FILE="${ROOT_DIR}/openapi.sha256"
CONFIG_FILE="${ROOT_DIR}/openapitools.json"
OUTPUT_DIR="${ROOT_DIR}/src/Ragie/Api"
STAMP_FILE="${OUTPUT_DIR}/.regen-stamp"

if [ ! -f "${SPEC_FILE}" ]; then
  echo "Missing local OpenAPI spec at ${SPEC_FILE}." >&2
  exit 1
fi

if command -v shasum >/dev/null 2>&1; then
  CHECKSUM="$(shasum -a 256 "${SPEC_FILE}" | awk '{print $1}')"
elif command -v sha256sum >/dev/null 2>&1; then
  CHECKSUM="$(sha256sum "${SPEC_FILE}" | awk '{print $1}')"
else
  echo "Neither shasum nor sha256sum is available to compute the spec checksum." >&2
  exit 1
fi

printf '%s\n' "${CHECKSUM}" > "${CHECKSUM_FILE}"

echo "Generating Ragie PHP client from local spec..."
openapi-generator-cli generate --config "${CONFIG_FILE}" --output "${OUTPUT_DIR}"

mkdir -p "$(dirname "${STAMP_FILE}")"
printf 'spec_sha=%s\n' "${CHECKSUM}" > "${STAMP_FILE}"
printf 'generated_at=%s\n' "$(date -Iseconds)" >> "${STAMP_FILE}"

echo "Generation completed. Spec checksum recorded in ${CHECKSUM_FILE}."
</document_content>
</document>

<document index="10">
<source>composer.json</source>
<document_content>
{
  "name": "ragie/ragie-php",
  "description": "PHP SDK for Ragie with generated client plus inference-focused helpers",
  "type": "library",
  "license": "MIT",

... (Data file content truncated to first 5 lines)
</document_content>
</document>

<document index="11">
<source>coverage-checker.php</source>
<document_content>
#!/usr/bin/env php
<?php

declare(strict_types=1);

// this_file: ragie-php/coverage-checker.php

use Ragie\Dev\Coverage\CoverageThresholdChecker;
use RuntimeException;

require __DIR__ . '/vendor/autoload.php';

$arguments = $argv ?? [];

if (count($arguments) < 3) {
    fwrite(
        STDERR,
        "Usage: php coverage-checker.php <coverage.xml> <minimumPercent>\n"
        . "Example: php coverage-checker.php coverage.xml 80\n",
    );
    exit(1);
}

$cloverPath = $arguments[1];
$threshold = (float) $arguments[2];
$checker = new CoverageThresholdChecker();

try {
    $coverage = $checker->assertMinimum($cloverPath, $threshold);
    fwrite(STDOUT, sprintf("Line coverage %.2f%% meets the %.2f%% threshold.\n", $coverage, $threshold));
    exit(0);
} catch (RuntimeException $exception) {
    fwrite(STDERR, $exception->getMessage() . PHP_EOL);
    exit(2);
}
</document_content>
</document>

<document index="12">
<source>dev/Coverage/CoverageThresholdChecker.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: ragie-php/dev/Coverage/CoverageThresholdChecker.php

namespace Ragie\Dev\Coverage;

use RuntimeException;

/**
 * Parses PHPUnit Clover reports and enforces a minimum coverage percentage.
 */
final class CoverageThresholdChecker
{
    public function calculate(string $cloverPath): float
    {
        if (!is_file($cloverPath)) {
            throw new RuntimeException(sprintf('Coverage file "%s" not found.', $cloverPath));
        }

        $report = simplexml_load_file($cloverPath);
        if ($report === false) {
            throw new RuntimeException(sprintf('Coverage file "%s" is not valid Clover XML.', $cloverPath));
        }

        $metrics = $report->xpath('/coverage/project/metrics');
        if (!isset($metrics[0])) {
            throw new RuntimeException('Coverage metrics missing from Clover report.');
        }

        $statements = (int) $metrics[0]['statements'];
        $coveredStatements = (int) $metrics[0]['coveredstatements'];

        if ($statements === 0) {
            return 100.0;
        }

        return round(($coveredStatements / $statements) * 100, 2);
    }

    public function assertMinimum(string $cloverPath, float $minimumPercent): float
    {
        if ($minimumPercent < 0 || $minimumPercent > 100) {
            throw new RuntimeException('Coverage threshold must be between 0 and 100.');
        }

        $coverage = $this->calculate($cloverPath);

        if ($coverage < $minimumPercent) {
            throw new RuntimeException(
                sprintf('Coverage %.2f%% is below the required %.2f%% threshold.', $coverage, $minimumPercent),
            );
        }

        return $coverage;
    }
}
</document_content>
</document>

<document index="13">
<source>docs/COOKBOOK.md</source>
<document_content>
---
this_file: docs/COOKBOOK.md
---

# Ragie PHP Cookbook

Fast recipes for common retrieval workloads. No OpenAI keys requiredâ€”ragie-php now focuses entirely on Ragieâ€™s search API.

## Minimal CLI Search

```php
use Ragie\Client;

require __DIR__ . '/../vendor/autoload.php';

$ragie = new Client(getenv('RAGIE_API_KEY'));
$query = trim($argv[1] ?? 'What is Ragie?');

$result = $ragie->retrieve($query);

if ($result->isEmpty()) {
    echo "No context found.\n";
    exit(0);
}

foreach ($result->getChunks() as $i => $chunk) {
    printf("%02d. %s (%s)\n", $i + 1, $chunk->getText(), $chunk->getDocumentName());
}
```

## Cache Expensive Queries

```php
use Ragie\Cache\InMemoryCache;
use Ragie\Client;

$client = (new Client($apiKey))
    ->withCache(new InMemoryCache(), ttlSeconds: 600)
    ->withDefaultTopK(12);

$result = $client->retrieve('How do I reset MFA tokens?');
```

Replace `InMemoryCache` with `SimpleCacheQueryCache` + Redis/Memcached to stretch rate limits and speed up popular FAQs.

## Custom Error Handling

```php
use Ragie\Client;
use Ragie\Exception\InvalidQueryException;

$client = new Client($apiKey);

try {
    $client->retrieve($userQuery);
} catch (InvalidQueryException $invalid) {
    logError('Invalid query', ['message' => $invalid->getMessage()]);
    throw $invalid;
} catch (\Ragie\Api\ApiException $api) {
    logError('Ragie API error', [
        'code' => $api->getCode(),
        'body' => $api->getResponseBody(),
    ]);
    throw new \RuntimeException('Temporary RAG outage, try again soon.');
}
```

## Batch + Concurrency

```php
use Ragie\Client;

$client = (new Client($apiKey))
    ->withDefaultTopK(8)
    ->withDefaultRerank();

$results = $client->retrieveBatch([
    'What is Vexy?',
    'Show me onboarding docs.',
    'How do I clear caches?',
]);

foreach ($results as $i => $result) {
    printf("#%d returned %d chunks\n", $i + 1, count($result));
}
```

`retrieveBatch()` is sequential, but you can upgrade to `retrieveAsync()` / `retrieveConcurrent()` later without changing business logic.

## Compose Recipes for Production

- **Moderation / LLM flows**: Use your orchestrator (for example ParaGra in `../paragra-php`) for OpenAI, AskYoda, and moderation orchestration while keeping ragie-php focused on retrieval.
- **Benchmarking**: `php benchmarks/RetrievalBenchmark.php` with `RAGIE_BENCH_*` knobs records min/max/p95 per question so you can prove latency targets.
- **Debug logging**: `(new Client($apiKey))->enableDebug()` writes queries, options, and chunk counts to `error_log`, useful during staging rollouts.

Pick the slice that solves todayâ€™s bottleneck, then stitch the rest together when you need a richer RAG pipeline.
</document_content>
</document>

<document index="14">
<source>examples/error_handling.php</source>
<document_content>
<?php

declare(strict_types=1);

/**
 * this_file: examples/error_handling.php
 *
 * Demonstrates resilient error handling around the Ragie\Client without relying
 * on higher-level helpers that now live in paragra-php.
 */

use Ragie\Api\ApiException;
use Ragie\Client;
use Ragie\Exception\InvalidQueryException;

require_once __DIR__ . '/../vendor/autoload.php';

$apiKey = getenv('RAGIE_API_KEY') ?: 'invalid-key-for-demo';
$client = new Client($apiKey);

echo "=== Example 1: Basic try/catch ===\n";
try {
    $result = $client->retrieve('What is RAG?');
    echo "Retrieved {$result->count()} chunks\n\n";
} catch (InvalidQueryException $invalid) {
    echo "Query rejected: {$invalid->getMessage()}\n\n";
} catch (ApiException $api) {
    echo formatApiError($api) . "\n\n";
}

echo "=== Example 2: Status-aware responses ===\n";
try {
    $client->retrieve('Trigger rate limiting?');
} catch (ApiException $api) {
    $status = $api->getCode();
    $message = match ($status) {
        401, 403 => 'Authentication failed â€” check API key.',
        404 => 'Resource not found.',
        429 => 'Too many requests â€” slow down.',
        500, 502, 503 => 'Server hiccup â€” try again shortly.',
        default => 'Unexpected Ragie error.',
    };
    echo "{$message} ({$status})\n";
    error_log(formatApiError($api));
}
echo "\n";

echo "=== Example 3: Simple retry with backoff ===\n";
$result = retryRetrieve($client, 'machine learning', maxAttempts: 3);
echo $result === null ? "All attempts failed.\n\n" : "Retry succeeded.\n\n";

echo "=== Example 4: Service wrapper with logging ===\n";
$service = new RetrievalService($client);
$maybeResult = $service->search('docs about caching', ['user_id' => '123']);
if ($maybeResult === null) {
    echo "Returned fallback content to caller.\n";
}
echo "\n=== Done ===\n";

function formatApiError(ApiException $exception): string
{
    $status = $exception->getCode();
    $details = $exception->getResponseBody();
    $extra = '';

    if (is_object($details) && isset($details->detail)) {
        $extra = (string) $details->detail;
    } elseif (is_array($details) && isset($details['detail'])) {
        $extra = (string) $details['detail'];
    }

    return sprintf(
        'Ragie API error (%d): %s%s',
        $status,
        $exception->getMessage(),
        $extra !== '' ? " â€” {$extra}" : ''
    );
}

function retryRetrieve(Client $client, string $query, int $maxAttempts = 3): ?object
{
    $attempt = 0;
    $delaySeconds = 1;

    while ($attempt < $maxAttempts) {
        $attempt++;
        try {
            echo "Attempt {$attempt}... ";
            $result = $client->retrieve($query);
            echo "success\n";
            return $result;
        } catch (ApiException $api) {
            $status = $api->getCode();
            echo "failed ({$status})\n";

            if ($status >= 400 && $status < 500 && $status !== 429) {
                echo "Client error, not retrying.\n";
                return null;
            }

            if ($attempt < $maxAttempts) {
                echo "Sleeping {$delaySeconds}s before retry...\n";
                sleep($delaySeconds);
                $delaySeconds *= 2;
            }
        }
    }

    return null;
}

final class RetrievalService
{
    public function __construct(private readonly Client $client)
    {
    }

    public function search(string $query, array $context = []): ?object
    {
        try {
            return $this->client->retrieve($query);
        } catch (InvalidQueryException $invalid) {
            $this->logError('invalid_query', $invalid, $context);
            throw $invalid;
        } catch (ApiException $api) {
            $this->logError('ragie_api_error', $api, $context);
            return null;
        }
    }

    private function logError(string $type, \Throwable $exception, array $context): void
    {
        $payload = [
            'type' => $type,
            'error' => get_class($exception),
            'message' => $exception->getMessage(),
            'code' => $exception->getCode(),
            'context' => $context,
            'timestamp' => date(DATE_ATOM),
        ];

        error_log(json_encode($payload, JSON_THROW_ON_ERROR));
    }
}
</document_content>
</document>

<document index="15">
<source>examples/input_validation.php</source>
<document_content>
<?php

/**
 * Input Validation Example
 *
 * Demonstrates input validation patterns and best practices
 * for building robust RAG applications.
 *
 * this_file: examples/input_validation.php
 */

declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use Ragie\Client;
use Ragie\RetrievalOptions;
use Ragie\Exception\InvalidQueryException;
use Ragie\Exception\InvalidParameterException;

// Example 1: Query validation
echo "=== Example 1: Query Validation ===\n\n";

$apiKey = getenv('RAGIE_API_KEY') ?: 'your-api-key-here';
$ragie = new Client($apiKey);

function testQuery(Client $client, string $query, string $description): void
{
    echo "Testing: {$description}\n";
    echo "Query: \"" . (strlen($query) > 50 ? substr($query, 0, 50) . '...' : $query) . "\"\n";

    try {
        $result = $client->retrieve($query);
        echo "âœ“ Valid - Retrieved {$result->count()} chunks\n\n";
    } catch (InvalidQueryException $e) {
        echo "âœ— Invalid - {$e->getMessage()}\n\n";
    }
}

// Test empty query
testQuery($ragie, '', 'Empty query');

// Test whitespace-only query
testQuery($ragie, '   ', 'Whitespace-only query');

// Test valid short query
testQuery($ragie, 'AI', 'Valid short query');

// Test valid normal query
testQuery($ragie, 'What is machine learning?', 'Valid normal query');

// Test query at max length (10K characters)
$maxQuery = str_repeat('a', 10000);
testQuery($ragie, $maxQuery, 'Query at max length (10K chars)');

// Test query exceeding max length
$tooLongQuery = str_repeat('a', 10001);
testQuery($ragie, $tooLongQuery, 'Query exceeding max length');

// Example 2: RetrievalOptions validation
echo "=== Example 2: RetrievalOptions Validation ===\n\n";

function testOptions(string $description, callable $optionsBuilder): void
{
    echo "Testing: {$description}\n";

    try {
        $options = $optionsBuilder();
        echo "âœ“ Valid options created\n\n";
    } catch (InvalidParameterException $e) {
        echo "âœ— Invalid - {$e->getMessage()}\n\n";
    }
}

// Test valid options
testOptions('Valid top_k value', fn () => RetrievalOptions::create()->withTopK(10));

// Test invalid top_k (too small)
testOptions('top_k too small (0)', fn () => RetrievalOptions::create()->withTopK(0));

// Test invalid top_k (too large)
testOptions('top_k too large (1001)', fn () => RetrievalOptions::create()->withTopK(1001));

// Test valid max_chunks_per_document
testOptions('Valid max_chunks_per_document', fn () => RetrievalOptions::create()->withMaxChunksPerDocument(5));

// Test invalid max_chunks_per_document (negative)
testOptions(
    'max_chunks_per_document negative',
    fn () => RetrievalOptions::create()->withMaxChunksPerDocument(-1)
);

// Example 3: User input sanitization
echo "=== Example 3: User Input Sanitization ===\n\n";

class QuerySanitizer
{
    /**
     * Sanitize and validate user query
     */
    public static function sanitize(string $query): string
    {
        // Trim whitespace
        $query = trim($query);

        // Remove null bytes
        $query = str_replace("\0", '', $query);

        // Normalize whitespace
        $query = preg_replace('/\s+/', ' ', $query);

        // Remove potentially dangerous characters for logging
        // (but keep them for the actual search)
        return $query;
    }

    /**
     * Validate query meets requirements
     */
    public static function validate(string $query): void
    {
        $sanitized = self::sanitize($query);

        if ($sanitized === '') {
            throw new InvalidQueryException('Query cannot be empty after sanitization');
        }

        if (mb_strlen($sanitized) > 10000) {
            throw new InvalidQueryException(
                sprintf('Query too long: %d characters (max 10000)', mb_strlen($sanitized))
            );
        }

        // Check for suspiciously repetitive content
        if (preg_match('/(.)\1{100,}/', $sanitized)) {
            throw new InvalidQueryException('Query contains suspicious repetitive content');
        }
    }
}

$testInputs = [
    "  normal query  \n",
    "query\0with\0nullbytes",
    "query    with     multiple      spaces",
    str_repeat('a', 150),
    '',
];

foreach ($testInputs as $input) {
    $display = str_replace(["\0", "\n"], ['\\0', '\\n'], substr($input, 0, 50));
    echo "Input: \"{$display}\"\n";

    try {
        $sanitized = QuerySanitizer::sanitize($input);
        QuerySanitizer::validate($sanitized);
        echo "âœ“ Sanitized: \"{$sanitized}\"\n\n";
    } catch (InvalidQueryException $e) {
        echo "âœ— {$e->getMessage()}\n\n";
    }
}

// Example 4: Production-ready search handler
echo "=== Example 4: Production Search Handler ===\n\n";

class SearchHandler
{
    public function __construct(private readonly Client $client)
    {
    }

    public function search(string $rawQuery, array $options = []): array
    {
        // Sanitize input
        $query = QuerySanitizer::sanitize($rawQuery);

        // Validate
        try {
            QuerySanitizer::validate($query);
        } catch (InvalidQueryException $e) {
            return [
                'success' => false,
                'error' => 'Invalid query: ' . $e->getMessage(),
                'code' => 'INVALID_QUERY',
            ];
        }

        // Build retrieval options
        try {
            $retrievalOptions = RetrievalOptions::create()
                ->withTopK($options['top_k'] ?? 10)
                ->withRerank($options['rerank'] ?? true);

            if (isset($options['filter'])) {
                $retrievalOptions->withFilter($options['filter']);
            }
        } catch (InvalidParameterException $e) {
            return [
                'success' => false,
                'error' => 'Invalid options: ' . $e->getMessage(),
                'code' => 'INVALID_OPTIONS',
            ];
        }

        // Execute search
        try {
            $result = $this->client->retrieve($query, $retrievalOptions);

            return [
                'success' => true,
                'query' => $query,
                'count' => $result->count(),
                'chunks' => array_map(
                    fn ($chunk) => [
                        'text' => $chunk->getText(),
                        'score' => $chunk->getScore(),
                        'document' => $chunk->getDocumentName(),
                    ],
                    $result->getChunks()
                ),
            ];
        } catch (\Exception $e) {
            error_log("Search failed: {$e->getMessage()}");

            return [
                'success' => false,
                'error' => 'Search failed. Please try again.',
                'code' => 'SEARCH_FAILED',
            ];
        }
    }
}

$handler = new SearchHandler($ragie);

// Test with various inputs
$testCases = [
    ['query' => '  valid query  ', 'options' => ['top_k' => 5]],
    ['query' => '', 'options' => []],
    ['query' => 'valid query', 'options' => ['top_k' => 0]],
];

foreach ($testCases as $i => $testCase) {
    echo "Test case " . ($i + 1) . ":\n";
    $result = $handler->search($testCase['query'], $testCase['options']);
    echo json_encode($result, JSON_PRETTY_PRINT) . "\n\n";
}

echo "=== Done ===\n";
</document_content>
</document>

<document index="16">
<source>examples/interactive-demo.php</source>
<document_content>
#!/usr/bin/env php
<?php

declare(strict_types=1);

/**
 * Interactive CLI for exploring Ragie retrievals.
 *
 * this_file: examples/interactive-demo.php
 */

use Ragie\Api\ApiException;
use Ragie\Client;
use Ragie\Examples\ChunkFormatter;
use Ragie\Exception\InvalidQueryException;

require __DIR__ . '/../vendor/autoload.php';

const RAGIE_INTERACTIVE_DEFAULT_MAX_CHUNKS = 5;
const RAGIE_INTERACTIVE_DEFAULT_MAX_LENGTH = 220;

$topChunkLimit = (int) ($_ENV['RAGIE_INTERACTIVE_MAX_CHUNKS'] ?? getenv('RAGIE_INTERACTIVE_MAX_CHUNKS') ?: RAGIE_INTERACTIVE_DEFAULT_MAX_CHUNKS);
$topChunkLimit = $topChunkLimit > 0 ? $topChunkLimit : RAGIE_INTERACTIVE_DEFAULT_MAX_CHUNKS;

$maxChunkLength = (int) ($_ENV['RAGIE_INTERACTIVE_MAX_LENGTH'] ?? getenv('RAGIE_INTERACTIVE_MAX_LENGTH') ?: RAGIE_INTERACTIVE_DEFAULT_MAX_LENGTH);
$maxChunkLength = $maxChunkLength >= 40 ? $maxChunkLength : RAGIE_INTERACTIVE_DEFAULT_MAX_LENGTH;

$apiKey = getenv('RAGIE_API_KEY');
if ($apiKey === false || trim($apiKey) === '') {
    if (function_exists('readline')) {
        $apiKey = readline('Enter Ragie API key: ');
    } else {
        fwrite(STDOUT, 'Enter Ragie API key: ');
        $apiKeyInput = fgets(STDIN);
        $apiKey = $apiKeyInput === false ? '' : $apiKeyInput;
    }
}

$apiKey = trim((string) $apiKey);
if ($apiKey === '') {
    fwrite(STDERR, "RAGIE_API_KEY is required to run the demo.\n");
    exit(1);
}

$client = new Client($apiKey);
echo PHP_EOL;
echo "Ragie Interactive Retrieval Demo\n";
echo "Type 'quit' or press Ctrl+D to exit.\n";
echo "Showing top {$topChunkLimit} chunks (max {$maxChunkLength} chars each).\n\n";

while (true) {
    if (function_exists('readline')) {
        $input = readline('Query> ');
        if ($input === false) {
            echo PHP_EOL;
            break;
        }
    } else {
        fwrite(STDOUT, 'Query> ');
        $read = fgets(STDIN);
        if ($read === false) {
            echo PHP_EOL;
            break;
        }
        $input = $read;
    }

    $query = trim((string) $input);

    if ($query === '') {
        continue;
    }

    if (in_array(strtolower($query), ['quit', 'exit'], true)) {
        break;
    }

    $start = microtime(true);

    try {
        $result = $client->retrieve($query);
        $durationMs = (int) round((microtime(true) - $start) * 1000);

        if ($result->isEmpty()) {
            echo "No context found. Try refining the question.\n\n";
            continue;
        }

        $chunkCount = count($result);
        printf("â†’ %d chunk(s) in %d ms\n", $chunkCount, $durationMs);

        $chunks = array_slice($result->getChunks(), 0, $topChunkLimit);
        foreach ($chunks as $i => $chunk) {
            echo ChunkFormatter::formatChunk($chunk, $i + 1, $maxChunkLength) . PHP_EOL . PHP_EOL;
        }
    } catch (InvalidQueryException $invalidQuery) {
        printf("Invalid query: %s\n\n", $invalidQuery->getMessage());
    } catch (ApiException $apiException) {
        printf("Ragie API error (%d): %s\n\n", $apiException->getCode(), $apiException->getMessage());
    } catch (\Throwable $throwable) {
        printf("Unexpected error: %s\n\n", $throwable->getMessage());
    }
}

echo "Bye!\n";
</document_content>
</document>

<document index="17">
<source>examples/retrieve.php</source>
<document_content>
<?php

/**
 * Basic retrieval example for Ragie PHP Client
 *
 * This example demonstrates the simplest way to retrieve relevant document chunks.
 *
 * this_file: examples/retrieve.php
 */

declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use Ragie\Client;

// Initialize the client with your API key
$apiKey = getenv('RAGIE_API_KEY') ?: 'your-api-key-here';
$ragie = new Client($apiKey);

try {
    // Perform a simple retrieval
    $result = $ragie->retrieve('What is machine learning?');

    // Check if we got results
    if ($result->isEmpty()) {
        echo "No results found.\n";
        exit(0);
    }

    // Display the number of results
    echo "Found {$result->count()} relevant chunks:\n\n";

    // Display the top result
    $topChunk = $result->getTopChunk();
    if ($topChunk !== null) {
        echo "Top result (score: {$topChunk->getScore()}):\n";
        echo "Document: {$topChunk->getDocumentName()}\n";
        echo "Text: {$topChunk->getText()}\n\n";
    }

    // Display all results
    echo "All results:\n";
    echo str_repeat('-', 80) . "\n";

    foreach ($result->getChunks() as $i => $chunk) {
        $num = $i + 1;
        echo "{$num}. [{$chunk->getDocumentName()}] (score: {$chunk->getScore()})\n";
        echo "   " . substr($chunk->getText(), 0, 100) . "...\n\n";
    }

    // Get just the text content
    $texts = $result->getChunkTexts();
    echo "\nExtracted " . count($texts) . " text snippets.\n";

    // Get unique document IDs
    $documentIds = $result->getDocumentIds();
    echo "Results span " . count($documentIds) . " unique documents.\n";
} catch (\Ragie\Api\ApiException $e) {
    echo "API Error: {$e->getMessage()}\n";
    exit(1);
} catch (\Exception $e) {
    echo "Error: {$e->getMessage()}\n";
    exit(1);
}
</document_content>
</document>

<document index="18">
<source>examples/retrieve_advanced.php</source>
<document_content>
<?php

/**
 * Advanced retrieval example with options for Ragie PHP Client
 *
 * This example demonstrates using RetrievalOptions to customize retrieval behavior.
 *
 * this_file: examples/retrieve_advanced.php
 */

declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use Ragie\Client;
use Ragie\RetrievalOptions;

// Initialize the client
$apiKey = getenv('RAGIE_API_KEY') ?: 'your-api-key-here';
$ragie = new Client($apiKey);

try {
    // Example 1: Retrieval with reranking
    echo "=== Example 1: With Reranking ===\n\n";

    $options = RetrievalOptions::create()
        ->withTopK(5)
        ->withRerank();

    $result = $ragie->retrieve('artificial intelligence applications', $options);
    echo "Found {$result->count()} results with reranking.\n\n";

    // Example 2: Retrieval with metadata filter
    echo "=== Example 2: With Metadata Filter ===\n\n";

    $options = RetrievalOptions::create()
        ->withTopK(10)
        ->withFilter([
            'category' => 'documentation',
        ]);

    $result = $ragie->retrieve('API usage examples', $options);
    echo "Found {$result->count()} results in 'documentation' category.\n\n";

    // Example 3: Complex filter with operators
    echo "=== Example 3: Complex Filter ===\n\n";

    $options = RetrievalOptions::create()
        ->withTopK(10)
        ->withFilter([
            'department' => ['$in' => ['sales', 'marketing']],
            'priority' => ['$gt' => 5],
        ]);

    $result = $ragie->retrieve('quarterly targets', $options);
    echo "Found {$result->count()} high-priority results from sales/marketing.\n\n";

    // Example 4: All options combined
    echo "=== Example 4: All Options ===\n\n";

    $options = RetrievalOptions::create()
        ->withTopK(20)
        ->withRerank()
        ->withMaxChunksPerDocument(3)
        ->withRecencyBias()
        ->withFilter(['status' => 'published']);

    $result = $ragie->retrieve('product updates', $options);

    echo "Found {$result->count()} results:\n";
    echo "- Top K: 20\n";
    echo "- Reranking: enabled\n";
    echo "- Max chunks per document: 3\n";
    echo "- Recency bias: enabled\n";
    echo "- Filter: status = published\n\n";

    // Display results
    if (!$result->isEmpty()) {
        echo "Top result:\n";
        $top = $result->getTopChunk();
        if ($top !== null) {
            echo "  Document: {$top->getDocumentName()}\n";
            echo "  Score: {$top->getScore()}\n";
            echo "  Text: " . substr($top->getText(), 0, 150) . "...\n\n";
        }

        echo "Documents in results:\n";
        foreach ($result->getDocumentIds() as $docId) {
            echo "  - {$docId}\n";
        }
    }

    // Example 5: Method chaining
    echo "\n=== Example 5: Fluent Method Chaining ===\n\n";

    $result = $ragie->retrieve(
        'machine learning best practices',
        RetrievalOptions::create()
            ->withTopK(15)
            ->withRerank(true)
            ->withMaxChunksPerDocument(2)
            ->withRecencyBias(true)
            ->withFilter(['type' => 'guide'])
    );

    echo "Retrieved {$result->count()} results using fluent interface.\n";

    // Example 6: Using partition
    echo "\n=== Example 6: Partition-Scoped Search ===\n\n";

    $options = RetrievalOptions::create()
        ->withPartition('customer-123')
        ->withTopK(10);

    $result = $ragie->retrieve('account history', $options);
    echo "Found {$result->count()} results in partition 'customer-123'.\n";
} catch (\Ragie\Api\ApiException $e) {
    echo "API Error: {$e->getMessage()}\n";
    exit(1);
} catch (\Exception $e) {
    echo "Error: {$e->getMessage()}\n";
    exit(1);
}

echo "\n=== Done ===\n";
</document_content>
</document>

<document index="19">
<source>examples/retrieve_concurrent.php</source>
<document_content>
<?php

/**
 * Concurrent retrieval example for Ragie PHP Client.
 *
 * Demonstrates the difference between sequential `retrieveBatch()` calls
 * and the built-in `retrieveConcurrent()` helper that reuses promises.
 *
 * this_file: ragie-php/examples/retrieve_concurrent.php
 */

declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use Ragie\Client;
use Ragie\RetrievalOptions;

$apiKey = getenv('RAGIE_API_KEY');

if ($apiKey === false || $apiKey === '') {
    fwrite(STDERR, "Set RAGIE_API_KEY before running this example.\n");
    exit(1);
}

$queries = [
    'What is Retrieval Augmented Generation?',
    'How do Ragie partitions work?',
    'Summarize Ragie client best practices',
];

$options = RetrievalOptions::create()
    ->withTopK(5)
    ->withRerank(true);

$ragie = (new Client($apiKey))
    ->withDefaultTopK(5)
    ->withDefaultRerank(true);

try {
    echo "Running sequential batch retrieval...\n";
    $sequential = timeOperation(fn (): array => $ragie->retrieveBatch($queries, $options));

    echo "\nRunning concurrent retrieval...\n";
    $concurrent = timeOperation(fn (): array => $ragie->retrieveConcurrent($queries, $options));

    echo "\nSequential duration: {$sequential['duration_ms']} ms\n";
    echo "Concurrent duration: {$concurrent['duration_ms']} ms\n";
    echo "Queries executed: " . count($queries) . "\n";

    echo "\nTop chunk previews:\n";
    foreach ($concurrent['results'] as $index => $result) {
        $top = $result->getTopChunk();
        printf(
            "  [%d] %s -> %s (score %.4f)\n",
            $index + 1,
            $queries[$index],
            $top?->getDocumentName() ?? 'no chunks',
            $top?->getScore() ?? 0.0
        );
    }

    echo "\nTip: increase the query list or compare durations with/without Ragie caching enabled.\n";
} catch (\Ragie\Api\ApiException $e) {
    fwrite(STDERR, "API Error: {$e->getMessage()}\n");
    exit(1);
} catch (\Throwable $e) {
    fwrite(STDERR, "Error: {$e->getMessage()}\n");
    exit(1);
}

/**
 * Helper to measure execution time for a callable returning RetrievalResult[].
 *
 * @param callable():array $operation
 *
 * @return array{results:array,duration_ms:int}
 */
function timeOperation(callable $operation): array
{
    $start = microtime(true);
    $results = $operation();

    return [
        'results' => $results,
        'duration_ms' => (int) round((microtime(true) - $start) * 1000),
    ];
}
</document_content>
</document>

<document index="20">
<source>examples/retrieve_with_cache.php</source>
<document_content>
<?php

/**
 * Cached retrieval example for Ragie PHP Client.
 *
 * Demonstrates how to enable the built-in QueryCache so repeat questions
 * reuse the last RetrievalResult instead of hitting the Ragie API again.
 *
 * this_file: ragie-php/examples/retrieve_with_cache.php
 */

declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use Ragie\Cache\InMemoryCache;
use Ragie\Client;
use Ragie\RetrievalResult;

$apiKey = getenv('RAGIE_API_KEY');

if ($apiKey === false || $apiKey === '') {
    fwrite(STDERR, "Set RAGIE_API_KEY before running this example.\n");
    exit(1);
}

$cacheTtlSeconds = (int) (getenv('RAGIE_CACHE_TTL') ?: 600);
$query = $argv[1] ?? 'How does Ragie index my documents?';

// Configure the client with fluent defaults plus cache wiring.
$ragie = (new Client($apiKey))
    ->withDefaultTopK(5)
    ->withCache(new InMemoryCache(), $cacheTtlSeconds);

printf("Running cached retrieval for \"%s\" (TTL: %ds)\n\n", $query, $cacheTtlSeconds);

try {
    $first = timedRetrieve($ragie, $query, 'First call');
    $second = timedRetrieve($ragie, $query, 'Second call (cache hit expected)');

    echo "\nResult summary:\n";
    echo sprintf("  Chunk count: %d\n", $first->count());
    echo sprintf("  Unique document IDs: %d\n", count($first->getDocumentIds()));

    $top = $first->getTopChunk();
    if ($top !== null) {
        echo "\nTop chunk preview:\n";
        echo sprintf("  Document: %s\n", $top->getDocumentName());
        echo sprintf("  Score: %.4f\n", $top->getScore());
        echo sprintf("  Text: %s\n", substr($top->getText(), 0, 200)) . "\n";
    }

    echo "\nTip: change the query text or lower the TTL to observe cache invalidation.\n";
} catch (\Ragie\Api\ApiException $e) {
    fwrite(STDERR, "API Error: {$e->getMessage()}\n");
    exit(1);
} catch (\Throwable $e) {
    fwrite(STDERR, "Error: {$e->getMessage()}\n");
    exit(1);
}

/**
 * Retrieve a question while printing elapsed time so cache behavior is visible.
 */
function timedRetrieve(Client $client, string $query, string $label): RetrievalResult
{
    $start = microtime(true);
    $result = $client->retrieve($query);
    $elapsedMs = (int) round((microtime(true) - $start) * 1000);

    echo sprintf("%s: %d chunks in %d ms\n", $label, $result->count(), $elapsedMs);

    return $result;
}
</document_content>
</document>

<document index="21">
<source>llms.sh</source>
<document_content>
#!/usr/bin/env bash

cd "$(dirname "$0")"

llms . "AGENTS.md,CLAUDE.md,GEMINI.md,LLXPRT.md,QWEN.md,WORK.md,external,vendor,vendor-local,src/Ragie/Api,build"
</document_content>
</document>

<document index="22">
<source>openapi.json</source>
<document_content>
{"openapi":"3.1.0","info":{"title":"Ragie API","version":"1.0.0"},"servers":[{"url":"https://api.ragie.ai"}],"paths":{"/documents":{"post":{"tags":["documents"],"summary":"Create Document","description":"On ingest, the document goes through a series of steps before it is ready for retrieval. Each step is reflected in the status of the document which can be one of [`pending`, `partitioning`, `partitioned`, `refined`, `chunked`, `indexed`, `summary_indexed`, `keyword_indexed`, `ready`, `failed`]. The document is available for retrieval once it is in ready state. The summary index step can take a few seconds. You can optionally use the document for retrieval once it is in `indexed` state. However the summary will only be available once the state has changed to `summary_indexed` or `ready`.","operationId":"CreateDocument","security":[{"auth":[]}],"requestBody":{"required":true,"content":{"multipart/form-data":{"schema":{"$ref":"#/components/schemas/CreateDocumentParams"}}}},"responses":{"201":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Document"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Bad Request"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-usage-example":true,"x-speakeasy-name-override":"create"},"get":{"tags":["documents"],"summary":"List Documents","description":"List all documents sorted by created_at in descending order. Results are paginated with a max limit of 100. When more documents are available, a `cursor` will be provided. Use the `cursor` parameter to retrieve the subsequent page.","operationId":"ListDocuments","security":[{"auth":[]}],"parameters":[{"name":"cursor","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An opaque cursor for pagination","title":"Cursor"},"description":"An opaque cursor for pagination"},{"name":"page_size","in":"query","required":false,"schema":{"type":"integer","maximum":100,"minimum":1,"description":"The number of items per page (must be greater than 0 and less than or equal to 100)","default":10,"title":"Page Size"},"description":"The number of items per page (must be greater than 0 and less than or equal to 100)"},{"name":"filter","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"The metadata search filter. Returns only items which match the filter. The following filter operators are supported: $eq - Equal to (number, string, boolean), $ne - Not equal to (number, string, boolean), $gt - Greater than (number), $gte - Greater than or equal to (number), $lt - Less than (number), $lte - Less than or equal to (number), $in - In array (string or number), $nin - Not in array (string or number). The operators can be combined with AND and OR. Read [Metadata & Filters guide](https://docs.ragie.ai/docs/metadata-filters) for more details and examples.","examples":[{"department":{"$in":["sales","marketing"]}}],"title":"Filter"},"description":"The metadata search filter. Returns only items which match the filter. The following filter operators are supported: $eq - Equal to (number, string, boolean), $ne - Not equal to (number, string, boolean), $gt - Greater than (number), $gte - Greater than or equal to (number), $lt - Less than (number), $lte - Less than or equal to (number), $in - In array (string or number), $nin - Not in array (string or number). The operators can be combined with AND and OR. Read [Metadata & Filters guide](https://docs.ragie.ai/docs/metadata-filters) for more details and examples."},{"name":"partition","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition.","examples":["acme_customer_id"],"title":"Partition"},"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition."}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DocumentList"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Not Found"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"list","x-speakeasy-max-method-params":0,"x-speakeasy-pagination":{"type":"cursor","inputs":[{"name":"cursor","type":"cursor","in":"parameters"}],"outputs":{"nextCursor":"$.pagination.next_cursor"}}}},"/documents/raw":{"post":{"tags":["documents"],"summary":"Create Document Raw","description":"Ingest a document as raw text. On ingest, the document goes through a series of steps before it is ready for retrieval. Each step is reflected in the status of the document which can be one of [`pending`, `partitioning`, `partitioned`, `refined`, `chunked`, `indexed`, `summary_indexed`, `keyword_indexed`, `ready`, `failed`]. The document is available for retrieval once it is in ready state. The summary index step can take a few seconds. You can optionally use the document for retrieval once it is in `indexed` state. However the summary will only be available once the state has changed to `summary_indexed` or `ready`.","operationId":"CreateDocumentRaw","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateDocumentRawParams"}}},"required":true},"responses":{"201":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Document"}}}},"401":{"description":"Unauthorized","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"402":{"description":"Payment Required","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"429":{"description":"Too Many Requests","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"500":{"description":"Internal Server Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"400":{"description":"Bad Request","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"security":[{"auth":[]}],"x-speakeasy-name-override":"createRaw"}},"/documents/url":{"post":{"tags":["documents"],"summary":"Create Document From Url","description":"Ingest a document from a publicly accessible URL. On ingest, the document goes through a series of steps before it is ready for retrieval. Each step is reflected in the status of the document which can be one of [`pending`, `partitioning`, `partitioned`, `refined`, `chunked`, `indexed`, `summary_indexed`, `keyword_indexed`, `ready`, `failed`]. The document is available for retrieval once it is in ready state. The summary index step can take a few seconds. You can optionally use the document for retrieval once it is in `indexed` state. However the summary will only be available once the state has changed to `summary_indexed` or `ready`. PDF files over 2000 pages are not supported in hi_res mode.","operationId":"CreateDocumentFromUrl","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateDocumentFromUrlParams"}}},"required":true},"responses":{"201":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Document"}}}},"401":{"description":"Unauthorized","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"402":{"description":"Payment Required","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"429":{"description":"Too Many Requests","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"500":{"description":"Internal Server Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"400":{"description":"Bad Request","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"security":[{"auth":[]}]}},"/documents/{document_id}":{"get":{"tags":["documents"],"summary":"Get Document","operationId":"GetDocument","security":[{"auth":[]}],"parameters":[{"name":"document_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","description":"The id of the document.","examples":["00000000-0000-0000-0000-000000000000"],"title":"Document Id"},"description":"The id of the document."},{"name":"partition","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition.","examples":["acme_customer_id"],"title":"Partition"},"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition."}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DocumentGet"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Not Found"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"get"},"delete":{"tags":["documents"],"summary":"Delete Document","operationId":"DeleteDocument","security":[{"auth":[]}],"parameters":[{"name":"document_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","description":"The id of the document.","examples":["00000000-0000-0000-0000-000000000000"],"title":"Document Id"},"description":"The id of the document."},{"name":"async","in":"query","required":false,"schema":{"anyOf":[{"type":"boolean"},{"type":"null"}],"description":"If true, performs document deletion asynchronously","examples":[false],"default":false,"title":"Async"},"description":"If true, performs document deletion asynchronously"},{"name":"partition","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition.","examples":["acme_customer_id"],"title":"Partition"},"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition."}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DocumentDelete"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Not Found"},"202":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/DocumentDelete"}}},"description":"Accepted"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"delete"}},"/documents/{document_id}/file":{"put":{"tags":["documents"],"summary":"Update Document File","operationId":"UpdateDocumentFile","security":[{"auth":[]}],"parameters":[{"name":"document_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","description":"The id of the document.","examples":["00000000-0000-0000-0000-000000000000"],"title":"Document Id"},"description":"The id of the document."},{"name":"partition","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition.","examples":["acme_customer_id"],"title":"Partition"},"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition."}],"requestBody":{"required":true,"content":{"multipart/form-data":{"schema":{"$ref":"#/components/schemas/UpdateDocumentFileParams"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DocumentFileUpdate"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Not Found"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"updateFile"}},"/documents/{document_id}/raw":{"put":{"tags":["documents"],"summary":"Update Document Raw","operationId":"UpdateDocumentRaw","security":[{"auth":[]}],"parameters":[{"name":"document_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","description":"The id of the document.","examples":["00000000-0000-0000-0000-000000000000"],"title":"Document Id"},"description":"The id of the document."},{"name":"partition","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition.","examples":["acme_customer_id"],"title":"Partition"},"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition."}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/UpdateDocumentRawParams"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DocumentRawUpdate"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Not Found"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"updateRaw"}},"/documents/{document_id}/url":{"put":{"tags":["documents"],"summary":"Update Document Url","description":"Updates a document from a publicly accessible URL. On ingest, the document goes through a series of steps before it is ready for retrieval. Each step is reflected in the status of the document which can be one of [`pending`, `partitioning`, `partitioned`, `refined`, `chunked`, `indexed`, `summary_indexed`, `keyword_indexed`, `ready`, `failed`]. The document is available for retrieval once it is in ready state. The summary index step can take a few seconds. You can optionally use the document for retrieval once it is in `indexed` state. However the summary will only be available once the state has changed to `summary_indexed` or `ready`. PDF files over 2000 pages are not supported in hi_res mode.","operationId":"UpdateDocumentFromUrl","security":[{"auth":[]}],"parameters":[{"name":"document_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","description":"The id of the document.","examples":["00000000-0000-0000-0000-000000000000"],"title":"Document Id"},"description":"The id of the document."},{"name":"partition","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition.","examples":["acme_customer_id"],"title":"Partition"},"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition."}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/UpdateDocumentFromUrlParams"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DocumentUrlUpdate"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Not Found"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"updateDocumentFromUrl"}},"/documents/{document_id}/metadata":{"patch":{"tags":["documents"],"summary":"Patch Document Metadata","operationId":"PatchDocumentMetadata","security":[{"auth":[]}],"parameters":[{"name":"document_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","description":"The id of the document.","examples":["00000000-0000-0000-0000-000000000000"],"title":"Document Id"},"description":"The id of the document."},{"name":"partition","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition.","examples":["acme_customer_id"],"title":"Partition"},"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition."}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PatchDocumentMetadataParams"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"anyOf":[{"$ref":"#/components/schemas/DocumentMetadataUpdate"},{"$ref":"#/components/schemas/AsyncDocumentMetadataUpdate"}],"title":"Response Patchdocumentmetadata"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Not Found"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"patchMetadata"}},"/documents/{document_id}/chunks":{"get":{"tags":["documents"],"summary":"Get Document Chunks","description":"List all document chunks sorted by index in ascending order. May be limited to a range of chunk indices with the `start_index` and `end_index` parameters. Documents created prior to 9/18/2024, which have not been updated since, have chunks which do not include an index and their index will be returned as -1. They will be sorted by their ID instead. Updating the document using the `Update Document File` or `Update Document Raw` endpoint will regenerate document chunks, including their index. Results are paginated with a max limit of 100. When more chunks are available, a `cursor` will be provided. Use the `cursor` parameter to retrieve the subsequent page.","operationId":"GetDocumentChunks","security":[{"auth":[]}],"parameters":[{"name":"document_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","description":"The id of the document.","examples":["00000000-0000-0000-0000-000000000000"],"title":"Document Id"},"description":"The id of the document."},{"name":"start_index","in":"query","required":false,"schema":{"anyOf":[{"type":"integer"},{"type":"null"}],"description":"The inclusive starting index of the chunk range to list. If omitted and `end_index` is present effectively limits results to at most one chunk matching `end_index`. If both `start_index` and `end_index` are omitted, results are not limited by index.","examples":[3],"title":"Start Index"},"description":"The inclusive starting index of the chunk range to list. If omitted and `end_index` is present effectively limits results to at most one chunk matching `end_index`. If both `start_index` and `end_index` are omitted, results are not limited by index."},{"name":"end_index","in":"query","required":false,"schema":{"anyOf":[{"type":"integer"},{"type":"null"}],"description":"The inclusive ending index of the chunk range to list. If omitted and `start_index` is present effectively limits results to at most one chunk matching `start_index`. If both `start_index` and `end_index` are omitted, results are not limited by index.","examples":[5],"title":"End Index"},"description":"The inclusive ending index of the chunk range to list. If omitted and `start_index` is present effectively limits results to at most one chunk matching `start_index`. If both `start_index` and `end_index` are omitted, results are not limited by index."},{"name":"cursor","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An opaque cursor for pagination","title":"Cursor"},"description":"An opaque cursor for pagination"},{"name":"page_size","in":"query","required":false,"schema":{"type":"integer","maximum":100,"minimum":1,"description":"The number of items per page (must be greater than 0 and less than or equal to 100)","default":10,"title":"Page Size"},"description":"The number of items per page (must be greater than 0 and less than or equal to 100)"},{"name":"partition","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition.","examples":["acme_customer_id"],"title":"Partition"},"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition."}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DocumentChunkList"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Not Found"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"getChunks"}},"/documents/{document_id}/chunks/{chunk_id}":{"get":{"tags":["documents"],"summary":"Get Document Chunk","description":"Gets a document chunk by its document and chunk ID.","operationId":"GetDocumentChunk","security":[{"auth":[]}],"parameters":[{"name":"document_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","description":"The id of the document.","examples":["00000000-0000-0000-0000-000000000000"],"title":"Document Id"},"description":"The id of the document."},{"name":"chunk_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","description":"The ID of the chunk.","examples":["00000000-0000-0000-0000-000000000000"],"title":"Chunk Id"},"description":"The ID of the chunk."},{"name":"partition","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition.","examples":["acme_customer_id"],"title":"Partition"},"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition."}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DocumentChunkDetail"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Not Found"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"getChunk"}},"/documents/{document_id}/chunks/{chunk_id}/content":{"get":{"tags":["documents"],"summary":"Get Document Chunk Content","description":"Returns the content of a document chunk in the requested format. Can be used to stream media of the content for audio/video documents.","operationId":"GetDocumentChunkContent","security":[{"auth":[]}],"parameters":[{"name":"document_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","description":"The id of the document.","examples":["00000000-0000-0000-0000-000000000000"],"title":"Document Id"},"description":"The id of the document."},{"name":"chunk_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","description":"The ID of the chunk.","examples":["00000000-0000-0000-0000-000000000000"],"title":"Chunk Id"},"description":"The ID of the chunk."},{"name":"media_type","in":"query","required":false,"schema":{"anyOf":[{"enum":["text/plain","audio/mpeg","video/mp4","image/webp","image/heic","image/bmp","image/png","image/jpeg","image/tiff"],"type":"string"},{"type":"null"}],"description":"The desired media type of the content to return described as a mime type. An error will be returned if the requested media type is not supported for the chunk's document type.","examples":["text/plain","audio/mpeg","video/mp4"],"title":"Media Type"},"description":"The desired media type of the content to return described as a mime type. An error will be returned if the requested media type is not supported for the chunk's document type."},{"name":"download","in":"query","required":false,"schema":{"type":"boolean","description":"Whether to return the content as a file download or a raw stream. If set to `true`, the content will be returned as a named file for download.","default":false,"title":"Download"},"description":"Whether to return the content as a file download or a raw stream. If set to `true`, the content will be returned as a named file for download."},{"name":"partition","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition.","examples":["acme_customer_id"],"title":"Partition"},"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition."},{"name":"range","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Range"}}],"responses":{"200":{"description":"Returns the source content of the document chunk.","content":{"application/json":{"schema":{}},"application/octet-stream":{},"audio/mpeg":{},"text/plain":{}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"getChunkContent"}},"/documents/{document_id}/content":{"get":{"tags":["documents"],"summary":"Get Document Content","description":"Get the content of a document. The `media_type` parameter can be used to request the content in a different format. When requesting as `application/json` additional metadata about the document will be included. If the original document contained content such as images or other non-textual media, this response will include a text description of that media instead of the original file data. Using mime types such as `audio/mpeg` or `video/mp4` will stream the file in a format that can be provided to an audio video player.","operationId":"GetDocumentContent","security":[{"auth":[]}],"parameters":[{"name":"document_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","description":"The id of the document.","examples":["00000000-0000-0000-0000-000000000000"],"title":"Document Id"},"description":"The id of the document."},{"name":"media_type","in":"query","required":false,"schema":{"anyOf":[{"enum":["text/plain","audio/mpeg","video/mp4","image/webp","image/heic","image/bmp","image/png","image/jpeg","image/tiff"],"type":"string"},{"const":"application/json","type":"string"},{"type":"null"}],"description":"The desired media type of the content to return described as a mime type. An error will be returned if the requested media type is not supported for the document's type.","examples":["text/plain","audio/mpeg","video/mp4"],"title":"Media Type"},"description":"The desired media type of the content to return described as a mime type. An error will be returned if the requested media type is not supported for the document's type."},{"name":"download","in":"query","required":false,"schema":{"type":"boolean","description":"Whether to return the content as a file download or a raw stream. If set to `true`, the content will be returned as a named file for download.","default":false,"title":"Download"},"description":"Whether to return the content as a file download or a raw stream. If set to `true`, the content will be returned as a named file for download."},{"name":"partition","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition.","examples":["acme_customer_id"],"title":"Partition"},"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition."},{"name":"range","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Range"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DocumentWithContent"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Not Found"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"getContent"}},"/documents/{document_id}/source":{"get":{"tags":["documents"],"summary":"Get Document Source","description":"Get the source file of a document. The source file is the original file that was uploaded to create the document. If the document was created from a URL, the source file will be the content of the URL. If the document was created by a connection, the source file will vary based on the type of the connection. For example, a Google Drive connection will return the file that was synced from the Google Drive, while a SalesForce connection would return a JSON file of the data synced from SalesForce.","operationId":"GetDocumentSource","security":[{"auth":[]}],"parameters":[{"name":"document_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","description":"The id of the document.","examples":["00000000-0000-0000-0000-000000000000"],"title":"Document Id"},"description":"The id of the document."},{"name":"partition","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition.","examples":["acme_customer_id"],"title":"Partition"},"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition."}],"responses":{"200":{"description":"Return a file in binary format","content":{"*/*":{"schema":{"type":"string","format":"binary"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Not Found"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"getSource"}},"/retrievals":{"post":{"tags":["retrievals"],"summary":"Retrieve","operationId":"Retrieve","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/RetrieveParams"}}},"required":true},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Retrieval"}}}},"401":{"description":"Unauthorized","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"402":{"description":"Payment Required","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"429":{"description":"Too Many Requests","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"500":{"description":"Internal Server Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"security":[{"auth":[]}],"x-speakeasy-name-override":"retrieve"}},"/documents/{document_id}/summary":{"get":{"tags":["documents"],"summary":"Get Document Summary","description":"Get a LLM generated summary of the document. The summary is created when the document is first created or updated. Documents of types ['xls', 'xlsx', 'csv', 'json'] are not supported for summarization. Documents greater than 1M in token length are not supported. This feature is in beta and may change in the future.","operationId":"GetDocumentSummary","security":[{"auth":[]}],"parameters":[{"name":"document_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","description":"The id of the document.","examples":["00000000-0000-0000-0000-000000000000"],"title":"Document Id"},"description":"The id of the document."},{"name":"partition","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition.","examples":["acme_customer_id"],"title":"Partition"},"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition."}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/DocumentSummary"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"404":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Not Found"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"getSummary"}},"/instructions":{"get":{"tags":["entities"],"summary":"List Instructions","description":"List all instructions.","operationId":"ListInstructions","responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"items":{"$ref":"#/components/schemas/Instruction"},"type":"array","title":"Response Listinstructions"}}}},"401":{"description":"Unauthorized","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"402":{"description":"Payment Required","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"429":{"description":"Too Many Requests","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"500":{"description":"Internal Server Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}}},"security":[{"auth":[]}],"x-speakeasy-name-override":"listInstructions"},"post":{"tags":["entities"],"summary":"Create Instruction","description":"Create a new instruction. Instructions are applied to documents as they are created or updated. The results of the instruction are stored as structured data in the schema defined by the `entity_schema` parameter. The `prompt` parameter is a natural language instruction which will be applied to documents. This feature is in beta and may change in the future.","operationId":"CreateInstruction","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateInstructionParams"}}},"required":true},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Instruction"}}}},"401":{"description":"Unauthorized","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"402":{"description":"Payment Required","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"429":{"description":"Too Many Requests","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"500":{"description":"Internal Server Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"security":[{"auth":[]}],"x-speakeasy-name-override":"createInstruction"}},"/instructions/{instruction_id}":{"put":{"tags":["entities"],"summary":"Update Instruction","operationId":"UpdateInstruction","security":[{"auth":[]}],"parameters":[{"name":"instruction_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","description":"The ID of the instruction.","examples":["00000000-0000-0000-0000-000000000000"],"title":"Instruction Id"},"description":"The ID of the instruction."}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/UpdateInstructionParams"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Instruction"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"updateInstruction"},"delete":{"tags":["entities"],"summary":"Delete Instruction","description":"Delete an instruction. This will delete the instruction and all entities generated by it. This operation is irreversible.","operationId":"DeleteInstruction","security":[{"auth":[]}],"parameters":[{"name":"instruction_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","description":"The ID of the instruction.","examples":["00000000-0000-0000-0000-000000000000"],"title":"Instruction Id"},"description":"The ID of the instruction."}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"object","additionalProperties":{"type":"string"},"title":"Response Deleteinstruction"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"delete"}},"/instructions/{instruction_id}/entities":{"get":{"tags":["entities"],"summary":"Get Instruction Extracted Entities","operationId":"ListEntitiesByInstruction","security":[{"auth":[]}],"parameters":[{"name":"instruction_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","description":"The ID of the instruction.","examples":["00000000-0000-0000-0000-000000000000"],"title":"Instruction Id"},"description":"The ID of the instruction."},{"name":"cursor","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An opaque cursor for pagination","title":"Cursor"},"description":"An opaque cursor for pagination"},{"name":"page_size","in":"query","required":false,"schema":{"type":"integer","maximum":100,"minimum":1,"description":"The number of items per page (must be greater than 0 and less than or equal to 100)","default":10,"title":"Page Size"},"description":"The number of items per page (must be greater than 0 and less than or equal to 100)"},{"name":"partition","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition.","examples":["acme_customer_id"],"title":"Partition"},"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition."}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/EntityList"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"listByInstruction","x-speakeasy-max-method-params":2,"x-speakeasy-pagination":{"type":"cursor","inputs":[{"name":"cursor","type":"cursor","in":"parameters"}],"outputs":{"nextCursor":"$.pagination.next_cursor"}}}},"/documents/{document_id}/entities":{"get":{"tags":["entities"],"summary":"Get Document Extracted Entities","operationId":"ListEntitiesByDocument","security":[{"auth":[]}],"parameters":[{"name":"document_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","description":"The id of the document.","examples":["00000000-0000-0000-0000-000000000000"],"title":"Document Id"},"description":"The id of the document."},{"name":"cursor","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An opaque cursor for pagination","title":"Cursor"},"description":"An opaque cursor for pagination"},{"name":"page_size","in":"query","required":false,"schema":{"type":"integer","maximum":100,"minimum":1,"description":"The number of items per page (must be greater than 0 and less than or equal to 100)","default":10,"title":"Page Size"},"description":"The number of items per page (must be greater than 0 and less than or equal to 100)"},{"name":"partition","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition.","examples":["acme_customer_id"],"title":"Partition"},"description":"An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition."}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/EntityList"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"listByDocument","x-speakeasy-max-method-params":2,"x-speakeasy-pagination":{"type":"cursor","inputs":[{"name":"cursor","type":"cursor","in":"parameters"}],"outputs":{"nextCursor":"$.pagination.next_cursor"}}}},"/connection":{"post":{"tags":["connections","beta","enterprise"],"summary":"Create Connection","description":"Create a connection. This is only for non-oauth connections such as S3 compatible connections, Freshdesk, and Zendesk.","operationId":"CreateConnection","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PublicCreateConnection"}}},"required":true},"responses":{"201":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Connection"}}}},"401":{"description":"Unauthorized","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"402":{"description":"Payment Required","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"429":{"description":"Too Many Requests","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"500":{"description":"Internal Server Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"400":{"description":"Bad Request","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"security":[{"auth":[]}],"x-speakeasy-usage-example":true,"x-speakeasy-group":"connections"}},"/connections":{"get":{"tags":["connections"],"summary":"List Connections","description":"List all connections sorted by created_at in descending order. Results are paginated with a max limit of 100. When more documents are available, a `cursor` will be provided. Use the `cursor` parameter to retrieve the subsequent page.","operationId":"list_connections_connections_get","security":[{"auth":[]}],"parameters":[{"name":"cursor","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An opaque cursor for pagination","title":"Cursor"},"description":"An opaque cursor for pagination"},{"name":"page_size","in":"query","required":false,"schema":{"type":"integer","maximum":100,"minimum":1,"description":"The number of items per page (must be greater than 0 and less than or equal to 100)","default":10,"title":"Page Size"},"description":"The number of items per page (must be greater than 0 and less than or equal to 100)"},{"name":"filter","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"The metadata search filter. Returns only items which match the filter. The following filter operators are supported: $eq - Equal to (number, string, boolean), $ne - Not equal to (number, string, boolean), $gt - Greater than (number), $gte - Greater than or equal to (number), $lt - Less than (number), $lte - Less than or equal to (number), $in - In array (string or number), $nin - Not in array (string or number). The operators can be combined with AND and OR. Read [Metadata & Filters guide](https://docs.ragie.ai/docs/metadata-filters) for more details and examples.","examples":[{"department":{"$in":["sales","marketing"]}}],"title":"Filter"},"description":"The metadata search filter. Returns only items which match the filter. The following filter operators are supported: $eq - Equal to (number, string, boolean), $ne - Not equal to (number, string, boolean), $gt - Greater than (number), $gte - Greater than or equal to (number), $lt - Less than (number), $lte - Less than or equal to (number), $in - In array (string or number), $nin - Not in array (string or number). The operators can be combined with AND and OR. Read [Metadata & Filters guide](https://docs.ragie.ai/docs/metadata-filters) for more details and examples."},{"name":"partition","in":"header","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An optional partition to scope the request to. If omitted, the request will be scoped to the default partition.","examples":["acme_customer_id"],"title":"Partition"},"description":"An optional partition to scope the request to. If omitted, the request will be scoped to the default partition."}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ConnectionList"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"list","x-speakeasy-pagination":{"type":"cursor","inputs":[{"name":"cursor","type":"cursor","in":"parameters"}],"outputs":{"nextCursor":"$.pagination.next_cursor"}}}},"/connections/oauth":{"post":{"tags":["connections"],"summary":"Create Oauth Redirect Url","description":"Creates a redirect url to redirect the user to when initializing an embedded connector.","operationId":"create_oauth_redirect_url_connections_oauth_post","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/OAuthUrlCreate"}}},"required":true},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/OAuthUrlResponse"}}}},"401":{"description":"Unauthorized","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"402":{"description":"Payment Required","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"429":{"description":"Too Many Requests","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"500":{"description":"Internal Server Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"security":[{"auth":[]}],"x-speakeasy-name-override":"createOAuthRedirectUrl"}},"/connections/source-type":{"get":{"tags":["connections"],"summary":"List Connection Source Types","description":"List available connection source types like 'google_drive' and 'notion' along with their metadata","operationId":"list_connection_source_types_connections_source_type_get","responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ListConnectorSourceTypeInfo"}}}},"401":{"description":"Unauthorized","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"402":{"description":"Payment Required","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"429":{"description":"Too Many Requests","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"500":{"description":"Internal Server Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}}},"security":[{"auth":[]}],"x-speakeasy-name-override":"list_connection_source_types"}},"/connections/{connection_id}/enabled":{"put":{"tags":["connections"],"summary":"Set Connection Enabled","description":"Enable or disable the connection. A disabled connection won't sync.","operationId":"set_connection_enabled_connections__connection_id__enabled_put","security":[{"auth":[]}],"parameters":[{"name":"connection_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","title":"Connection Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/SetConnectionEnabledPayload"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Connection"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"set_enabled"}},"/connections/{connection_id}":{"put":{"tags":["connections"],"summary":"Update Connection","description":"Updates a connections metadata or mode. These changes will be seen after the next sync.","operationId":"update_connection_connections__connection_id__put","security":[{"auth":[]}],"parameters":[{"name":"connection_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","title":"Connection Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ConnectionBase"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Connection"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"update"},"get":{"tags":["connections"],"summary":"Get Connection","description":"Get a connection.","operationId":"get_connection_connections__connection_id__get","security":[{"auth":[]}],"parameters":[{"name":"connection_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","title":"Connection Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Connection"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"get"}},"/connections/{connection_id}/stats":{"get":{"tags":["connections"],"summary":"Get Connection Stats","description":"Lists connection stats: total documents active documents, total active pages.","operationId":"get_connection_stats_connections__connection_id__stats_get","security":[{"auth":[]}],"parameters":[{"name":"connection_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","title":"Connection Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ConnectionStats"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"get_stats"}},"/connections/{connection_id}/limit":{"put":{"tags":["connections"],"summary":"Set Connection Limits","description":"Sets limits on a connection. Limits can be set on the total number of pages a connection can sync. When the limit is reached, the connection will be disabled. Limit may be removed by setting it to `null`.","operationId":"set_connection_limits_connections__connection_id__limit_put","security":[{"auth":[]}],"parameters":[{"name":"connection_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","title":"Connection Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ConnectionLimitParams"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Connection"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"set_limits"}},"/connections/{connection_id}/delete":{"post":{"tags":["connections"],"summary":"Delete Connection","description":"Schedules a connection to be deleted. You can choose to keep the files from the connection or delete them all. If you keep the files, they will no longer be associated to the connection. Deleting can take some time, so you will still see files for a bit after this is called.","operationId":"delete_connection_connections__connection_id__delete_post","security":[{"auth":[]}],"parameters":[{"name":"connection_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","title":"Connection Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/DeleteConnectionPayload"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"object","additionalProperties":{"type":"string"},"title":"Response Delete Connection Connections  Connection Id  Delete Post"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"delete"}},"/connections/{connection_id}/sync":{"post":{"tags":["connections"],"summary":"Sync Connection","description":"Schedules a connector to sync as soon as possible.","operationId":"SyncConnection","security":[{"auth":[]}],"parameters":[{"name":"connection_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","title":"Connection Id"}}],"responses":{"201":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ResponseOK"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Bad Request"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"sync"}},"/partitions":{"get":{"tags":["partitions"],"summary":"List Partitions","description":"List all partitions sorted by name in ascending order. Results are paginated with a max limit of 100. When more partitions are available, a `cursor` will be provided. Use the `cursor` parameter to retrieve the subsequent page.","operationId":"list_partitions_partitions_get","security":[{"auth":[]}],"parameters":[{"name":"cursor","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An opaque cursor for pagination","title":"Cursor"},"description":"An opaque cursor for pagination"},{"name":"page_size","in":"query","required":false,"schema":{"type":"integer","maximum":100,"minimum":1,"description":"The number of items per page (must be greater than 0 and less than or equal to 100)","default":10,"title":"Page Size"},"description":"The number of items per page (must be greater than 0 and less than or equal to 100)"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/PartitionList"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"list","x-speakeasy-pagination":{"type":"cursor","inputs":[{"name":"cursor","type":"cursor","in":"parameters"}],"outputs":{"nextCursor":"$.pagination.next_cursor"}}},"post":{"tags":["partitions"],"summary":"Create Partition","description":"Create a new partition. Partitions are used to scope documents, connections, and instructions. Partitions must be lowercase alphanumeric and may only include the special characters `_` and `-`. A partition may also be created by creating a document in it. Limits for a partition may optionally be defined when creating.","operationId":"create_partition_partitions_post","security":[{"auth":[]}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreatePartitionParams"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Partition"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"create"}},"/partitions/{partition_id}":{"get":{"tags":["partitions"],"summary":"Get Partition","description":"Get a partition by its ID. Includes usage information such as the number of documents and pages hosted and processed. The partition's limits are also included.","operationId":"get_partition_partitions__partition_id__get","security":[{"auth":[]}],"parameters":[{"name":"partition_id","in":"path","required":true,"schema":{"type":"string","title":"Partition Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/PartitionDetail"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"get"},"patch":{"tags":["partitions"],"summary":"Update Partition","description":"Updates a partition. This includes the partition's description and metadata schema.","operationId":"update_partition_partitions__partition_id__patch","security":[{"auth":[]}],"parameters":[{"name":"partition_id","in":"path","required":true,"schema":{"type":"string","title":"Partition Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/UpdatePartitionParams"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/PartitionDetail"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"update"},"delete":{"tags":["partitions"],"summary":"Delete Partition","description":"Deletes a partition and all of its associated data. This includes connections, documents, and partition specific instructions. This operation is irreversible.","operationId":"delete_partition_partitions__partition_id__delete","security":[{"auth":[]}],"parameters":[{"name":"partition_id","in":"path","required":true,"schema":{"type":"string","title":"Partition Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"type":"object","additionalProperties":{"type":"string"},"title":"Response Delete Partition Partitions  Partition Id  Delete"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"delete"}},"/partitions/{partition_id}/limits":{"put":{"tags":["partitions"],"summary":"Set Partition Limits","description":"Sets limits on a partition. Limits can be set on the total number of pages a partition can host and process. When the limit is reached, the partition will be disabled. A limit may be removed by setting it to `null`.","operationId":"set_partition_limits_partitions__partition_id__limits_put","security":[{"auth":[]}],"parameters":[{"name":"partition_id","in":"path","required":true,"schema":{"type":"string","title":"Partition Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/PartitionLimitParams"}}}},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/PartitionDetail"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"set_limits"}},"/authenticators":{"post":{"tags":["authenticators","beta","enterprise"],"summary":"Create Authenticator","description":"Create White labeled connector credentials","operationId":"CreateAuthenticator","security":[{"auth":[]}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"oneOf":[{"$ref":"#/components/schemas/OAuthCredentials"},{"$ref":"#/components/schemas/CreateGoogleAuthenticator"}],"discriminator":{"propertyName":"provider","mapping":{"atlassian":"#/components/schemas/OAuthCredentials","dropbox":"#/components/schemas/OAuthCredentials","microsoft":"#/components/schemas/OAuthCredentials","salesforce":"#/components/schemas/OAuthCredentials","slack":"#/components/schemas/OAuthCredentials","hubspot":"#/components/schemas/OAuthCredentials","google":"#/components/schemas/CreateGoogleAuthenticator"}},"title":"Payload"}}}},"responses":{"201":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BaseGetAuthenticator"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Bad Request"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-usage-example":true,"x-speakeasy-name-override":"create","x-speakeasy-group":"authenticators"},"get":{"tags":["authenticators","beta","enterprise"],"summary":"List Authenticators","description":"List all authenticators sorted by created_at in descending order. Results are paginated with a max limit of 100. When more authenticators are available, a `cursor` will be provided. Use the `cursor` parameter to retrieve the subsequent page.","operationId":"ListAuthenticators","security":[{"auth":[]}],"parameters":[{"name":"cursor","in":"query","required":false,"schema":{"anyOf":[{"type":"string"},{"type":"null"}],"description":"An opaque cursor for pagination","title":"Cursor"},"description":"An opaque cursor for pagination"},{"name":"page_size","in":"query","required":false,"schema":{"type":"integer","maximum":100,"minimum":1,"description":"The number of items per page (must be greater than 0 and less than or equal to 100)","default":10,"title":"Page Size"},"description":"The number of items per page (must be greater than 0 and less than or equal to 100)"}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/AuthenticatorList"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Bad Request"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"list","x-speakeasy-group":"authenticators","x-speakeasy-max-method-params":0,"x-speakeasy-pagination":{"type":"cursor","inputs":[{"name":"cursor","type":"cursor","in":"parameters"}],"outputs":{"nextCursor":"$.pagination.next_cursor"}}}},"/authenticators/{authenticator_id}/connection":{"post":{"tags":["authenticators","beta","enterprise"],"summary":"Create Authenticator Connection","description":"Create a connector for a given authenticator. This requires credentials dependent on the provider. For google drive it is a refresh token.","operationId":"CreateAuthenticatorConnection","security":[{"auth":[]}],"parameters":[{"name":"authenticator_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","title":"Authenticator Id"}}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateAuthenticatorConnection"}}}},"responses":{"201":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Connection"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Bad Request"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-usage-example":true,"x-speakeasy-group":"authenticators"}},"/authenticators/{authenticator_id}":{"delete":{"tags":["authenticators","beta","enterprise"],"summary":"Delete Authenticator","description":"Delete an authenticator. This requires all connections created by that authenticator to be deleted first.","operationId":"DeleteAuthenticatorConnection","security":[{"auth":[]}],"parameters":[{"name":"authenticator_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","title":"Authenticator Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ResponseOK"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"400":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Bad Request"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-group":"authenticators"}},"/responses":{"post":{"tags":["responses"],"summary":"Create Response","description":"Create a response. This will generate an LLM or agentic response. At this time the only supported model is `deep-search`. Responses may be streamed or returned synchronously. The `retrieve` tool is currently the only supported tool, more tools will be added in the future. A single partition may be provided in the retrieve tool. If omitted the `default` partition is used.","operationId":"create_response_responses_post","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Request"}}},"required":true},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Response"}}}},"401":{"description":"Unauthorized","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"402":{"description":"Payment Required","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"429":{"description":"Too Many Requests","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"500":{"description":"Internal Server Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"security":[{"auth":[]}],"x-speakeasy-name-override":"create"}},"/responses/{response_id}":{"get":{"tags":["responses"],"summary":"Get Response","description":"Get a response by its ID. This will return the response and its status. If the response is still in progress, the status will be `in_progress`. If the response is completed, the status will be `completed`. If the response is failed, the status will be `failed`.","operationId":"get_response_responses__response_id__get","security":[{"auth":[]}],"parameters":[{"name":"response_id","in":"path","required":true,"schema":{"type":"string","format":"uuid","title":"Response Id"}}],"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Response"}}}},"401":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Unauthorized"},"402":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Payment Required"},"429":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Too Many Requests"},"500":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorMessage"}}},"description":"Internal Server Error"},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}},"x-speakeasy-name-override":"get"}}},"webhooks":{"event":{"post":{"summary":"Event","description":"When events occur in Ragie such as a document being processed, we'll send this data to URLs that you can register in app. Learn more about webhooks in our docs: https://docs.ragie.ai/docs/webhooks.","operationId":"eventevent_post","requestBody":{"content":{"application/json":{"schema":{"anyOf":[{"$ref":"#/components/schemas/DocumentUpdateWebhook"},{"$ref":"#/components/schemas/DocumentDeleteWebhook"},{"$ref":"#/components/schemas/EntityExtractedWebhook"},{"$ref":"#/components/schemas/ConnectionSyncStartedWebhook"},{"$ref":"#/components/schemas/ConnectionSyncProgressWebhook"},{"$ref":"#/components/schemas/ConnectionSyncFinishedWebhook"},{"$ref":"#/components/schemas/ConnectionLimitExceededWebhook"},{"$ref":"#/components/schemas/PartitionLimitExceededWebhook"},{"$ref":"#/components/schemas/PartitionLimitResetWebhook"}],"title":"Body"}}},"required":true},"responses":{"200":{"description":"Successful Response","content":{"application/json":{"schema":{}}}},"422":{"description":"Validation Error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HTTPValidationError"}}}}}}}},"components":{"schemas":{"AccessTokenCredentials":{"properties":{"access_token":{"type":"string","title":"Access Token"}},"type":"object","required":["access_token"],"title":"AccessTokenCredentials"},"Answer":{"properties":{"text":{"type":"string","title":"Text","description":"An answer to a question."},"evidence":{"items":{"type":"string"},"type":"array","title":"Evidence","description":"The evidence used to derive the answer."}},"type":"object","required":["text"],"title":"Answer"},"AnswerStep":{"properties":{"type":{"type":"string","const":"answer","title":"Type","default":"answer"},"think":{"type":"string","title":"Think"},"current_question":{"type":"string","title":"Current Question"},"errored":{"type":"boolean","title":"Errored","default":false},"other_resolved_question_ids":{"items":{"type":"string"},"type":"array","title":"Other Resolved Question Ids","description":"A list of question ids that are no longer relevant to the current answer referenced by their IDs."},"answer":{"$ref":"#/components/schemas/Answer"}},"type":"object","required":["think","current_question","answer"],"title":"AnswerStep"},"AsyncDocumentMetadataUpdate":{"properties":{"status":{"type":"string","title":"Status"}},"type":"object","required":["status"],"title":"AsyncDocumentMetadataUpdate"},"AudioModalityData":{"properties":{"type":{"type":"string","const":"audio","title":"Type","default":"audio"},"word_timestamps":{"items":{"$ref":"#/components/schemas/WordTimestamp"},"type":"array","title":"Word Timestamps","default":[]}},"type":"object","title":"AudioModalityData"},"AuthenticatorConfluenceConnection":{"properties":{"provider":{"type":"string","const":"confluence","title":"Provider"},"data":{"items":{"$ref":"#/components/schemas/ConfluenceData"},"type":"array","title":"Data"},"credentials":{"$ref":"#/components/schemas/OAuthRefreshTokenCredentials"}},"type":"object","required":["provider","data","credentials"],"title":"AuthenticatorConfluenceConnection"},"AuthenticatorDropboxConnection":{"properties":{"provider":{"type":"string","const":"dropbox","title":"Provider"},"data":{"$ref":"#/components/schemas/FolderData"},"email":{"type":"string","title":"Email","description":"The email of the Dropbox account this is for"},"credentials":{"$ref":"#/components/schemas/OAuthRefreshTokenCredentials"}},"type":"object","required":["provider","data","email","credentials"],"title":"AuthenticatorDropboxConnection"},"AuthenticatorGmailConnection":{"properties":{"provider":{"type":"string","const":"gmail","title":"Provider"},"data":{"$ref":"#/components/schemas/GmailData"},"email":{"type":"string","title":"Email","description":"The email of the Google Drive account this is for"},"credentials":{"$ref":"#/components/schemas/OAuthRefreshTokenCredentials"}},"type":"object","required":["provider","data","email","credentials"],"title":"AuthenticatorGmailConnection"},"AuthenticatorGoogleDriveConnection":{"properties":{"provider":{"type":"string","const":"google_drive","title":"Provider"},"data":{"items":{"$ref":"#/components/schemas/GoogleFolderData"},"type":"array","title":"Data"},"email":{"type":"string","title":"Email","description":"The email of the Google Drive account this is for"},"credentials":{"$ref":"#/components/schemas/OAuthRefreshTokenCredentials"}},"type":"object","required":["provider","data","email","credentials"],"title":"AuthenticatorGoogleDriveConnection"},"AuthenticatorHubspotConnection":{"properties":{"provider":{"type":"string","const":"hubspot","title":"Provider"},"data":{"$ref":"#/components/schemas/HubspotData"},"hub_id":{"type":"string","title":"Hub Id"},"hub_domain":{"type":"string","title":"Hub Domain"},"credentials":{"$ref":"#/components/schemas/OAuthRefreshTokenCredentials"}},"type":"object","required":["provider","data","hub_id","hub_domain","credentials"],"title":"AuthenticatorHubspotConnection"},"AuthenticatorJiraConnection":{"properties":{"provider":{"type":"string","const":"jira","title":"Provider"},"credentials":{"$ref":"#/components/schemas/OAuthRefreshTokenCredentials"}},"type":"object","required":["provider","credentials"],"title":"AuthenticatorJiraConnection"},"AuthenticatorList":{"properties":{"pagination":{"$ref":"#/components/schemas/Pagination"},"authenticators":{"items":{"$ref":"#/components/schemas/BaseGetAuthenticator"},"type":"array","title":"Authenticators"}},"type":"object","required":["pagination","authenticators"],"title":"AuthenticatorList"},"AuthenticatorNotionConnection":{"properties":{"provider":{"type":"string","const":"notion","title":"Provider"},"workspace_id":{"type":"string","title":"Workspace Id"},"workspace_name":{"type":"string","title":"Workspace Name"},"user_email":{"type":"string","title":"User Email","description":"The email of the Notion account this is for"},"credentials":{"$ref":"#/components/schemas/AccessTokenCredentials"}},"type":"object","required":["provider","workspace_id","workspace_name","user_email","credentials"],"title":"AuthenticatorNotionConnection"},"AuthenticatorOnedriveConnection":{"properties":{"provider":{"type":"string","const":"onedrive","title":"Provider"},"data":{"$ref":"#/components/schemas/OnedriveData"},"user_email":{"type":"string","title":"User Email","description":"The email of the Onedrive account this is for"},"credentials":{"$ref":"#/components/schemas/OAuthRefreshTokenCredentials"}},"type":"object","required":["provider","data","user_email","credentials"],"title":"AuthenticatorOnedriveConnection"},"AuthenticatorSalesforceConnection":{"properties":{"provider":{"type":"string","const":"salesforce","title":"Provider"},"user_email":{"type":"string","title":"User Email","description":"The email of the Salesforce account this is for"},"url":{"type":"string","title":"Url","description":"The url of your Salesforce instance, where you go to login."},"credentials":{"$ref":"#/components/schemas/OAuthRefreshTokenCredentials"}},"type":"object","required":["provider","user_email","url","credentials"],"title":"AuthenticatorSalesforceConnection"},"AuthenticatorSharepointConnection":{"properties":{"provider":{"type":"string","const":"sharepoint","title":"Provider"},"data":{"$ref":"#/components/schemas/SharepointData"},"user_email":{"type":"string","title":"User Email","description":"The email of the Sharepoint account this is for"},"credentials":{"$ref":"#/components/schemas/OAuthRefreshTokenCredentials"}},"type":"object","required":["provider","data","user_email","credentials"],"title":"AuthenticatorSharepointConnection"},"AuthenticatorSlackConnection":{"properties":{"provider":{"type":"string","const":"slack","title":"Provider"},"data":{"$ref":"#/components/schemas/SlackData"},"user_email":{"type":"string","title":"User Email","description":"The email of the Slack account this is for"},"credentials":{"$ref":"#/components/schemas/AccessTokenCredentials"}},"type":"object","required":["provider","data","user_email","credentials"],"title":"AuthenticatorSlackConnection"},"BackblazeCredentials":{"properties":{"key_id":{"type":"string","title":"Key Id"},"application_key":{"type":"string","title":"Application Key"},"region":{"type":"string","title":"Region"},"endpoint":{"type":"string","title":"Endpoint"}},"type":"object","required":["key_id","application_key","region","endpoint"],"title":"BackblazeCredentials"},"BaseGetAuthenticator":{"properties":{"provider":{"type":"string","title":"Provider"},"name":{"type":"string","title":"Name","description":"The unique name of your authenticator, used to identify it and distinguish it from others. This name must be unique. Attempting to reuse the same name will result in an error."},"id":{"type":"string","format":"uuid","title":"Id"}},"type":"object","required":["provider","name","id"],"title":"BaseGetAuthenticator"},"Body_CreateDocument":{"properties":{"mode":{"type":"string","title":"Mode","description":"Partition strategy for the document. Different strategies exist for textual, audio and video file types and you can set the strategy you want for  each file type, or just for textual types.  For textual documents the options are `'hi_res'` or `'fast'`. When set to `'hi_res'`, images and tables will be extracted from the document. `'fast'` will only extract text. `'fast'` may be up to 20x faster than `'hi_res'`. `hi_res` is only applicable for Word documents, PDFs, Images, and PowerPoints. Images will always be processed in `hi_res`. If `hi_res` is set for an unsupported document type, it will be processed and billed in `fast` mode.  For audio files, the options are true or false. True if you want to process audio, false otherwise.          For video files, the options are `'audio_only'`, `'video_only'`, `'audio_video'`. `'audio_only'` will extract just the audio part of the video. `'video_only'` will similarly just extract the video part, ignoring audio. `'audio_video'` will extract both audio and video.  To process all media types at the highest quality, use `'all'`.  When you specify audio or video stategies, the format must be a JSON object. In this case, textual documents are denoted by the key \"static\". If you omit a key, that document type won't be processd.  See examples below.  Examples  Textual documents only     \"fast\"  Video documents only {     \"video\": \"audio_video\" }  Specify multiple document types {     \"static\": \"hi_res\",     \"audio\": true,     \"video\": \"video_only\" }  Specify only textual or audio document types {     \"static\": \"fast\",     \"audio\": true }  Highest quality processing for all media types     \"all\"","default":"fast"},"metadata":{"type":"string","title":"Metadata","description":"Metadata for the document. Keys must be strings. Values may be strings, numbers, booleans, or lists of strings. Numbers may be integers or floating point and will be converted to 64 bit floating point. 1000 total values are allowed. Each item in an array counts towards the total. The following keys are reserved for internal use: `document_id`, `document_type`, `document_source`, `document_name`, `document_uploaded_at`, `start_time`, `end_time`.","default":"{}"},"file":{"type":"string","format":"binary","title":"File","description":"The binary file to upload, extract, and index for retrieval. The following file types are supported: Plain Text: `.eml` `.html` `.json` `.md` `.msg` `.rst` `.rtf` `.txt` `.xml`\nImages: `.png` `.webp` `.jpg` `.jpeg` `.tiff` `.bmp` `.heic`\nDocuments: `.csv` `.doc` `.docx` `.epub` `.epub+zip` `.odt` `.pdf` `.ppt` `.pptx` `.tsv` `.xlsx` `.xls`. PDF files over 2000 pages are not supported in hi_res mode."},"external_id":{"type":"string","title":"External Id","description":"An optional identifier for the document. A common value might be an id in an external system or the URL where the source file may be found."},"partition":{"type":"string","title":"Partition","description":"An optional partition identifier. Documents can be scoped to a partition. Partitions must be lowercase alphanumeric and may only include the special characters `_` and `-`.  A partition is created any time a document is created."},"name":{"type":"string","title":"Name","description":"An optional name for the document. If set, the document will have this name. Otherwise it will default to the file's name."}},"type":"object","required":["file"],"title":"Body_CreateDocument"},"Body_UpdateDocumentFile":{"properties":{"mode":{"type":"string","title":"Mode","description":"Partition strategy for the document. Different strategies exist for textual, audio and video file types and you can set the strategy you want for  each file type, or just for textual types.  For textual documents the options are `'hi_res'` or `'fast'`. When set to `'hi_res'`, images and tables will be extracted from the document. `'fast'` will only extract text. `'fast'` may be up to 20x faster than `'hi_res'`. `hi_res` is only applicable for Word documents, PDFs, Images, and PowerPoints. Images will always be processed in `hi_res`. If `hi_res` is set for an unsupported document type, it will be processed and billed in `fast` mode.  For audio files, the options are true or false. True if you want to process audio, false otherwise.          For video files, the options are `'audio_only'`, `'video_only'`, `'audio_video'`. `'audio_only'` will extract just the audio part of the video. `'video_only'` will similarly just extract the video part, ignoring audio. `'audio_video'` will extract both audio and video.  To process all media types at the highest quality, use `'all'`.  When you specify audio or video stategies, the format must be a JSON object. In this case, textual documents are denoted by the key \"static\". If you omit a key, that document type won't be processd.  See examples below.  Examples  Textual documents only     \"fast\"  Video documents only {     \"video\": \"audio_video\" }  Specify multiple document types {     \"static\": \"hi_res\",     \"audio\": true,     \"video\": \"video_only\" }  Specify only textual or audio document types {     \"static\": \"fast\",     \"audio\": true }  Highest quality processing for all media types     \"all\"","default":"fast"},"file":{"type":"string","format":"binary","title":"File","description":"The binary file to upload, extract, and index for retrieval. The following file types are supported: Plain Text: `.eml` `.html` `.json` `.md` `.msg` `.rst` `.rtf` `.txt` `.xml`\nImages: `.png` `.webp` `.jpg` `.jpeg` `.tiff` `.bmp` `.heic`\nDocuments: `.csv` `.doc` `.docx` `.epub` `.epub+zip` `.odt` `.pdf` `.ppt` `.pptx` `.tsv` `.xlsx` `.xls`. PDF files over 2000 pages are not supported in hi_res mode."}},"type":"object","required":["file"],"title":"Body_UpdateDocumentFile"},"BucketData":{"properties":{"bucket":{"type":"string","title":"Bucket"},"prefix":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Prefix"},"import_file_metadata":{"type":"boolean","title":"Import File Metadata","default":false}},"type":"object","required":["bucket"],"title":"BucketData"},"ChunkMetadata":{"properties":{},"additionalProperties":true,"type":"object","title":"ChunkMetadata"},"CodeInterpreterEvidence":{"properties":{"type":{"type":"string","const":"code_interpreter","title":"Type","default":"code_interpreter"},"text":{"type":"string","title":"Text"},"code":{"type":"string","title":"Code","description":"The code that was executed."},"code_issue":{"type":"string","title":"Code Issue","description":"The issue that the code was written to solve."},"code_result":{"type":"string","title":"Code Result","description":"The result of the code that was executed."}},"type":"object","required":["text","code","code_issue","code_result"],"title":"CodeInterpreterEvidence"},"CodeInterpreterOutput":{"properties":{"id":{"type":"string","title":"Id","description":"The unique ID of the code interpreter tool call."},"code":{"type":"string","title":"Code","description":"The code executed by the code interpreter."},"container_id":{"type":"string","title":"Container Id","description":"The ID of the container used to run the code."},"outputs":{"items":{"$ref":"#/components/schemas/CodeInterpreterOutputLogs"},"type":"array","title":"Outputs","description":"The outputs generated by the code interpreter, such as logs or images."},"type":{"type":"string","const":"code_interpreter_output","title":"Type","default":"code_interpreter_output"},"status":{"type":"string","enum":["in_progress","interpreting","completed","incomplete","failed"],"title":"Status","default":"completed"}},"type":"object","required":["id","code","container_id","outputs"],"title":"CodeInterpreterOutput"},"CodeInterpreterOutputLogs":{"properties":{"logs":{"type":"string","title":"Logs","description":"The logs output from the code interpreter."},"type":{"type":"string","const":"logs","title":"Type","default":"logs"}},"type":"object","required":["logs"],"title":"CodeInterpreterOutputLogs"},"CodeStep":{"properties":{"type":{"type":"string","const":"code","title":"Type","default":"code"},"think":{"type":"string","title":"Think"},"current_question":{"type":"string","title":"Current Question"},"errored":{"type":"boolean","title":"Errored","default":false},"code_issue":{"type":"string","title":"Code Issue","description":"The natural language description of the code issue you need to solve."},"code":{"type":"string","title":"Code","description":"The code you generated to solve the code issue.","default":""},"code_result":{"type":"string","title":"Code Result","description":"The result of the code you generated after executing it.","default":""}},"type":"object","required":["think","current_question","code_issue"],"title":"CodeStep"},"ConfluenceData":{"properties":{"resource_id":{"type":"string","title":"Resource Id"},"space_id":{"type":"integer","title":"Space Id"},"space_key":{"type":"string","title":"Space Key"},"space_name":{"type":"string","title":"Space Name"}},"type":"object","required":["resource_id","space_id","space_key","space_name"],"title":"ConfluenceData"},"Connection":{"properties":{"id":{"type":"string","format":"uuid","title":"Id"},"created_at":{"type":"string","format":"date-time","title":"Created At"},"updated_at":{"type":"string","format":"date-time","title":"Updated At"},"metadata":{"additionalProperties":{"anyOf":[{"type":"string"},{"type":"integer"},{"type":"number"},{"type":"boolean"},{"items":{"type":"string"},"type":"array"}]},"type":"object","title":"Metadata"},"type":{"type":"string","title":"Type"},"name":{"type":"string","title":"Name"},"source":{"anyOf":[{"type":"string"},{"items":{"type":"string"},"type":"array"},{"additionalProperties":true,"type":"object"},{"type":"null"}],"title":"Source"},"enabled":{"type":"boolean","title":"Enabled"},"disabled_by_system_reason":{"anyOf":[{"type":"string","enum":["connection_over_total_page_limit","authentication_failed"]},{"type":"null"}],"title":"Disabled By System Reason"},"last_synced_at":{"anyOf":[{"type":"string","format":"date-time"},{"type":"null"}],"title":"Last Synced At"},"syncing":{"anyOf":[{"type":"boolean"},{"type":"null"}],"title":"Syncing"},"partition":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Partition"},"page_limit":{"anyOf":[{"type":"integer"},{"type":"null"}],"title":"Page Limit"},"disabled_by_system":{"type":"boolean","title":"Disabled By System","readOnly":true}},"type":"object","required":["id","created_at","updated_at","metadata","type","name","source","enabled","disabled_by_system_reason","page_limit","disabled_by_system"],"title":"Connection"},"ConnectionBase":{"properties":{"partition_strategy":{"anyOf":[{"type":"string","enum":["hi_res","fast"]},{"$ref":"#/components/schemas/MediaModeParam"}],"title":"Partition Strategy"},"metadata":{"additionalProperties":{"anyOf":[{"type":"string"},{"type":"integer"},{"type":"number"},{"type":"boolean"},{"items":{"type":"string"},"type":"array"}]},"type":"object","title":"Metadata","description":"Metadata for the document. Keys must be strings. Values may be strings, numbers, booleans, or lists of strings. Numbers may be integers or floating point and will be converted to 64 bit floating point. 1000 total values are allowed. Each item in an array counts towards the total. The following keys are reserved for internal use: `document_id`, `document_type`, `document_source`, `document_name`, `document_uploaded_at`, `start_time`, `end_time`.","default":{}},"page_limit":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Page Limit","description":"The maximum number of pages a connection will sync. The connection will be disabled after this limit is reached. Some in process documents may continue processing. Remove the limit by setting to `null`.","examples":[1000]}},"type":"object","required":["partition_strategy"],"title":"ConnectionBase"},"ConnectionLimitExceededWebhook":{"properties":{"nonce":{"type":"string","title":"Nonce"},"type":{"type":"string","const":"connection_limit_exceeded","title":"Type"},"payload":{"$ref":"#/components/schemas/ConnectionLimitExceededWebhookPayload"}},"type":"object","required":["nonce","type","payload"],"title":"ConnectionLimitExceededWebhook"},"ConnectionLimitExceededWebhookPayload":{"properties":{"connection_id":{"type":"string","title":"Connection Id"},"partition":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Partition"},"connection_metadata":{"additionalProperties":true,"type":"object","title":"Connection Metadata"},"limit_type":{"type":"string","const":"page_limit","title":"Limit Type"}},"type":"object","required":["connection_id","partition","connection_metadata","limit_type"],"title":"ConnectionLimitExceededWebhookPayload"},"ConnectionLimitParams":{"properties":{"page_limit":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Page Limit","description":"The maximum number of pages a connection will sync. The connection will be disabled after this limit is reached. Some in process documents may continue processing. Remove the limit by setting to `null`.","examples":[1000]}},"type":"object","title":"ConnectionLimitParams"},"ConnectionList":{"properties":{"pagination":{"$ref":"#/components/schemas/Pagination"},"connections":{"items":{"$ref":"#/components/schemas/Connection"},"type":"array","title":"Connections"}},"type":"object","required":["pagination","connections"],"title":"ConnectionList"},"ConnectionStats":{"properties":{"document_count":{"type":"integer","title":"Document Count"},"page_count":{"type":"number","title":"Page Count"}},"type":"object","required":["document_count","page_count"],"title":"ConnectionStats"},"ConnectionSyncFinishedWebhook":{"properties":{"nonce":{"type":"string","title":"Nonce"},"type":{"type":"string","const":"connection_sync_finished","title":"Type"},"payload":{"$ref":"#/components/schemas/ConnectionSyncFinishedWebhookPayload"}},"type":"object","required":["nonce","type","payload"],"title":"ConnectionSyncFinishedWebhook"},"ConnectionSyncFinishedWebhookPayload":{"properties":{"connection_id":{"type":"string","title":"Connection Id"},"sync_id":{"type":"string","title":"Sync Id"},"partition":{"type":"string","title":"Partition"},"connection_metadata":{"additionalProperties":true,"type":"object","title":"Connection Metadata"}},"type":"object","required":["connection_id","sync_id","partition","connection_metadata"],"title":"ConnectionSyncFinishedWebhookPayload"},"ConnectionSyncProgressWebhook":{"properties":{"nonce":{"type":"string","title":"Nonce"},"type":{"type":"string","const":"connection_sync_progress","title":"Type"},"payload":{"$ref":"#/components/schemas/ConnectionSyncProgressWebhookPayload"}},"type":"object","required":["nonce","type","payload"],"title":"ConnectionSyncProgressWebhook"},"ConnectionSyncProgressWebhookPayload":{"properties":{"connection_id":{"type":"string","title":"Connection Id"},"sync_id":{"type":"string","title":"Sync Id"},"partition":{"type":"string","title":"Partition"},"connection_metadata":{"additionalProperties":true,"type":"object","title":"Connection Metadata"},"create_count":{"type":"integer","title":"Create Count"},"created_count":{"type":"integer","title":"Created Count"},"update_content_count":{"type":"integer","title":"Update Content Count"},"updated_content_count":{"type":"integer","title":"Updated Content Count"},"update_metadata_count":{"type":"integer","title":"Update Metadata Count"},"updated_metadata_count":{"type":"integer","title":"Updated Metadata Count"},"delete_count":{"type":"integer","title":"Delete Count"},"deleted_count":{"type":"integer","title":"Deleted Count"},"errored_count":{"type":"integer","title":"Errored Count"}},"type":"object","required":["connection_id","sync_id","partition","connection_metadata","create_count","created_count","update_content_count","updated_content_count","update_metadata_count","updated_metadata_count","delete_count","deleted_count","errored_count"],"title":"ConnectionSyncProgressWebhookPayload"},"ConnectionSyncStartedWebhook":{"properties":{"nonce":{"type":"string","title":"Nonce"},"type":{"type":"string","const":"connection_sync_started","title":"Type"},"payload":{"$ref":"#/components/schemas/ConnectionSyncStartedWebhookPayload"}},"type":"object","required":["nonce","type","payload"],"title":"ConnectionSyncStartedWebhook"},"ConnectionSyncStartedWebhookPayload":{"properties":{"connection_id":{"type":"string","title":"Connection Id"},"sync_id":{"type":"string","title":"Sync Id"},"partition":{"type":"string","title":"Partition"},"connection_metadata":{"additionalProperties":true,"type":"object","title":"Connection Metadata"},"create_count":{"type":"integer","title":"Create Count"},"update_content_count":{"type":"integer","title":"Update Content Count"},"update_metadata_count":{"type":"integer","title":"Update Metadata Count"},"delete_count":{"type":"integer","title":"Delete Count"}},"type":"object","required":["connection_id","sync_id","partition","connection_metadata","create_count","update_content_count","update_metadata_count","delete_count"],"title":"ConnectionSyncStartedWebhookPayload"},"ConnectorSource":{"type":"string","enum":["backblaze","confluence","dropbox","freshdesk","onedrive","google_drive","gmail","intercom","notion","salesforce","sharepoint","jira","slack","s3","gcs","hubspot","webcrawler","zendesk"],"title":"ConnectorSource"},"ConnectorSourceTypeInfo":{"properties":{"source_type":{"$ref":"#/components/schemas/ConnectorSource"},"display_name":{"type":"string","title":"Display Name"},"icon_url":{"type":"string","title":"Icon Url"},"docs_url":{"type":"string","title":"Docs Url"}},"type":"object","required":["source_type","display_name","icon_url","docs_url"],"title":"ConnectorSourceTypeInfo"},"CreateAuthenticatorConnection":{"properties":{"partition_strategy":{"$ref":"#/components/schemas/MediaModeParam"},"partition":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Partition"},"page_limit":{"anyOf":[{"type":"integer"},{"type":"null"}],"title":"Page Limit","examples":[null,100]},"config":{"anyOf":[{"additionalProperties":true,"type":"object"},{"type":"null"}],"title":"Config","examples":[null]},"metadata":{"additionalProperties":{"anyOf":[{"type":"string"},{"type":"integer"},{"type":"number"},{"type":"boolean"},{"items":{"type":"string"},"type":"array"}]},"type":"object","title":"Metadata","description":"Metadata for the document. Keys must be strings. Values may be strings, numbers, booleans, or lists of strings. Numbers may be integers or floating point and will be converted to 64 bit floating point. 1000 total values are allowed. Each item in an array counts towards the total. The following keys are reserved for internal use: `document_id`, `document_type`, `document_source`, `document_name`, `document_uploaded_at`, `start_time`, `end_time`.","default":{}},"connection":{"oneOf":[{"$ref":"#/components/schemas/AuthenticatorConfluenceConnection"},{"$ref":"#/components/schemas/AuthenticatorDropboxConnection"},{"$ref":"#/components/schemas/AuthenticatorGoogleDriveConnection"},{"$ref":"#/components/schemas/AuthenticatorGmailConnection"},{"$ref":"#/components/schemas/AuthenticatorHubspotConnection"},{"$ref":"#/components/schemas/AuthenticatorJiraConnection"},{"$ref":"#/components/schemas/AuthenticatorNotionConnection"},{"$ref":"#/components/schemas/AuthenticatorOnedriveConnection"},{"$ref":"#/components/schemas/AuthenticatorSalesforceConnection"},{"$ref":"#/components/schemas/AuthenticatorSharepointConnection"},{"$ref":"#/components/schemas/AuthenticatorSlackConnection"}],"title":"Connection","discriminator":{"propertyName":"provider","mapping":{"confluence":"#/components/schemas/AuthenticatorConfluenceConnection","dropbox":"#/components/schemas/AuthenticatorDropboxConnection","gmail":"#/components/schemas/AuthenticatorGmailConnection","google_drive":"#/components/schemas/AuthenticatorGoogleDriveConnection","hubspot":"#/components/schemas/AuthenticatorHubspotConnection","jira":"#/components/schemas/AuthenticatorJiraConnection","notion":"#/components/schemas/AuthenticatorNotionConnection","onedrive":"#/components/schemas/AuthenticatorOnedriveConnection","salesforce":"#/components/schemas/AuthenticatorSalesforceConnection","sharepoint":"#/components/schemas/AuthenticatorSharepointConnection","slack":"#/components/schemas/AuthenticatorSlackConnection"}}}},"type":"object","required":["partition_strategy","connection"],"title":"CreateAuthenticatorConnection"},"CreateDocumentFromUrlParams":{"properties":{"name":{"type":"string","title":"Name"},"metadata":{"additionalProperties":{"anyOf":[{"type":"string"},{"type":"integer"},{"type":"number"},{"type":"boolean"},{"items":{"type":"string"},"type":"array"}]},"type":"object","title":"Metadata","description":"Metadata for the document. Keys must be strings. Values may be strings, numbers, booleans, or lists of strings. Numbers may be integers or floating point and will be converted to 64 bit floating point. 1000 total values are allowed. Each item in an array counts towards the total. The following keys are reserved for internal use: `document_id`, `document_type`, `document_source`, `document_name`, `document_uploaded_at`, `start_time`, `end_time`.","default":{}},"mode":{"anyOf":[{"type":"string","enum":["hi_res","fast"]},{"$ref":"#/components/schemas/MediaModeParam"}],"title":"Mode","description":"Partition strategy for the document. Different strategies exist for textual, audio and video file types and you can set the strategy you want for  each file type, or just for textual types.  For textual documents the options are `'hi_res'` or `'fast'`. When set to `'hi_res'`, images and tables will be extracted from the document. `'fast'` will only extract text. `'fast'` may be up to 20x faster than `'hi_res'`. `hi_res` is only applicable for Word documents, PDFs, Images, and PowerPoints. Images will always be processed in `hi_res`. If `hi_res` is set for an unsupported document type, it will be processed and billed in `fast` mode.  For audio files, the options are true or false. True if you want to process audio, false otherwise.          For video files, the options are `'audio_only'`, `'video_only'`, `'audio_video'`. `'audio_only'` will extract just the audio part of the video. `'video_only'` will similarly just extract the video part, ignoring audio. `'audio_video'` will extract both audio and video.  To process all media types at the highest quality, use `'all'`.  When you specify audio or video stategies, the format must be a JSON object. In this case, textual documents are denoted by the key \"static\". If you omit a key, that document type won't be processd.  See examples below.  Examples  Textual documents only     \"fast\"  Video documents only {     \"video\": \"audio_video\" }  Specify multiple document types {     \"static\": \"hi_res\",     \"audio\": true,     \"video\": \"video_only\" }  Specify only textual or audio document types {     \"static\": \"fast\",     \"audio\": true }  Highest quality processing for all media types     \"all\"","default":"fast"},"external_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"External Id","description":"An optional identifier for the document. A common value might be an id in an external system or the URL where the source file may be found."},"partition":{"type":"string","title":"Partition","description":"An optional partition identifier. Documents can be scoped to a partition. Partitions must be lowercase alphanumeric and may only include the special characters `_` and `-`.  A partition is created any time a document is created.","examples":[null]},"url":{"type":"string","maxLength":2083,"minLength":1,"format":"uri","title":"Url","description":"Url of the file to download. Must be publicly accessible and HTTP or HTTPS scheme."}},"type":"object","required":["url"],"title":"CreateDocumentFromUrlParams"},"CreateDocumentRawParams":{"properties":{"name":{"type":"string","title":"Name","description":"An optional name for the document. If set, the document will have this name. Otherwise it will default to the current timestamp."},"metadata":{"additionalProperties":{"anyOf":[{"type":"string"},{"type":"integer"},{"type":"number"},{"type":"boolean"},{"items":{"type":"string"},"type":"array"}]},"type":"object","title":"Metadata","description":"Metadata for the document. Keys must be strings. Values may be strings, numbers, booleans, or lists of strings. Numbers may be integers or floating point and will be converted to 64 bit floating point. 1000 total values are allowed. Each item in an array counts towards the total. The following keys are reserved for internal use: `document_id`, `document_type`, `document_source`, `document_name`, `document_uploaded_at`, `start_time`, `end_time`.","default":{}},"external_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"External Id","description":"An optional identifier for the document. A common value might be an id in an external system or the URL where the source file may be found."},"partition":{"type":"string","title":"Partition","description":"An optional partition identifier. Documents can be scoped to a partition. Partitions must be lowercase alphanumeric and may only include the special characters `_` and `-`.  A partition is created any time a document is created.","examples":[null]},"data":{"anyOf":[{"type":"string"},{"additionalProperties":true,"type":"object"}],"minLength":1,"title":"Data","description":"Document data in a text or JSON format."}},"type":"object","required":["data"],"title":"CreateDocumentRawParams"},"CreateGoogleAuthenticator":{"properties":{"provider":{"type":"string","const":"google","title":"Provider"},"name":{"type":"string","title":"Name","description":"The unique name of your authenticator, used to identify it and distinguish it from others. This name must be unique. Attempting to reuse the same name will result in an error."},"client_id":{"type":"string","title":"Client Id"},"client_secret":{"type":"string","title":"Client Secret"},"domain":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Domain"},"project_number":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Project Number"}},"type":"object","required":["provider","name","client_id","client_secret"],"title":"CreateGoogleAuthenticator"},"CreateInstructionParams":{"properties":{"name":{"type":"string","title":"Name","description":"The name of the instruction. Must be unique.","examples":["Find all pizzas"]},"active":{"type":"boolean","title":"Active","description":"Whether the instruction is active. Active instructions are applied to documents when they're created or when their file is updated.","default":true,"examples":[true]},"scope":{"type":"string","enum":["document","chunk"],"title":"Scope","description":"The scope of the instruction. Determines whether the instruction is applied to the entire document or to each chunk of the document. Options are `'document'` or `'chunk'`. Generally `'document'` should be used when analyzing the full document is desired, such as when generating a summary or determining sentiment, and `'chunk'` should be used when a fine grained search over a document is desired.","default":"chunk","examples":["document"]},"prompt":{"type":"string","title":"Prompt","description":"A natural language instruction which will be applied to documents as they are created and updated. The results of the `instruction_prompt` will be stored as an `entity` in the schema defined by the `entity_schema` parameter.","examples":["Find all pizzas described in the text."]},"entity_schema":{"$ref":"#/components/schemas/EntitySchema","description":"The JSON schema definition of the entity generated by an instruction. The schema must define an `object` at its root. If the instruction is expected to generate multiple items, the root object should have a key which defines an array of the expected items. An instruction which generates multiple emails may be expressed as `{\"type\": \"object\", \"properties\": {\"emails\": { \"type\": \"array\", \"items\": { \"type\": \"string\"}}}}`. Simple values may be expressed as an object with a single key. For example, a summary instruction may generate a single string value. The schema might be `{\"type\": \"object\", \"properties\": { \"summary\": { \"type\": \"string\"}}}`.","examples":[{"additionalProperties":false,"properties":{"size":{"enum":["small","medium","large"],"type":"string"},"crust":{"enum":["thin","thick","stuffed"],"type":"string"},"sauce":{"enum":["tomato","alfredo","pesto"],"type":"string"},"cheese":{"enum":["mozzarella","cheddar","parmesan","vegan"],"type":"string"},"toppings":{"items":{"enum":["pepperoni","mushrooms","onions","sausage","bacon","extra cheese","black olives","green peppers","pineapple","spinach"],"type":"string"},"type":"array","uniqueItems":true},"extraInstructions":{"type":"string"}},"required":["size","crust","sauce","cheese"],"title":"Pizza","type":"object"}],"additional_properties":true},"filter":{"additionalProperties":true,"type":"object","title":"Filter","description":"An optional metadata filter that is matched against document metadata during update and creation. The instruction will only be applied to documents with metadata matching the filter.  The following filter operators are supported: $eq - Equal to (number, string, boolean), $ne - Not equal to (number, string, boolean), $gt - Greater than (number), $gte - Greater than or equal to (number), $lt - Less than (number), $lte - Less than or equal to (number), $in - In array (string or number), $nin - Not in array (string or number). The operators can be combined with AND and OR. Read [Metadata & Filters guide](https://docs.ragie.ai/docs/metadata-filters) for more details and examples.","examples":[{"toppings":{"$in":["pizza","mushrooms"]}}]},"partition":{"type":"string","title":"Partition","description":"An optional partition identifier. Instructions can be scoped to a partition. An instruction that defines a partition will only be executed for documents in that partition.","examples":[null]}},"type":"object","required":["name","prompt","entity_schema"],"title":"CreateInstructionParams"},"CreatePartitionParams":{"properties":{"name":{"type":"string","title":"Name"},"description":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Description","description":"Description of the partition. Automatic description generation can be enabled in the web dashboard."},"pages_hosted_limit_monthly":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Pages Hosted Limit Monthly","description":"Monthly limit of hosted pages added in the current month in the partition.","examples":[1000]},"pages_processed_limit_monthly":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Pages Processed Limit Monthly","description":"Monthly limit, in pages, for processed documents in the partition.","examples":[1000]},"pages_hosted_limit_max":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Pages Hosted Limit Max","description":"Maximum limit, in pages, for hosted documents in the partition.","examples":[1000]},"pages_processed_limit_max":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Pages Processed Limit Max","description":"Maximum limit, in pages, for processed documents in the partition.","examples":[1000]},"audio_processed_limit_monthly":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Audio Processed Limit Monthly","description":"Monthly limit, in minutes, for audio processing in the partition.","examples":[60]},"audio_processed_limit_max":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Audio Processed Limit Max","description":"Maximum limit, in minutes, for audio processing in the partition.","examples":[60]},"video_processed_limit_monthly":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Video Processed Limit Monthly","description":"Monthly limit, in minutes, for video processing in the partition.","examples":[60]},"video_processed_limit_max":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Video Processed Limit Max","description":"Maximum limit, in minutes, for video processing in the partition.","examples":[60]},"media_streamed_limit_monthly":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Media Streamed Limit Monthly","description":"Monthly limit, in MBs, for media streamed from the partition.","examples":[1024]},"media_streamed_limit_max":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Media Streamed Limit Max","description":"Maximum limit, in MBs, for media streamed from the partition.","examples":[1024]},"media_hosted_limit_monthly":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Media Hosted Limit Monthly","description":"Monthly limit, in MBs, for media hosted in the partition.","examples":[1024]},"media_hosted_limit_max":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Media Hosted Limit Max","description":"Maximum limit, in MBs, for media hosted in the partition.","examples":[1024]},"metadata_schema":{"anyOf":[{"additionalProperties":{"anyOf":[{"type":"string"},{"type":"integer"},{"type":"boolean"},{"items":{"type":"string"},"type":"array"},{"additionalProperties":true,"type":"object"}]},"type":"object"},{"type":"null"}],"title":"Metadata Schema","description":"Metadata schema for the partition. This is an optional subset of the metadata of documents in the partition, defined as JSON Schema, that can be used in filter generatation. Providing detailed descriptions of the fields in the schema can be helpful for LLMs generating filters dynamically."}},"type":"object","required":["name"],"title":"CreatePartitionParams"},"DeleteConnectionPayload":{"properties":{"keep_files":{"type":"boolean","title":"Keep Files"}},"type":"object","required":["keep_files"],"title":"DeleteConnectionPayload"},"Document":{"properties":{"status":{"type":"string","title":"Status"},"id":{"type":"string","format":"uuid","title":"Id"},"created_at":{"type":"string","format":"date-time","title":"Created At"},"updated_at":{"type":"string","format":"date-time","title":"Updated At"},"name":{"type":"string","title":"Name"},"metadata":{"additionalProperties":{"anyOf":[{"type":"string"},{"type":"integer"},{"type":"number"},{"type":"boolean"},{"items":{"type":"string"},"type":"array"}]},"type":"object","title":"Metadata"},"partition":{"type":"string","title":"Partition"},"chunk_count":{"anyOf":[{"type":"integer"},{"type":"null"}],"title":"Chunk Count"},"external_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"External Id"},"page_count":{"anyOf":[{"type":"number"},{"type":"null"}],"title":"Page Count"}},"type":"object","required":["status","id","created_at","updated_at","name","metadata","partition"],"title":"Document"},"DocumentChunk":{"properties":{"id":{"type":"string","format":"uuid","title":"Id"},"index":{"type":"integer","title":"Index","default":-1},"text":{"type":"string","title":"Text"},"metadata":{"$ref":"#/components/schemas/ChunkMetadata","default":{}},"links":{"additionalProperties":{"$ref":"#/components/schemas/Link"},"type":"object","title":"Links"}},"type":"object","required":["id","text","links"],"title":"DocumentChunk"},"DocumentChunkDetail":{"properties":{"id":{"type":"string","format":"uuid","title":"Id"},"index":{"type":"integer","title":"Index","default":-1},"text":{"type":"string","title":"Text"},"metadata":{"$ref":"#/components/schemas/ChunkMetadata","default":{}},"links":{"additionalProperties":{"$ref":"#/components/schemas/Link"},"type":"object","title":"Links"},"modality_data":{"anyOf":[{"oneOf":[{"$ref":"#/components/schemas/AudioModalityData"},{"$ref":"#/components/schemas/VideoModalityData"}],"discriminator":{"propertyName":"type","mapping":{"audio":"#/components/schemas/AudioModalityData","video":"#/components/schemas/VideoModalityData"}}},{"type":"null"}],"title":"Modality Data","description":"Additional data specific to the modality of the chunk's source file, such as word level timestamps for chunks extracted from audio files."}},"type":"object","required":["id","text","links"],"title":"DocumentChunkDetail"},"DocumentChunkList":{"properties":{"pagination":{"$ref":"#/components/schemas/Pagination"},"chunks":{"items":{"$ref":"#/components/schemas/DocumentChunk"},"type":"array","title":"Chunks"}},"type":"object","required":["pagination","chunks"],"title":"DocumentChunkList"},"DocumentDelete":{"properties":{"status":{"type":"string","title":"Status"}},"type":"object","required":["status"],"title":"DocumentDelete"},"DocumentDeleteWebhook":{"properties":{"nonce":{"type":"string","title":"Nonce"},"type":{"type":"string","const":"document_deleted","title":"Type"},"payload":{"$ref":"#/components/schemas/DocumentDeleteWebhookPayload"}},"type":"object","required":["nonce","type","payload"],"title":"DocumentDeleteWebhook"},"DocumentDeleteWebhookPayload":{"properties":{"document_id":{"type":"string","title":"Document Id"},"partition":{"type":"string","title":"Partition"},"metadata":{"additionalProperties":true,"type":"object","title":"Metadata"},"external_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"External Id"},"name":{"type":"string","title":"Name"},"connection_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Connection Id"},"sync_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Sync Id"}},"type":"object","required":["document_id","partition","metadata","external_id","name","connection_id","sync_id"],"title":"DocumentDeleteWebhookPayload"},"DocumentFileUpdate":{"properties":{"status":{"type":"string","title":"Status"}},"type":"object","required":["status"],"title":"DocumentFileUpdate"},"DocumentGet":{"properties":{"status":{"type":"string","title":"Status"},"id":{"type":"string","format":"uuid","title":"Id"},"created_at":{"type":"string","format":"date-time","title":"Created At"},"updated_at":{"type":"string","format":"date-time","title":"Updated At"},"name":{"type":"string","title":"Name"},"metadata":{"additionalProperties":{"anyOf":[{"type":"string"},{"type":"integer"},{"type":"number"},{"type":"boolean"},{"items":{"type":"string"},"type":"array"}]},"type":"object","title":"Metadata"},"partition":{"type":"string","title":"Partition"},"chunk_count":{"anyOf":[{"type":"integer"},{"type":"null"}],"title":"Chunk Count"},"external_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"External Id"},"page_count":{"anyOf":[{"type":"number"},{"type":"null"}],"title":"Page Count"},"errors":{"items":{"type":"string"},"type":"array","title":"Errors"}},"type":"object","required":["status","id","created_at","updated_at","name","metadata","partition","errors"],"title":"DocumentGet"},"DocumentList":{"properties":{"pagination":{"$ref":"#/components/schemas/Pagination"},"documents":{"items":{"$ref":"#/components/schemas/Document"},"type":"array","title":"Documents"}},"type":"object","required":["pagination","documents"],"title":"DocumentList"},"DocumentMetadata":{"properties":{},"additionalProperties":true,"type":"object","title":"DocumentMetadata"},"DocumentMetadataUpdate":{"properties":{"metadata":{"additionalProperties":{"anyOf":[{"type":"string"},{"type":"integer"},{"type":"number"},{"type":"boolean"},{"items":{"type":"string"},"type":"array"}]},"type":"object","title":"Metadata","description":"The full document metadata inclusive of the update.","examples":[{"editors":["Alice","Bob"],"title":"declassified report","unchanged_key":"unchanged_value","updated_at":1714491736216}]}},"type":"object","required":["metadata"],"title":"DocumentMetadataUpdate"},"DocumentRawUpdate":{"properties":{"status":{"type":"string","title":"Status"}},"type":"object","required":["status"],"title":"DocumentRawUpdate"},"DocumentSummary":{"properties":{"document_id":{"type":"string","title":"Document Id"},"summary":{"type":"string","title":"Summary"}},"type":"object","required":["document_id","summary"],"title":"DocumentSummary"},"DocumentUpdateWebhook":{"properties":{"nonce":{"type":"string","title":"Nonce"},"type":{"type":"string","const":"document_status_updated","title":"Type"},"payload":{"$ref":"#/components/schemas/DocumentUpdateWebhookPayload"}},"type":"object","required":["nonce","type","payload"],"title":"DocumentUpdateWebhook"},"DocumentUpdateWebhookPayload":{"properties":{"document_id":{"type":"string","title":"Document Id"},"status":{"anyOf":[{"type":"string","const":"ready"},{"type":"string","const":"failed"},{"type":"string","const":"indexed"},{"type":"string","const":"keyword_indexed"}],"title":"Status"},"partition":{"type":"string","title":"Partition"},"metadata":{"additionalProperties":true,"type":"object","title":"Metadata"},"external_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"External Id"},"name":{"type":"string","title":"Name"},"connection_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Connection Id"},"sync_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Sync Id"},"error":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Error"}},"type":"object","required":["document_id","status","partition","metadata","external_id","name","connection_id","sync_id","error"],"title":"DocumentUpdateWebhookPayload"},"DocumentUrlUpdate":{"properties":{"status":{"type":"string","title":"Status"}},"type":"object","required":["status"],"title":"DocumentUrlUpdate"},"DocumentWithContent":{"properties":{"status":{"type":"string","title":"Status"},"id":{"type":"string","format":"uuid","title":"Id"},"created_at":{"type":"string","format":"date-time","title":"Created At"},"updated_at":{"type":"string","format":"date-time","title":"Updated At"},"name":{"type":"string","title":"Name"},"metadata":{"additionalProperties":{"anyOf":[{"type":"string"},{"type":"integer"},{"type":"number"},{"type":"boolean"},{"items":{"type":"string"},"type":"array"}]},"type":"object","title":"Metadata"},"partition":{"type":"string","title":"Partition"},"chunk_count":{"anyOf":[{"type":"integer"},{"type":"null"}],"title":"Chunk Count"},"external_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"External Id"},"page_count":{"anyOf":[{"type":"number"},{"type":"null"}],"title":"Page Count"},"content":{"type":"string","title":"Content"}},"type":"object","required":["status","id","created_at","updated_at","name","metadata","partition","content"],"title":"DocumentWithContent"},"Entity":{"properties":{"id":{"type":"string","format":"uuid","title":"Id"},"created_at":{"type":"string","format":"date-time","title":"Created At"},"updated_at":{"type":"string","format":"date-time","title":"Updated At"},"instruction_id":{"type":"string","format":"uuid","title":"Instruction Id","description":"The ID of the instruction which generated the entity."},"document_id":{"type":"string","format":"uuid","title":"Document Id","description":"The ID of the document which the entity was produced from."},"chunk_id":{"anyOf":[{"type":"string","format":"uuid"},{"type":"null"}],"title":"Chunk Id"},"data":{"$ref":"#/components/schemas/EntityData","description":"The entity data generated by the instruction."}},"type":"object","required":["id","created_at","updated_at","instruction_id","document_id","data"],"title":"Entity"},"EntityData":{"properties":{},"additionalProperties":true,"type":"object","title":"EntityData"},"EntityExtractedWebhook":{"properties":{"nonce":{"type":"string","title":"Nonce"},"type":{"type":"string","const":"entity_extracted","title":"Type"},"payload":{"$ref":"#/components/schemas/EntityExtractedWebhookPayload"}},"type":"object","required":["nonce","type","payload"],"title":"EntityExtractedWebhook"},"EntityExtractedWebhookPayload":{"properties":{"entity_id":{"type":"string","title":"Entity Id"},"document_id":{"type":"string","title":"Document Id"},"instruction_id":{"type":"string","title":"Instruction Id"},"document_metadata":{"additionalProperties":true,"type":"object","title":"Document Metadata"},"document_external_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Document External Id"},"document_name":{"type":"string","title":"Document Name"},"partition":{"type":"string","title":"Partition"},"sync_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Sync Id"},"data":{"additionalProperties":true,"type":"object","title":"Data"}},"type":"object","required":["entity_id","document_id","instruction_id","document_metadata","document_external_id","document_name","partition","sync_id","data"],"title":"EntityExtractedWebhookPayload"},"EntityList":{"properties":{"pagination":{"$ref":"#/components/schemas/Pagination"},"entities":{"items":{"$ref":"#/components/schemas/Entity"},"type":"array","title":"Entities"}},"type":"object","required":["pagination","entities"],"title":"EntityList"},"EntitySchema":{"additionalProperties":true,"type":"object","title":"EntitySchema"},"ErrorMessage":{"properties":{"detail":{"type":"string","title":"Detail"}},"type":"object","required":["detail"],"title":"ErrorMessage"},"EvaluatedAnswerStep":{"properties":{"type":{"type":"string","const":"evaluated_answer","title":"Type","default":"evaluated_answer"},"think":{"type":"string","title":"Think"},"current_question":{"type":"string","title":"Current Question"},"errored":{"type":"boolean","title":"Errored","default":false},"answer":{"$ref":"#/components/schemas/Answer"},"other_resolved_question_ids":{"items":{"type":"string"},"type":"array","title":"Other Resolved Question Ids","description":"A list of questions ids that are no longer relevant to the current answer referenced by their IDs."},"eval_passed":{"type":"boolean","title":"Eval Passed"},"eval_reason":{"type":"string","title":"Eval Reason"}},"type":"object","required":["think","current_question","answer","eval_passed","eval_reason"],"title":"EvaluatedAnswerStep"},"FailedStep":{"properties":{"type":{"type":"string","const":"failed","title":"Type","default":"failed"},"think":{"type":"string","title":"Think"},"current_question":{"type":"string","title":"Current Question"},"errored":{"type":"boolean","title":"Errored","default":false}},"type":"object","required":["think","current_question"],"title":"FailedStep"},"FileSearchOutput":{"properties":{"id":{"type":"string","title":"Id"},"queries":{"items":{"type":"string"},"type":"array","title":"Queries","description":"The queries used to search for files."},"status":{"type":"string","enum":["in_progress","searching","incomplete","completed","failed"],"title":"Status","default":"searching"},"type":{"type":"string","const":"file_search_call","title":"Type"},"results":{"items":{"$ref":"#/components/schemas/FileSearchResult"},"type":"array","title":"Results","description":"The results of the file search tool call."}},"type":"object","required":["id","queries","type","results"],"title":"FileSearchOutput"},"FileSearchResult":{"properties":{"file_id":{"type":"string","title":"File Id","description":"The unique ID of the document."},"filename":{"type":"string","title":"Filename","description":"The name of the document."},"score":{"type":"number","title":"Score","description":"The relevance score of the chunk - a value between 0 and 1."},"text":{"type":"string","title":"Text","description":"The text content of the chunk."},"attributes":{"additionalProperties":true,"type":"object","title":"Attributes","description":"The attributes of the chunk."}},"type":"object","required":["file_id","filename","score","text","attributes"],"title":"FileSearchResult"},"FinalAnswer":{"properties":{"text":{"type":"string","title":"Text","description":"The final answer to the question."},"evidence":{"items":{"anyOf":[{"$ref":"#/components/schemas/CodeInterpreterEvidence"},{"$ref":"#/components/schemas/RagieEvidence"}]},"type":"array","title":"Evidence","description":"The evidence used to derive the answer."},"steps":{"items":{"anyOf":[{"$ref":"#/components/schemas/AnswerStep"},{"$ref":"#/components/schemas/SearchStep"},{"$ref":"#/components/schemas/SearchStepWithQueryDetails"},{"$ref":"#/components/schemas/PlanStep"},{"$ref":"#/components/schemas/CodeStep"},{"$ref":"#/components/schemas/SurrenderStep"},{"$ref":"#/components/schemas/EvaluatedAnswerStep"},{"$ref":"#/components/schemas/FailedStep"}]},"type":"array","title":"Steps","description":"The steps that led to the answer."},"usage":{"$ref":"#/components/schemas/agent_hopps__models__models__Usage","description":"The usage of the models."}},"type":"object","required":["text"],"title":"FinalAnswer"},"FolderData":{"properties":{"folder_id":{"type":"string","title":"Folder Id"},"folder_name":{"type":"string","title":"Folder Name"}},"type":"object","required":["folder_id","folder_name"],"title":"FolderData"},"FreshdeskCredentials":{"properties":{"domain":{"type":"string","title":"Domain"},"api_key":{"type":"string","title":"Api Key"}},"type":"object","required":["domain","api_key"],"title":"FreshdeskCredentials"},"FreshdeskData":{"properties":{"tickets":{"type":"boolean","title":"Tickets"},"articles":{"type":"boolean","title":"Articles"}},"type":"object","required":["tickets","articles"],"title":"FreshdeskData"},"GmailData":{"properties":{"label":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Label"}},"type":"object","title":"GmailData"},"GoogleFolderData":{"properties":{"id":{"type":"string","title":"Id"},"name":{"type":"string","title":"Name"},"mime_type":{"type":"string","title":"Mime Type"}},"type":"object","required":["id","name","mime_type"],"title":"GoogleFolderData"},"HTTPValidationError":{"properties":{"detail":{"items":{"$ref":"#/components/schemas/ValidationError"},"type":"array","title":"Detail"}},"type":"object","title":"HTTPValidationError"},"HubspotData":{"properties":{"companies":{"type":"boolean","title":"Companies"},"contacts":{"type":"boolean","title":"Contacts"},"contact_notes":{"type":"boolean","title":"Contact Notes"},"deals":{"type":"boolean","title":"Deals"},"deal_notes":{"type":"boolean","title":"Deal Notes"},"emails":{"type":"boolean","title":"Emails"},"tasks":{"type":"boolean","title":"Tasks"}},"type":"object","required":["companies","contacts","contact_notes","deals","deal_notes","emails","tasks"],"title":"HubspotData"},"InputTokenDetails":{"properties":{"cached_tokens":{"type":"integer","title":"Cached Tokens","default":0}},"type":"object","title":"InputTokenDetails"},"Instruction":{"properties":{"id":{"type":"string","format":"uuid","title":"Id"},"created_at":{"type":"string","format":"date-time","title":"Created At"},"updated_at":{"type":"string","format":"date-time","title":"Updated At"},"name":{"type":"string","title":"Name","description":"The name of the instruction. Must be unique.","examples":["Find all pizzas"]},"active":{"type":"boolean","title":"Active","description":"Whether the instruction is active. Active instructions are applied to documents when they're created or when their file is updated.","default":true,"examples":[true]},"scope":{"type":"string","enum":["document","chunk"],"title":"Scope","description":"The scope of the instruction. Determines whether the instruction is applied to the entire document or to each chunk of the document. Options are `'document'` or `'chunk'`. Generally `'document'` should be used when analyzing the full document is desired, such as when generating a summary or determining sentiment, and `'chunk'` should be used when a fine grained search over a document is desired.","default":"chunk","examples":["document"]},"prompt":{"type":"string","title":"Prompt","description":"A natural language instruction which will be applied to documents as they are created and updated. The results of the `instruction_prompt` will be stored as an `entity` in the schema defined by the `entity_schema` parameter.","examples":["Find all pizzas described in the text."]},"entity_schema":{"$ref":"#/components/schemas/EntitySchema","description":"The JSON schema definition of the entity generated by an instruction. The schema must define an `object` at its root. If the instruction is expected to generate multiple items, the root object should have a key which defines an array of the expected items. An instruction which generates multiple emails may be expressed as `{\"type\": \"object\", \"properties\": {\"emails\": { \"type\": \"array\", \"items\": { \"type\": \"string\"}}}}`. Simple values may be expressed as an object with a single key. For example, a summary instruction may generate a single string value. The schema might be `{\"type\": \"object\", \"properties\": { \"summary\": { \"type\": \"string\"}}}`.","examples":[{"additionalProperties":false,"properties":{"size":{"enum":["small","medium","large"],"type":"string"},"crust":{"enum":["thin","thick","stuffed"],"type":"string"},"sauce":{"enum":["tomato","alfredo","pesto"],"type":"string"},"cheese":{"enum":["mozzarella","cheddar","parmesan","vegan"],"type":"string"},"toppings":{"items":{"enum":["pepperoni","mushrooms","onions","sausage","bacon","extra cheese","black olives","green peppers","pineapple","spinach"],"type":"string"},"type":"array","uniqueItems":true},"extraInstructions":{"type":"string"}},"required":["size","crust","sauce","cheese"],"title":"Pizza","type":"object"}],"additional_properties":true},"filter":{"additionalProperties":true,"type":"object","title":"Filter","description":"An optional metadata filter that is matched against document metadata during update and creation. The instruction will only be applied to documents with metadata matching the filter.  The following filter operators are supported: $eq - Equal to (number, string, boolean), $ne - Not equal to (number, string, boolean), $gt - Greater than (number), $gte - Greater than or equal to (number), $lt - Less than (number), $lte - Less than or equal to (number), $in - In array (string or number), $nin - Not in array (string or number). The operators can be combined with AND and OR. Read [Metadata & Filters guide](https://docs.ragie.ai/docs/metadata-filters) for more details and examples.","examples":[{"toppings":{"$in":["pizza","mushrooms"]}}]},"partition":{"type":"string","title":"Partition","description":"An optional partition identifier. Instructions can be scoped to a partition. An instruction that defines a partition will only be executed for documents in that partition.","examples":[null]}},"type":"object","required":["id","created_at","updated_at","name","prompt","entity_schema"],"title":"Instruction"},"IntercomCredentials":{"properties":{"access_token":{"type":"string","title":"Access Token"},"app_name":{"type":"string","title":"App Name"},"user_email":{"type":"string","title":"User Email","description":"The email of the Intercom account this is for"}},"type":"object","required":["access_token","app_name","user_email"],"title":"IntercomCredentials"},"IntercomData":{"properties":{"articles_help_center":{"type":"boolean","title":"Articles Help Center","default":false},"admins":{"type":"boolean","title":"Admins","default":false},"contacts":{"type":"boolean","title":"Contacts","default":false},"conversations":{"type":"boolean","title":"Conversations","default":false},"conversation_attachments":{"type":"boolean","title":"Conversation Attachments","default":false},"conversation_notes":{"type":"boolean","title":"Conversation Notes","default":false},"tickets":{"type":"boolean","title":"Tickets","default":false},"ticket_attachments":{"type":"boolean","title":"Ticket Attachments","default":false},"ticket_comments":{"type":"boolean","title":"Ticket Comments","default":false},"ticket_notes":{"type":"boolean","title":"Ticket Notes","default":false},"filter_user_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Filter User Id"}},"type":"object","title":"IntercomData"},"Link":{"properties":{"href":{"type":"string","title":"Href"},"type":{"type":"string","title":"Type"}},"type":"object","required":["href","type"],"title":"Link"},"ListConnectorSourceTypeInfo":{"properties":{"connectors":{"items":{"$ref":"#/components/schemas/ConnectorSourceTypeInfo"},"type":"array","title":"Connectors"}},"type":"object","required":["connectors"],"title":"ListConnectorSourceTypeInfo"},"MediaModeParam":{"properties":{"static":{"anyOf":[{"type":"string","enum":["hi_res","fast"]},{"type":"null"}],"title":"Static"},"audio":{"anyOf":[{"type":"boolean"},{"type":"null"}],"title":"Audio"},"video":{"anyOf":[{"type":"string","enum":["audio_only","video_only","audio_video"]},{"type":"null"}],"title":"Video"}},"type":"object","title":"MediaModeParam"},"MetadataFilter":{"additionalProperties":true,"type":"object","title":"MetadataFilter"},"ModelUsage":{"properties":{"model_name":{"type":"string","title":"Model Name"},"input_tokens":{"type":"integer","title":"Input Tokens"},"output_tokens":{"type":"integer","title":"Output Tokens"}},"type":"object","required":["model_name","input_tokens","output_tokens"],"title":"ModelUsage"},"OAuthCredentials":{"properties":{"provider":{"type":"string","enum":["atlassian","dropbox","microsoft","salesforce","slack","hubspot"],"title":"Provider"},"name":{"type":"string","title":"Name","description":"The unique name of your authenticator, used to identify it and distinguish it from others. This name must be unique. Attempting to reuse the same name will result in an error."},"client_id":{"type":"string","title":"Client Id"},"client_secret":{"type":"string","title":"Client Secret"},"domain":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Domain"}},"type":"object","required":["provider","name","client_id","client_secret"],"title":"OAuthCredentials"},"OAuthRefreshTokenCredentials":{"properties":{"refresh_token":{"type":"string","title":"Refresh Token"}},"type":"object","required":["refresh_token"],"title":"OAuthRefreshTokenCredentials"},"OAuthUrlCreate":{"properties":{"redirect_uri":{"type":"string","title":"Redirect Uri"},"partition":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Partition"},"source_type":{"$ref":"#/components/schemas/ConnectorSource","description":"The type of connector you want to create, such as google_drive, notion, hubspot, etc.","default":"google_drive"},"metadata":{"additionalProperties":{"anyOf":[{"type":"string"},{"type":"integer"},{"type":"number"},{"type":"boolean"},{"items":{"type":"string"},"type":"array"}]},"type":"object","title":"Metadata","description":"Metadata for the document. Keys must be strings. Values may be strings, numbers, booleans, or lists of strings. Numbers may be integers or floating point and will be converted to 64 bit floating point. 1000 total values are allowed. Each item in an array counts towards the total. The following keys are reserved for internal use: `document_id`, `document_type`, `document_source`, `document_name`, `document_uploaded_at`, `start_time`, `end_time`.","default":{}},"mode":{"anyOf":[{"type":"string","enum":["hi_res","fast"]},{"$ref":"#/components/schemas/MediaModeParam"},{"type":"null"}],"title":"Mode"},"theme":{"anyOf":[{"type":"string","enum":["light","dark","system"]},{"type":"null"}],"title":"Theme","description":"Sets the theme of the Ragie Web UI when the user lands there. Can be light, dark, or system to use whatever the system value is. If omitted, system is used.","default":"system"},"page_limit":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Page Limit","description":"The maximum number of pages a connection will sync. The connection will be disabled after this limit is reached. Some in progress documents may continue processing after the limit is reached. The limit will be enforced at the start of the next document sync. Remove the limit by setting to null.","examples":[1000]},"config":{"additionalProperties":true,"type":"object","title":"Config","description":"Optional config per connector","examples":[]},"authenticator_id":{"anyOf":[{"type":"string","format":"uuid"},{"type":"null"}],"title":"Authenticator Id"}},"type":"object","required":["redirect_uri"],"title":"OAuthUrlCreate"},"OAuthUrlResponse":{"properties":{"url":{"type":"string","title":"Url"}},"type":"object","required":["url"],"title":"OAuthUrlResponse"},"OnedriveData":{"properties":{"drive_id":{"type":"string","title":"Drive Id"},"folder_id":{"type":"string","title":"Folder Id"},"folder_name":{"type":"string","title":"Folder Name"}},"type":"object","required":["drive_id","folder_id","folder_name"],"title":"OnedriveData"},"OutputTokenDetails":{"properties":{"reasoning_tokens":{"type":"integer","title":"Reasoning Tokens","default":0}},"type":"object","title":"OutputTokenDetails"},"Pagination":{"properties":{"next_cursor":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Next Cursor"},"total_count":{"type":"integer","title":"Total Count"}},"type":"object","required":["total_count"],"title":"Pagination"},"Partition":{"properties":{"name":{"type":"string","title":"Name"},"is_default":{"type":"boolean","title":"Is Default"},"limit_exceeded_at":{"anyOf":[{"type":"string","format":"date-time"},{"type":"null"}],"title":"Limit Exceeded At","description":"Timestamp when the partition exceeded its limits, if applicable.","examples":["2025-06-11T12:00:00Z"]},"description":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Description"},"context_aware":{"type":"boolean","title":"Context Aware"},"metadata_schema":{"anyOf":[{"additionalProperties":{"anyOf":[{"type":"string"},{"type":"integer"},{"type":"boolean"},{"items":{"type":"string"},"type":"array"},{"additionalProperties":true,"type":"object"}]},"type":"object"},{"type":"null"}],"title":"Metadata Schema"},"limits":{"$ref":"#/components/schemas/PartitionLimits"}},"type":"object","required":["name","is_default","description","context_aware","metadata_schema","limits"],"title":"Partition"},"PartitionDetail":{"properties":{"name":{"type":"string","title":"Name"},"is_default":{"type":"boolean","title":"Is Default"},"limit_exceeded_at":{"anyOf":[{"type":"string","format":"date-time"},{"type":"null"}],"title":"Limit Exceeded At","description":"Timestamp when the partition exceeded its limits, if applicable.","examples":["2025-06-11T12:00:00Z"]},"description":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Description"},"context_aware":{"type":"boolean","title":"Context Aware"},"metadata_schema":{"anyOf":[{"additionalProperties":{"anyOf":[{"type":"string"},{"type":"integer"},{"type":"boolean"},{"items":{"type":"string"},"type":"array"},{"additionalProperties":true,"type":"object"}]},"type":"object"},{"type":"null"}],"title":"Metadata Schema"},"limits":{"$ref":"#/components/schemas/PartitionLimits"},"stats":{"$ref":"#/components/schemas/PartitionStats"}},"type":"object","required":["name","is_default","description","context_aware","metadata_schema","limits","stats"],"title":"PartitionDetail"},"PartitionLimitExceededWebhook":{"properties":{"nonce":{"type":"string","title":"Nonce"},"type":{"type":"string","const":"partition_limit_exceeded","title":"Type"},"payload":{"$ref":"#/components/schemas/PartitionLimitExceededWebhookPayload"}},"type":"object","required":["nonce","type","payload"],"title":"PartitionLimitExceededWebhook"},"PartitionLimitExceededWebhookPayload":{"properties":{"partition":{"type":"string","title":"Partition"},"limit_type":{"type":"string","enum":["pages_processed_limit_monthly","pages_hosted_limit_monthly","pages_processed_limit_max","pages_hosted_limit_max","video_processed_limit_monthly","video_processed_limit_max","audio_processed_limit_monthly","audio_processed_limit_max","media_streamed_limit_monthly","media_streamed_limit_max","media_hosted_limit_monthly","media_hosted_limit_max"],"title":"Limit Type"}},"type":"object","required":["partition","limit_type"],"title":"PartitionLimitExceededWebhookPayload"},"PartitionLimitParams":{"properties":{"pages_hosted_limit_monthly":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Pages Hosted Limit Monthly","description":"Monthly limit of hosted pages added in the current month in the partition.","examples":[1000]},"pages_processed_limit_monthly":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Pages Processed Limit Monthly","description":"Monthly limit, in pages, for processed documents in the partition.","examples":[1000]},"pages_hosted_limit_max":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Pages Hosted Limit Max","description":"Maximum limit, in pages, for hosted documents in the partition.","examples":[1000]},"pages_processed_limit_max":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Pages Processed Limit Max","description":"Maximum limit, in pages, for processed documents in the partition.","examples":[1000]},"video_processed_limit_monthly":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Video Processed Limit Monthly","description":"Monthly limit, in minutes, for video processing in the partition.","examples":[3600]},"video_processed_limit_max":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Video Processed Limit Max","description":"Maximum limit, in minutes, for video processing in the partition.","examples":[3600]},"audio_processed_limit_monthly":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Audio Processed Limit Monthly","description":"Monthly limit, in minutes, for audio processing in the partition.","examples":[3600]},"audio_processed_limit_max":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Audio Processed Limit Max","description":"Maximum limit, in minutes, for audio processing in the partition.","examples":[3600]},"media_streamed_limit_monthly":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Media Streamed Limit Monthly","description":"Monthly limit, in MBs, for media streamed from the partition.","examples":[1024]},"media_streamed_limit_max":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Media Streamed Limit Max","description":"Maximum limit, in MBs, for media streamed from the partition.","examples":[1024]},"media_hosted_limit_monthly":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Media Hosted Limit Monthly","description":"Monthly limit, in MBs, for media hosted in the partition.","examples":[1024]},"media_hosted_limit_max":{"anyOf":[{"type":"integer","minimum":1.0},{"type":"null"}],"title":"Media Hosted Limit Max","description":"Maximum limit, in MBs, for media hosted in the partition.","examples":[1024]}},"type":"object","title":"PartitionLimitParams"},"PartitionLimitResetWebhook":{"properties":{"nonce":{"type":"string","title":"Nonce"},"type":{"type":"string","const":"partition_limit_reset","title":"Type"},"payload":{"$ref":"#/components/schemas/PartitionLimitResetWebhookPayload"}},"type":"object","required":["nonce","type","payload"],"title":"PartitionLimitResetWebhook"},"PartitionLimitResetWebhookPayload":{"properties":{"partition":{"type":"string","title":"Partition"}},"type":"object","required":["partition"],"title":"PartitionLimitResetWebhookPayload"},"PartitionLimits":{"properties":{"pages_processed_limit_monthly":{"anyOf":[{"type":"integer","minimum":0.0},{"type":"null"}],"title":"Pages Processed Limit Monthly","description":"Monthly limit, in pages, for processed documents in the partition.","examples":[1000]},"pages_hosted_limit_monthly":{"anyOf":[{"type":"integer","minimum":0.0},{"type":"null"}],"title":"Pages Hosted Limit Monthly","description":"Monthly limit of hosted pages added in the current month in the partition.","examples":[1000]},"pages_processed_limit_max":{"anyOf":[{"type":"integer","minimum":0.0},{"type":"null"}],"title":"Pages Processed Limit Max","description":"Maximum limit, in pages, for processed documents in the partition.","examples":[1000]},"pages_hosted_limit_max":{"anyOf":[{"type":"integer","minimum":0.0},{"type":"null"}],"title":"Pages Hosted Limit Max","description":"Maximum limit, in pages, for hosted documents in the partition.","examples":[1000]},"video_processed_limit_monthly":{"anyOf":[{"type":"integer","minimum":0.0},{"type":"null"}],"title":"Video Processed Limit Monthly","description":"Monthly limit, in minutes, for video processing in the partition.","examples":[60]},"video_processed_limit_max":{"anyOf":[{"type":"integer","minimum":0.0},{"type":"null"}],"title":"Video Processed Limit Max","description":"Maximum limit, in minutes, for video processing in the partition.","examples":[60]},"audio_processed_limit_monthly":{"anyOf":[{"type":"integer","minimum":0.0},{"type":"null"}],"title":"Audio Processed Limit Monthly","description":"Monthly limit, in minutes, for audio processing in the partition.","examples":[60]},"audio_processed_limit_max":{"anyOf":[{"type":"integer","minimum":0.0},{"type":"null"}],"title":"Audio Processed Limit Max","description":"Maximum limit, in minutes, for audio processing in the partition.","examples":[60]},"media_streamed_limit_monthly":{"anyOf":[{"type":"integer","minimum":0.0},{"type":"null"}],"title":"Media Streamed Limit Monthly","description":"Monthly limit, in MBs, for media streamed from the partition.","examples":[1024]},"media_streamed_limit_max":{"anyOf":[{"type":"integer","minimum":0.0},{"type":"null"}],"title":"Media Streamed Limit Max","description":"Maximum limit, in MBs, for media streamed from the partition.","examples":[1024]},"media_hosted_limit_monthly":{"anyOf":[{"type":"integer","minimum":0.0},{"type":"null"}],"title":"Media Hosted Limit Monthly","description":"Monthly limit, in MBs, for media hosted in the partition.","examples":[1024]},"media_hosted_limit_max":{"anyOf":[{"type":"integer","minimum":0.0},{"type":"null"}],"title":"Media Hosted Limit Max","description":"Maximum limit, in MBs, for media hosted in the partition.","examples":[1024]}},"type":"object","title":"PartitionLimits"},"PartitionList":{"properties":{"pagination":{"$ref":"#/components/schemas/Pagination"},"partitions":{"items":{"$ref":"#/components/schemas/Partition"},"type":"array","title":"Partitions"}},"type":"object","required":["pagination","partitions"],"title":"PartitionList"},"PartitionStats":{"properties":{"pages_processed_monthly":{"type":"number","title":"Pages Processed Monthly","description":"Number of pages processed in the current month in this partition.","examples":[1000.0]},"pages_hosted_monthly":{"type":"number","title":"Pages Hosted Monthly","description":"Number of hosted pages added in the current month in this partition.","examples":[1000.0]},"pages_processed_total":{"type":"number","title":"Pages Processed Total","description":"Total number of pages processed in this partition.","examples":[1000.0]},"pages_hosted_total":{"type":"number","title":"Pages Hosted Total","description":"Total number of hosted pages in this partition.","examples":[1000.0]},"document_count":{"type":"integer","title":"Document Count","description":"Total number of documents, inclusive of all files types, in this partition.","examples":[1000]},"video_processed_monthly":{"type":"number","title":"Video Processed Monthly","description":"Total number of seconds of video processed in the current month in this partition.","examples":[60]},"video_processed_total":{"type":"number","title":"Video Processed Total","description":"Total number of seconds of video processed in this partition.","examples":[60]},"audio_processed_monthly":{"type":"number","title":"Audio Processed Monthly","description":"Total number of seconds of audio processed in the current month in this partition.","examples":[60]},"audio_processed_total":{"type":"number","title":"Audio Processed Total","description":"Total number of seconds of audio processed in this partition.","examples":[60]},"media_streamed_monthly":{"type":"number","title":"Media Streamed Monthly","description":"Total number of MBs streamed in the current month in this partition.","examples":[1024]},"media_streamed_total":{"type":"number","title":"Media Streamed Total","description":"Total number of MBs streamed in this partition.","examples":[1024]},"media_hosted_monthly":{"type":"number","title":"Media Hosted Monthly","description":"Total number of MBs hosted in the current month in this partition.","examples":[1024]},"media_hosted_total":{"type":"number","title":"Media Hosted Total","description":"Total number of MBs hosted in this partition.","examples":[1024]}},"type":"object","required":["pages_processed_monthly","pages_hosted_monthly","pages_processed_total","pages_hosted_total","document_count","video_processed_monthly","video_processed_total","audio_processed_monthly","audio_processed_total","media_streamed_monthly","media_streamed_total","media_hosted_monthly","media_hosted_total"],"title":"PartitionStats"},"PatchDocumentMetadataParams":{"properties":{"metadata":{"additionalProperties":true,"type":"object","title":"Metadata","description":"The metadata to update on the document. Performs a partial update of the document's metadata. Keys must be strings. Values may be strings, numbers, booleans, or lists of strings. Numbers may be integers or floating point and will be converted to 64 bit floating point. Keys set to `null` are deleted. 1000 total values are allowed, inclusive of existing metadata. Each item in an array counts towards the total. The following keys are reserved for internal use: `document_id`, `document_type`, `document_source`, `document_name`, `document_uploaded_at`. If the document is managed by a connection, this operation will extend a metadata overlay which is applied to the document any time the connection syncs the document.","examples":[{"classified":"null (setting null deletes key from metadata)","editors":["Alice","Bob"],"published":true,"articleCount":42,"title":"declassified report"}]},"async":{"type":"boolean","title":"Async","description":"Whether to run the metadata update asynchronously. If true, the metadata update will be run in the background and the response will be 202. If false, the metadata update will be run synchronously and the response will be 200.","default":false}},"type":"object","required":["metadata"],"title":"PatchDocumentMetadataParams"},"PlanStep":{"properties":{"type":{"type":"string","const":"plan","title":"Type","default":"plan"},"think":{"type":"string","title":"Think"},"current_question":{"type":"string","title":"Current Question"},"errored":{"type":"boolean","title":"Errored","default":false},"questions_to_answer":{"items":{"type":"string"},"type":"array","title":"Questions To Answer","description":"The questions that need to be answered to answer the original question."}},"type":"object","required":["think","current_question"],"title":"PlanStep"},"PublicBackblazeConnection":{"properties":{"provider":{"type":"string","const":"backblaze","title":"Provider"},"data":{"$ref":"#/components/schemas/BucketData"},"credentials":{"$ref":"#/components/schemas/BackblazeCredentials"}},"type":"object","required":["provider","data","credentials"],"title":"PublicBackblazeConnection"},"PublicCreateConnection":{"properties":{"partition_strategy":{"$ref":"#/components/schemas/MediaModeParam"},"partition":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Partition"},"page_limit":{"anyOf":[{"type":"integer"},{"type":"null"}],"title":"Page Limit","examples":[null,100]},"config":{"anyOf":[{"additionalProperties":true,"type":"object"},{"type":"null"}],"title":"Config","examples":[null]},"metadata":{"additionalProperties":{"anyOf":[{"type":"string"},{"type":"integer"},{"type":"number"},{"type":"boolean"},{"items":{"type":"string"},"type":"array"}]},"type":"object","title":"Metadata","description":"Metadata for the document. Keys must be strings. Values may be strings, numbers, booleans, or lists of strings. Numbers may be integers or floating point and will be converted to 64 bit floating point. 1000 total values are allowed. Each item in an array counts towards the total. The following keys are reserved for internal use: `document_id`, `document_type`, `document_source`, `document_name`, `document_uploaded_at`, `start_time`, `end_time`.","default":{}},"connection":{"oneOf":[{"$ref":"#/components/schemas/PublicBackblazeConnection"},{"$ref":"#/components/schemas/PublicGCSConnection"},{"$ref":"#/components/schemas/PublicFreshdeskConnection"},{"$ref":"#/components/schemas/PublicIntercomConnection"},{"$ref":"#/components/schemas/PublicS3CompatibleConnection"},{"$ref":"#/components/schemas/PublicZendeskConnection"}],"title":"Connection","discriminator":{"propertyName":"provider","mapping":{"backblaze":"#/components/schemas/PublicBackblazeConnection","freshdesk":"#/components/schemas/PublicFreshdeskConnection","gcs":"#/components/schemas/PublicGCSConnection","intercom":"#/components/schemas/PublicIntercomConnection","s3":"#/components/schemas/PublicS3CompatibleConnection","zendesk":"#/components/schemas/PublicZendeskConnection"}}}},"type":"object","required":["partition_strategy","connection"],"title":"PublicCreateConnection"},"PublicFreshdeskConnection":{"properties":{"provider":{"type":"string","const":"freshdesk","title":"Provider"},"data":{"$ref":"#/components/schemas/FreshdeskData"},"user_email":{"type":"string","title":"User Email","description":"The email the API key is associated with"},"credentials":{"$ref":"#/components/schemas/FreshdeskCredentials"}},"type":"object","required":["provider","data","user_email","credentials"],"title":"PublicFreshdeskConnection"},"PublicGCSConnection":{"properties":{"provider":{"type":"string","const":"gcs","title":"Provider"},"data":{"$ref":"#/components/schemas/BucketData"},"credentials":{"additionalProperties":true,"type":"object","title":"Credentials"}},"type":"object","required":["provider","data","credentials"],"title":"PublicGCSConnection"},"PublicIntercomConnection":{"properties":{"provider":{"type":"string","const":"intercom","title":"Provider"},"data":{"$ref":"#/components/schemas/IntercomData"},"credentials":{"$ref":"#/components/schemas/IntercomCredentials"}},"type":"object","required":["provider","data","credentials"],"title":"PublicIntercomConnection"},"PublicS3CompatibleConnection":{"properties":{"provider":{"type":"string","const":"s3","title":"Provider"},"data":{"$ref":"#/components/schemas/BucketData"},"credentials":{"$ref":"#/components/schemas/S3CompatibleCredentials"}},"type":"object","required":["provider","data","credentials"],"title":"PublicS3CompatibleConnection"},"PublicZendeskConnection":{"properties":{"provider":{"type":"string","const":"zendesk","title":"Provider"},"data":{"$ref":"#/components/schemas/ZendeskData"},"credentials":{"$ref":"#/components/schemas/ZendeskCredentials"}},"type":"object","required":["provider","data","credentials"],"title":"PublicZendeskConnection"},"QueryDetails":{"properties":{"query":{"type":"string","title":"Query"},"search_effort":{"$ref":"#/components/schemas/SearchEffort"},"metadata_filter":{"additionalProperties":true,"type":"object","title":"Metadata Filter"},"search_results":{"items":{"$ref":"#/components/schemas/RagieEvidence"},"type":"array","title":"Search Results"}},"type":"object","required":["query","search_effort","metadata_filter","search_results"],"title":"QueryDetails"},"RagieEvidence":{"properties":{"type":{"type":"string","const":"ragie","title":"Type","default":"ragie"},"text":{"type":"string","title":"Text"},"id":{"type":"string","title":"Id","description":"The chunk id of the evidence."},"index":{"type":"integer","title":"Index","description":"The index of the chunk in the document."},"document_id":{"type":"string","title":"Document Id","description":"The document id of the document containing the chunk being used as evidence."},"document_name":{"type":"string","title":"Document Name","description":"The name of the document that contains the chunk being used as evidence."},"metadata":{"additionalProperties":true,"type":"object","title":"Metadata","description":"The metadata of the chunk being used as evidence."},"document_metadata":{"additionalProperties":true,"type":"object","title":"Document Metadata","description":"The metadata of the document that contains the evidence."},"links":{"additionalProperties":{"$ref":"#/components/schemas/SearchResultLink"},"type":"object","title":"Links","description":"The links to the evidence."}},"type":"object","required":["text","id","index","document_id","document_name"],"title":"RagieEvidence"},"Reasoning":{"properties":{"effort":{"type":"string","enum":["low","medium","high"],"title":"Effort"},"summary":{"type":"null","title":"Summary"}},"type":"object","required":["effort"],"title":"Reasoning"},"ReasoningOutput":{"properties":{"id":{"type":"string","title":"Id","description":"The unique ID of the reasoning output."},"summary":{"items":{"$ref":"#/components/schemas/ReasoningSummary"},"type":"array","title":"Summary","description":"The summary of the reasoning."},"type":{"type":"string","const":"reasoning","title":"Type","default":"reasoning"},"content":{"items":{"$ref":"#/components/schemas/ReasoningText"},"type":"array","title":"Content","description":"The content of the reasoning."},"encrypted_content":{"type":"string","title":"Encrypted Content","description":"The encrypted content of the reasoning output."},"status":{"type":"string","enum":["in_progress","completed","incomplete"],"title":"Status","default":"completed"}},"type":"object","required":["id","summary","content","encrypted_content"],"title":"ReasoningOutput"},"ReasoningSummary":{"properties":{"summary":{"type":"string","title":"Summary","description":"The summary of the reasoning."},"type":{"type":"string","const":"summary","title":"Type","default":"summary"}},"type":"object","required":["summary"],"title":"ReasoningSummary"},"ReasoningText":{"properties":{"text":{"type":"string","title":"Text","description":"The text of the reasoning."},"type":{"type":"string","const":"reasoning_text","title":"Type","default":"reasoning_text"}},"type":"object","required":["text"],"title":"ReasoningText"},"Request":{"properties":{"input":{"type":"string","title":"Input","description":"The text used to generate the response. Generally a question or a query."},"instructions":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Instructions","description":"The instructions inserted in the prompt. For this agent, the instructions are injected during search related steps."},"tools":{"items":{"$ref":"#/components/schemas/Tool"},"type":"array","title":"Tools","description":"The tools available to the agent. Currently the only tool is retrieve. The `default` partition is used by default unless an other partition is specified.","default":[{"type":"retrieve","partitions":["default"]}]},"model":{"type":"string","const":"deep-search","title":"Model","description":"The model to use for the agent. Currently the only model is deep-search.","default":"deep-search"},"reasoning":{"$ref":"#/components/schemas/Reasoning","description":"The reasoning to use for the agent. The default effort level is medium.","default":{"effort":"medium"}},"stream":{"type":"boolean","title":"Stream","description":"Whether to stream the response","default":false}},"type":"object","required":["input"],"title":"Request"},"Response":{"properties":{"id":{"type":"string","title":"Id"},"object":{"type":"string","const":"response","title":"Object","default":"response"},"created_at":{"type":"integer","title":"Created At"},"status":{"type":"string","enum":["completed","failed","in_progress","cancelled"],"title":"Status"},"error":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Error"},"incomplete_details":{"type":"null","title":"Incomplete Details"},"instructions":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Instructions"},"max_output_tokens":{"type":"null","title":"Max Output Tokens"},"model":{"type":"string","const":"deep-search","title":"Model","default":"deep-search"},"output":{"items":{"anyOf":[{"$ref":"#/components/schemas/ResponseOutputMessage"},{"$ref":"#/components/schemas/ReasoningOutput"},{"$ref":"#/components/schemas/CodeInterpreterOutput"},{"$ref":"#/components/schemas/FileSearchOutput"}]},"type":"array","title":"Output"},"output_parsed":{"anyOf":[{"$ref":"#/components/schemas/FinalAnswer"},{"type":"null"}]},"tools":{"items":{"$ref":"#/components/schemas/Tool"},"type":"array","title":"Tools"},"reasoning":{"$ref":"#/components/schemas/Reasoning"},"parallel_tool_calls":{"type":"boolean","title":"Parallel Tool Calls","default":false},"store":{"type":"boolean","title":"Store","default":false},"temperature":{"type":"number","title":"Temperature","default":1.0},"previous_response_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Previous Response Id"},"tool_choice":{"type":"string","const":"auto","title":"Tool Choice","default":"auto"},"top_p":{"type":"number","title":"Top P","default":1.0},"truncation":{"type":"string","const":"disabled","title":"Truncation","default":"disabled"},"usage":{"$ref":"#/components/schemas/ragie__api__schema__response__Usage"},"user":{"type":"null","title":"User"},"metadata":{"additionalProperties":true,"type":"object","title":"Metadata","default":{}}},"type":"object","required":["id","created_at","status","output","tools","reasoning","usage"],"title":"Response"},"ResponseContent":{"properties":{"type":{"type":"string","const":"text","title":"Type","default":"text"},"text":{"type":"string","title":"Text"},"annotations":{"items":{"additionalProperties":true,"type":"object"},"type":"array","title":"Annotations","default":[]}},"type":"object","required":["text"],"title":"ResponseContent"},"ResponseOK":{"properties":{"message":{"type":"string","title":"Message","default":"ok"}},"type":"object","title":"ResponseOK"},"ResponseOutputMessage":{"properties":{"type":{"type":"string","const":"message","title":"Type","default":"message"},"id":{"type":"string","title":"Id"},"role":{"type":"string","const":"assistant","title":"Role","default":"assistant"},"content":{"items":{"$ref":"#/components/schemas/ResponseContent"},"type":"array","title":"Content"}},"type":"object","required":["id","content"],"title":"ResponseOutputMessage"},"Retrieval":{"properties":{"scored_chunks":{"items":{"$ref":"#/components/schemas/ScoredChunk"},"type":"array","title":"Scored Chunks"}},"type":"object","required":["scored_chunks"],"title":"Retrieval"},"RetrieveParams":{"properties":{"query":{"type":"string","title":"Query","description":"The query to search with when retrieving document chunks.","examples":["What is the best pizza place in SF?"]},"top_k":{"type":"integer","title":"Top K","description":"The maximum number of chunks to return. Defaults to 8.","default":8,"examples":[8]},"filter":{"$ref":"#/components/schemas/MetadataFilter","title":"Filter","description":"The metadata search filter on documents. Returns chunks only from documents which match the filter. The following filter operators are supported: $eq - Equal to (number, string, boolean), $ne - Not equal to (number, string, boolean), $gt - Greater than (number), $gte - Greater than or equal to (number), $lt - Less than (number), $lte - Less than or equal to (number), $in - In array (string or number), $nin - Not in array (string or number). The operators can be combined with AND and OR. Read [Metadata & Filters guide](https://docs.ragie.ai/docs/metadata-filters) for more details and examples.","examples":[{"department":{"$in":["sales","marketing"]}}]},"rerank":{"type":"boolean","title":"Rerank","description":"Reranks the chunks for semantic relevancy post cosine similarity. Will be slower but returns a subset of highly relevant chunks. Best for reducing hallucinations and improving accuracy for LLM generation.","default":false,"examples":[true]},"max_chunks_per_document":{"type":"integer","title":"Max Chunks Per Document","description":"Maximum number of chunks to retrieve per document. Use this to increase the number of documents the final chunks are retrieved from. This feature is in beta and may change in the future.","examples":[0]},"partition":{"type":"string","title":"Partition","description":"The partition to scope a retrieval to. If omitted, the retrieval will be scoped to the default partition, which includes any documents that have not been created in a partition.","examples":[null]},"recency_bias":{"type":"boolean","title":"Recency Bias","description":"Enables recency bias which will favor more recent documents vs older documents. https://docs.ragie.ai/docs/retrievals-recency-bias","default":false,"examples":[false]}},"type":"object","required":["query"],"title":"RetrieveParams"},"S3CompatibleCredentials":{"properties":{"access_key_id":{"type":"string","title":"Access Key Id"},"secret_access_key":{"type":"string","title":"Secret Access Key"},"region":{"type":"string","title":"Region"},"endpoint":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Endpoint"}},"type":"object","required":["access_key_id","secret_access_key","region"],"title":"S3CompatibleCredentials"},"ScoredChunk":{"properties":{"text":{"type":"string","title":"Text"},"score":{"type":"number","title":"Score"},"id":{"type":"string","title":"Id"},"index":{"type":"integer","title":"Index"},"metadata":{"$ref":"#/components/schemas/ChunkMetadata","default":{}},"document_id":{"type":"string","title":"Document Id"},"document_name":{"type":"string","title":"Document Name"},"document_metadata":{"$ref":"#/components/schemas/DocumentMetadata"},"links":{"additionalProperties":{"$ref":"#/components/schemas/Link"},"type":"object","title":"Links"}},"type":"object","required":["text","score","id","index","document_id","document_name","document_metadata","links"],"title":"ScoredChunk"},"Search":{"properties":{"search_requests":{"items":{"type":"string"},"type":"array","title":"Search Requests"}},"type":"object","required":["search_requests"],"title":"Search"},"SearchEffort":{"type":"string","enum":["low","medium","high"],"title":"SearchEffort"},"SearchResultLink":{"properties":{"href":{"type":"string","title":"Href"},"type":{"type":"string","title":"Type"}},"type":"object","required":["href","type"],"title":"SearchResultLink"},"SearchStep":{"properties":{"type":{"type":"string","const":"base_search","title":"Type","default":"base_search"},"think":{"type":"string","title":"Think"},"current_question":{"type":"string","title":"Current Question"},"errored":{"type":"boolean","title":"Errored","default":false},"search":{"$ref":"#/components/schemas/Search","description":"The search request to be made."}},"type":"object","required":["think","current_question","search"],"title":"SearchStep"},"SearchStepWithQueryDetails":{"properties":{"type":{"type":"string","const":"search","title":"Type","default":"search"},"think":{"type":"string","title":"Think"},"current_question":{"type":"string","title":"Current Question"},"errored":{"type":"boolean","title":"Errored","default":false},"search":{"$ref":"#/components/schemas/Search","description":"The search request to be made."},"query_details":{"items":{"$ref":"#/components/schemas/QueryDetails"},"type":"array","title":"Query Details"},"search_log":{"type":"string","title":"Search Log","description":"A log of the search results you found.","default":""}},"type":"object","required":["think","current_question","search"],"title":"SearchStepWithQueryDetails"},"SetConnectionEnabledPayload":{"properties":{"enabled":{"type":"boolean","title":"Enabled"},"reason":{"anyOf":[{"type":"string","enum":["connection_over_total_page_limit","authentication_failed"]},{"type":"null"}],"title":"Reason"}},"type":"object","required":["enabled"],"title":"SetConnectionEnabledPayload"},"SharepointData":{"properties":{"site":{"$ref":"#/components/schemas/SharepointSiteData"},"drive":{"anyOf":[{"$ref":"#/components/schemas/SharepointDriveData"},{"type":"null"}]},"files":{"items":{"$ref":"#/components/schemas/SharepointFileData"},"type":"array","title":"Files"}},"type":"object","required":["site","drive","files"],"title":"SharepointData"},"SharepointDriveData":{"properties":{"id":{"type":"string","title":"Id"},"name":{"type":"string","title":"Name"}},"type":"object","required":["id","name"],"title":"SharepointDriveData"},"SharepointFileData":{"properties":{"id":{"type":"string","title":"Id"},"name":{"type":"string","title":"Name"},"type":{"type":"string","enum":["file","folder"],"title":"Type"},"drive_id":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Drive Id"}},"type":"object","required":["id","name","type","drive_id"],"title":"SharepointFileData"},"SharepointSiteData":{"properties":{"id":{"type":"string","title":"Id"},"name":{"type":"string","title":"Name"}},"type":"object","required":["id","name"],"title":"SharepointSiteData"},"SlackData":{"properties":{"channel_id":{"type":"string","title":"Channel Id"},"channel_name":{"type":"string","title":"Channel Name"}},"type":"object","required":["channel_id","channel_name"],"title":"SlackData"},"SurrenderStep":{"properties":{"type":{"type":"string","const":"surrender","title":"Type","default":"surrender"},"think":{"type":"string","title":"Think"},"current_question":{"type":"string","title":"Current Question"},"errored":{"type":"boolean","title":"Errored","default":false},"partial_answer":{"$ref":"#/components/schemas/Answer","description":"The a potential partial answer when a full answer was not possible."}},"type":"object","required":["think","current_question","partial_answer"],"title":"SurrenderStep"},"Tool":{"properties":{"type":{"type":"string","const":"retrieve","title":"Type"},"partitions":{"items":{"type":"string"},"type":"array","title":"Partitions"}},"type":"object","required":["type","partitions"],"title":"Tool"},"UpdateDocumentFromUrlParams":{"properties":{"mode":{"anyOf":[{"type":"string","enum":["hi_res","fast"]},{"$ref":"#/components/schemas/MediaModeParam"}],"title":"Mode","description":"Partition strategy for the document. Different strategies exist for textual, audio and video file types and you can set the strategy you want for  each file type, or just for textual types.  For textual documents the options are `'hi_res'` or `'fast'`. When set to `'hi_res'`, images and tables will be extracted from the document. `'fast'` will only extract text. `'fast'` may be up to 20x faster than `'hi_res'`. `hi_res` is only applicable for Word documents, PDFs, Images, and PowerPoints. Images will always be processed in `hi_res`. If `hi_res` is set for an unsupported document type, it will be processed and billed in `fast` mode.  For audio files, the options are true or false. True if you want to process audio, false otherwise.          For video files, the options are `'audio_only'`, `'video_only'`, `'audio_video'`. `'audio_only'` will extract just the audio part of the video. `'video_only'` will similarly just extract the video part, ignoring audio. `'audio_video'` will extract both audio and video.  To process all media types at the highest quality, use `'all'`.  When you specify audio or video stategies, the format must be a JSON object. In this case, textual documents are denoted by the key \"static\". If you omit a key, that document type won't be processd.  See examples below.  Examples  Textual documents only     \"fast\"  Video documents only {     \"video\": \"audio_video\" }  Specify multiple document types {     \"static\": \"hi_res\",     \"audio\": true,     \"video\": \"video_only\" }  Specify only textual or audio document types {     \"static\": \"fast\",     \"audio\": true }  Highest quality processing for all media types     \"all\"","default":"fast"},"url":{"type":"string","title":"Url","description":"Url of the file to download. Must be publicly accessible and HTTP or HTTPS scheme."}},"type":"object","required":["url"],"title":"UpdateDocumentFromUrlParams"},"UpdateDocumentRawParams":{"properties":{"data":{"anyOf":[{"type":"string"},{"additionalProperties":true,"type":"object"}],"minLength":1,"title":"Data","description":"Document data in a text or JSON format."}},"type":"object","required":["data"],"title":"UpdateDocumentRawParams"},"UpdateInstructionParams":{"properties":{"active":{"type":"boolean","title":"Active","description":"Whether the instruction is active. Active instructions are applied to documents when they're created or when their file is updated.","examples":[true]}},"type":"object","required":["active"],"title":"UpdateInstructionParams"},"UpdatePartitionParams":{"properties":{"context_aware":{"anyOf":[{"type":"boolean"},{"type":"null"}],"title":"Context Aware","description":"Enable context-aware descriptions for the partition."},"description":{"anyOf":[{"type":"string"},{"type":"null"}],"title":"Description","description":"Description of the partition."},"metadata_schema":{"anyOf":[{"additionalProperties":{"anyOf":[{"type":"string"},{"type":"integer"},{"type":"boolean"},{"items":{"type":"string"},"type":"array"},{"additionalProperties":true,"type":"object"}]},"type":"object"},{"type":"null"}],"title":"Metadata Schema","description":"Metadata schema for the partition. This is an optional subset of the metadata of documents in the partition, defined as JSON Schema, that can be used in filter generatation. Providing detailed descriptions of the fields in the schema can be helpful for LLMs generating filters dynamically."}},"type":"object","title":"UpdatePartitionParams"},"ValidationError":{"properties":{"loc":{"items":{"anyOf":[{"type":"string"},{"type":"integer"}]},"type":"array","title":"Location"},"msg":{"type":"string","title":"Message"},"type":{"type":"string","title":"Error Type"}},"type":"object","required":["loc","msg","type"],"title":"ValidationError"},"VideoModalityData":{"properties":{"type":{"type":"string","const":"video","title":"Type","default":"video"},"word_timestamps":{"items":{"$ref":"#/components/schemas/WordTimestamp"},"type":"array","title":"Word Timestamps","default":[]}},"type":"object","title":"VideoModalityData"},"WordTimestamp":{"properties":{"start_time":{"type":"number","title":"Start Time"},"end_time":{"type":"number","title":"End Time"},"word":{"type":"string","title":"Word"},"probability":{"type":"number","title":"Probability"}},"type":"object","required":["start_time","end_time","word","probability"],"title":"WordTimestamp"},"ZendeskCredentials":{"properties":{"domain":{"type":"string","title":"Domain"},"email":{"type":"string","title":"Email"},"api_token":{"type":"string","title":"Api Token"}},"type":"object","required":["domain","email","api_token"],"title":"ZendeskCredentials"},"ZendeskData":{"properties":{"articles":{"type":"boolean","title":"Articles"}},"type":"object","required":["articles"],"title":"ZendeskData"},"agent_hopps__models__models__Usage":{"properties":{"models":{"items":{"$ref":"#/components/schemas/ModelUsage"},"type":"array","title":"Models"}},"type":"object","title":"Usage"},"ragie__api__schema__response__Usage":{"properties":{"input_tokens":{"type":"integer","title":"Input Tokens"},"input_token_details":{"$ref":"#/components/schemas/InputTokenDetails","default":{"cached_tokens":0}},"output_tokens":{"type":"integer","title":"Output Tokens"},"output_token_details":{"$ref":"#/components/schemas/OutputTokenDetails","default":{"reasoning_tokens":0}},"total_tokens":{"type":"integer","title":"Total Tokens"}},"type":"object","required":["input_tokens","output_tokens","total_tokens"],"title":"Usage"},"CreateDocumentParams":{"type":"object","title":"CreateDocumentParams","properties":{"mode":{"type":"object","title":"Mode","description":"Partition strategy for the document. Different strategies exist for textual, audio and video file types and you can set the strategy you want for  each file type, or just for textual types.  For textual documents the options are `'hi_res'` or `'fast'`. When set to `'hi_res'`, images and tables will be extracted from the document. `'fast'` will only extract text. `'fast'` may be up to 20x faster than `'hi_res'`. `hi_res` is only applicable for Word documents, PDFs, Images, and PowerPoints. Images will always be processed in `hi_res`. If `hi_res` is set for an unsupported document type, it will be processed and billed in `fast` mode.  For audio files, the options are true or false. True if you want to process audio, false otherwise.          For video files, the options are `'audio_only'`, `'video_only'`, `'audio_video'`. `'audio_only'` will extract just the audio part of the video. `'video_only'` will similarly just extract the video part, ignoring audio. `'audio_video'` will extract both audio and video.  To process all media types at the highest quality, use `'all'`.  When you specify audio or video stategies, the format must be a JSON object. In this case, textual documents are denoted by the key \"static\". If you omit a key, that document type won't be processd.  See examples below.  Examples  Textual documents only     \"fast\"  Video documents only {     \"video\": \"audio_video\" }  Specify multiple document types {     \"static\": \"hi_res\",     \"audio\": true,     \"video\": \"video_only\" }  Specify only textual or audio document types {     \"static\": \"fast\",     \"audio\": true }  Highest quality processing for all media types     \"all\"","default":"fast","oneOf":[{"type":"object","properties":{"static":{"oneOf":[{"type":"string","enum":["hi_res","fast"]},{"type":"null"}],"title":"Static"},"audio":{"oneOf":[{"type":"boolean"},{"type":"null"}],"title":"Audio"},"video":{"oneOf":[{"type":"string","enum":["audio_only","video_only","audio_video"]},{"type":"null"}],"title":"Video"}}},{"type":"string","enum":["hi_res","fast"]}]},"metadata":{"type":"object","title":"Metadata","description":"Metadata for the document. Keys must be strings. Values may be strings, numbers, booleans, or lists of strings. Numbers may be integers or floating point and will be converted to 64 bit floating point. 1000 total values are allowed. Each item in an array counts towards the total. The following keys are reserved for internal use: `document_id`, `document_type`, `document_source`, `document_name`, `document_uploaded_at`, `start_time`, `end_time`.","default":"{}","additionalProperties":{"oneOf":[{"type":"string"},{"type":"number"},{"type":"boolean"},{"type":"array","items":{"type":"string"}}]}},"file":{"type":"string","format":"binary","title":"File","description":"The binary file to upload, extract, and index for retrieval. The following file types are supported: Plain Text: `.eml` `.html` `.json` `.md` `.msg` `.rst` `.rtf` `.txt` `.xml`\nImages: `.png` `.webp` `.jpg` `.jpeg` `.tiff` `.bmp` `.heic`\nDocuments: `.csv` `.doc` `.docx` `.epub` `.epub+zip` `.odt` `.pdf` `.ppt` `.pptx` `.tsv` `.xlsx` `.xls`. PDF files over 2000 pages are not supported in hi_res mode."},"external_id":{"type":"string","title":"External Id","description":"An optional identifier for the document. A common value might be an id in an external system or the URL where the source file may be found."},"name":{"type":"string","title":"Name","description":"An optional name for the document. If set, the document will have this name. Otherwise it will default to the file's name."},"partition":{"type":"string","title":"Partition","description":"An optional partition identifier. Documents can be scoped to a partition. Partitions must be lowercase alphanumeric and may only include the special characters `_` and `-`.  A partition is created any time a document is created."}},"required":["file"]},"UpdateDocumentFileParams":{"type":"object","title":"UpdateDocumentFileParams","properties":{"mode":{"type":"object","title":"Mode","description":"Partition strategy for the document. Different strategies exist for textual, audio and video file types and you can set the strategy you want for  each file type, or just for textual types.  For textual documents the options are `'hi_res'` or `'fast'`. When set to `'hi_res'`, images and tables will be extracted from the document. `'fast'` will only extract text. `'fast'` may be up to 20x faster than `'hi_res'`. `hi_res` is only applicable for Word documents, PDFs, Images, and PowerPoints. Images will always be processed in `hi_res`. If `hi_res` is set for an unsupported document type, it will be processed and billed in `fast` mode.  For audio files, the options are true or false. True if you want to process audio, false otherwise.          For video files, the options are `'audio_only'`, `'video_only'`, `'audio_video'`. `'audio_only'` will extract just the audio part of the video. `'video_only'` will similarly just extract the video part, ignoring audio. `'audio_video'` will extract both audio and video.  To process all media types at the highest quality, use `'all'`.  When you specify audio or video stategies, the format must be a JSON object. In this case, textual documents are denoted by the key \"static\". If you omit a key, that document type won't be processd.  See examples below.  Examples  Textual documents only     \"fast\"  Video documents only {     \"video\": \"audio_video\" }  Specify multiple document types {     \"static\": \"hi_res\",     \"audio\": true,     \"video\": \"video_only\" }  Specify only textual or audio document types {     \"static\": \"fast\",     \"audio\": true }  Highest quality processing for all media types     \"all\"","default":"fast","oneOf":[{"type":"object","properties":{"static":{"oneOf":[{"type":"string","enum":["hi_res","fast"]},{"type":"null"}],"title":"Static"},"audio":{"oneOf":[{"type":"boolean"},{"type":"null"}],"title":"Audio"},"video":{"oneOf":[{"type":"string","enum":["audio_only","video_only","audio_video"]},{"type":"null"}],"title":"Video"}}},{"type":"string","enum":["hi_res","fast"]}]},"file":{"type":"string","format":"binary","title":"File","description":"The binary file to upload, extract, and index for retrieval. The following file types are supported: Plain Text: `.eml` `.html` `.json` `.md` `.msg` `.rst` `.rtf` `.txt` `.xml`\nImages: `.png` `.webp` `.jpg` `.jpeg` `.tiff` `.bmp` `.heic`\nDocuments: `.csv` `.doc` `.docx` `.epub` `.epub+zip` `.odt` `.pdf` `.ppt` `.pptx` `.tsv` `.xlsx` `.xls`. PDF files over 2000 pages are not supported in hi_res mode."}},"required":["file"]}},"securitySchemes":{"auth":{"type":"http","scheme":"bearer"}}},"security":[{"auth":[]}]}

... (Data file content truncated to first 5 lines)
</document_content>
</document>

<document index="23">
<source>openapi.sha256</source>
<document_content>
5884ba5e907be9da40af93d61e7f079b1c3585cf6866291cdbc849e99c322873
</document_content>
</document>

<document index="24">
<source>openapitools.json</source>
<document_content>
{
  "$schema": "./node_modules/@openapitools/openapi-generator-cli/config.schema.json",
  "spaces": 2,
  "generator-cli": {
    "version": "7.14.0"

... (Data file content truncated to first 5 lines)
</document_content>
</document>

<document index="25">
<source>phpstan-baseline.neon</source>
<document_content>
# this_file: phpstan-baseline.neon
parameters:
  ignoreErrors: []
</document_content>
</document>

<document index="26">
<source>phpstan.neon.dist</source>
<document_content>
# this_file: phpstan.neon.dist
includes:
  - phpstan-baseline.neon

parameters:
  level: 6
  paths:
    - src
    - tests
  excludePaths:
    - src/Ragie/Api/lib
    - src/Ragie/Api/docs
    - src/Ragie/Api/test
  ignoreErrors: []
</document_content>
</document>

<document index="27">
<source>phpunit.xml.dist</source>
<document_content>
<?xml version="1.0" encoding="UTF-8"?>
<!-- this_file: phpunit.xml.dist -->
<phpunit
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="https://schema.phpunit.de/10.5/phpunit.xsd"
    bootstrap="./vendor/autoload.php"
    colors="true"
    stopOnFailure="false"
    cacheDirectory="./.phpunit.cache"
>
    <testsuites>
        <testsuite name="unit">
            <directory>./tests/unit</directory>
        </testsuite>
        <testsuite name="integration">
            <directory>./tests/Integration</directory>
        </testsuite>
    </testsuites>
    <source>
        <include>
            <directory suffix=".php">./src</directory>
        </include>
        <exclude>
            <directory suffix=".php">./src/Ragie/Api/lib</directory>
        </exclude>
    </source>
    <php>
        <ini name="error_reporting" value="E_ALL"/>
    </php>
</phpunit>
</document_content>
</document>

<document index="28">
<source>psalm.xml</source>
<document_content>
<?xml version="1.0" encoding="UTF-8"?>
<!-- this_file: psalm.xml -->
<psalm
    errorLevel="4"
    phpVersion="8.1"
    findUnusedPsalmSuppress="true"
>
    <projectFiles>
        <directory name="src"/>
        <directory name="tests"/>
        <ignoreFiles>
            <directory name="vendor"/>
            <directory name="src/Ragie/Api/lib"/>
            <directory name="src/Ragie/Api/docs"/>
            <directory name="src/Ragie/Api/test"/>
        </ignoreFiles>
    </projectFiles>
    <issueHandlers>
        <UnusedClass>
            <errorLevel type="suppress">
                <directory name="tests"/>
            </errorLevel>
        </UnusedClass>
    </issueHandlers>
</psalm>
</document_content>
</document>

<document index="29">
<source>src/Benchmark/TimingSummary.php</source>
<document_content>
<?php

// this_file: src/Benchmark/TimingSummary.php

declare(strict_types=1);

namespace Ragie\Benchmark;

use InvalidArgumentException;

/**
 * Aggregates retrieval benchmark timings into helpful summary statistics.
 *
 * The summary is deterministic because timings are sorted on construction and
 * percentile calculations use linear interpolation between ranks.
 */
final class TimingSummary
{
    /**
     * @param list<float> $timings Sorted list of timings (milliseconds)
     */
    private function __construct(
        private readonly array $timings,
        private readonly float $averageMs,
        private readonly float $minMs,
        private readonly float $maxMs,
    ) {
    }

    /**
     * @param array<float|int> $timings Timings in milliseconds
     */
    public static function fromTimings(array $timings): self
    {
        if ($timings === []) {
            throw new InvalidArgumentException('At least one timing is required');
        }

        $normalized = [];

        foreach ($timings as $timing) {
            if (!is_numeric($timing)) {
                throw new InvalidArgumentException('Timings must be numeric values in milliseconds');
            }

            $value = (float) $timing;

            if ($value < 0) {
                throw new InvalidArgumentException('Timings cannot be negative');
            }

            $normalized[] = $value;
        }

        sort($normalized);

        $count = count($normalized);
        $sum = array_sum($normalized);

        return new self(
            $normalized,
            $sum / (float) $count,
            $normalized[0],
            $normalized[$count - 1],
        );
    }

    public function getAverageMs(): float
    {
        return $this->averageMs;
    }

    public function getMinMs(): float
    {
        return $this->minMs;
    }

    public function getMaxMs(): float
    {
        return $this->maxMs;
    }

    public function getCount(): int
    {
        return count($this->timings);
    }

    /**
     * Returns the interpolated percentile in milliseconds.
     */
    public function getPercentileMs(float $percentile): float
    {
        if ($percentile <= 0 || $percentile > 100) {
            throw new InvalidArgumentException('Percentile must be between 0 and 100');
        }

        $count = count($this->timings);

        if ($count === 1) {
            return $this->timings[0];
        }

        $position = ($percentile / 100.0) * ((float) ($count - 1));
        $lowerIndex = (int) floor($position);
        $upperIndex = (int) ceil($position);

        if ($lowerIndex === $upperIndex) {
            return $this->timings[$lowerIndex];
        }

        $lowerValue = $this->timings[$lowerIndex];
        $upperValue = $this->timings[$upperIndex];
        $fraction = $position - (float) $lowerIndex;

        return $lowerValue + (($upperValue - $lowerValue) * $fraction);
    }

    /**
     * Export summary data for downstream reporting.
     *
     * @return array{
     *     count: int,
     *     average_ms: float,
     *     min_ms: float,
     *     max_ms: float,
     *     p50_ms: float,
     *     p95_ms: float,
     *     p99_ms: float
     * }
     */
    public function toArray(): array
    {
        return [
            'count' => $this->getCount(),
            'average_ms' => $this->getAverageMs(),
            'min_ms' => $this->getMinMs(),
            'max_ms' => $this->getMaxMs(),
            'p50_ms' => $this->getPercentileMs(50),
            'p95_ms' => $this->getPercentileMs(95),
            'p99_ms' => $this->getPercentileMs(99),
        ];
    }
}
</document_content>
</document>

<document index="30">
<source>src/Cache/InMemoryCache.php</source>
<document_content>
<?php

// this_file: src/Cache/InMemoryCache.php

declare(strict_types=1);

namespace Ragie\Cache;

use Closure;
use Ragie\RetrievalResult;

/**
 * Lightweight per-request cache for retrieval responses.
 */
final class InMemoryCache implements QueryCacheInterface
{
    /** @var array<string, RetrievalResult> */
    private array $cache = [];

    /** @var array<string, int> */
    private array $expiry = [];

    private Closure $clock;

    /**
     * @param callable():int|null $clock Allows deterministic time control during testing
     */
    public function __construct(?callable $clock = null)
    {
        $this->clock = $clock !== null
            ? Closure::fromCallable($clock)
            : static fn (): int => time();
    }

    #[\Override]
    public function get(string $key): ?RetrievalResult
    {
        if (!$this->has($key)) {
            return null;
        }

        return $this->cache[$key];
    }

    #[\Override]
    public function set(string $key, RetrievalResult $result, int $ttl): void
    {
        if ($ttl <= 0) {
            unset($this->cache[$key], $this->expiry[$key]);
            return;
        }

        $this->cache[$key] = $result;
        $this->expiry[$key] = $this->now() + $ttl;
    }

    #[\Override]
    public function has(string $key): bool
    {
        if (!isset($this->cache[$key])) {
            return false;
        }

        $expiry = $this->expiry[$key] ?? 0;

        if ($expiry <= $this->now()) {
            unset($this->cache[$key], $this->expiry[$key]);
            return false;
        }

        return true;
    }

    #[\Override]
    public function clear(): void
    {
        $this->cache = [];
        $this->expiry = [];
    }

    private function now(): int
    {
        return (int) ($this->clock)();
    }
}
</document_content>
</document>

<document index="31">
<source>src/Cache/QueryCacheInterface.php</source>
<document_content>
<?php

// this_file: src/Cache/QueryCacheInterface.php

declare(strict_types=1);

namespace Ragie\Cache;

use Ragie\RetrievalResult;

/**
 * Interface for opt-in retrieval result caching.
 */
interface QueryCacheInterface
{
    /**
     * Fetch a cached retrieval result if present and not expired.
     */
    public function get(string $key): ?RetrievalResult;

    /**
     * Persist a retrieval result for the specified TTL (seconds).
     */
    public function set(string $key, RetrievalResult $result, int $ttl): void;

    /**
     * Determine whether a cache entry exists and is still valid.
     */
    public function has(string $key): bool;

    /**
     * Remove all cached entries.
     */
    public function clear(): void;
}
</document_content>
</document>

<document index="32">
<source>src/Cache/SimpleCacheQueryCache.php</source>
<document_content>
<?php

// this_file: src/Cache/SimpleCacheQueryCache.php

declare(strict_types=1);

namespace Ragie\Cache;

use Psr\SimpleCache\CacheInterface;
use Ragie\RetrievalResult;

/**
 * Adapter that allows any PSR-16 cache to back query caching.
 */
final class SimpleCacheQueryCache implements QueryCacheInterface
{
    public function __construct(
        private readonly CacheInterface $cache
    ) {
    }

    #[\Override]
    public function get(string $key): ?RetrievalResult
    {
        $value = $this->cache->get($key);

        return $value instanceof RetrievalResult ? $value : null;
    }

    #[\Override]
    public function set(string $key, RetrievalResult $result, int $ttl): void
    {
        $this->cache->set($key, $result, $ttl);
    }

    #[\Override]
    public function has(string $key): bool
    {
        return $this->cache->has($key);
    }

    #[\Override]
    public function clear(): void
    {
        $this->cache->clear();
    }
}
</document_content>
</document>

<document index="33">
<source>src/Client.php</source>
<document_content>
<?php

// this_file: src/Client.php

declare(strict_types=1);

namespace Ragie;

use GuzzleHttp\Client as GuzzleClient;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Promise\Create;
use GuzzleHttp\Promise\PromiseInterface;
use GuzzleHttp\Promise\Utils;
use JsonException;
use Psr\Log\LoggerInterface;
use Ragie\Api\Api\DocumentsApi;
use Ragie\Api\Api\RetrievalsApi;
use Ragie\Api\Api\ResponsesApi;
use Ragie\Api\Configuration;
use Ragie\Cache\QueryCacheInterface;
use Ragie\Exception\InvalidQueryException;
use Ragie\Logging\StructuredLogger;
use Ragie\Metrics\CostTracker;
use Ragie\Metrics\MetricsCollector;
use Ragie\Validation\InputSanitizer;

/**
 * Ragie PHP Client
 *
 * High-level convenience client for common RAG (Retrieval-Augmented Generation) operations.
 * Wraps the auto-generated Ragie API client and provides simplified methods for retrieval tasks.
 *
 * Note: This class is not designed to be extended. Use composition instead of inheritance.
 *
 * @example
 * ```php
 * use Ragie\Client;
 *
 * // Initialize client
 * $ragie = new Client('your-api-key');
 *
 * // Simple retrieval
 * $result = $ragie->retrieve('What is RAG?');
 * foreach ($result->getChunks() as $chunk) {
 *     echo $chunk->getText() . "\n";
 * }
 *
 * // Fluent configuration with defaults
 * $ragie = (new Client('your-api-key'))
 *     ->withDefaultTopK(20)
 *     ->withDefaultRerank();
 *
 * // Enable debug mode
 * $ragie = (new Client('your-api-key'))
 *     ->enableDebug();
 *
 * // Batch retrieval
 * $results = $ragie->retrieveBatch([
 *     'What is machine learning?',
 *     'Explain neural networks'
 * ]);
 *
 * // Access underlying API for document management
 * $documents = $ragie->getDocumentsApi()->listDocuments();
 * ```
 *
 * @package Ragie
 */
class Client
{
    private const MAX_QUERY_LENGTH = 10000;
    private const DEFAULT_CACHE_TTL = 300;

    private Configuration $configuration;
    private ClientInterface $httpClient;

    private ?RetrievalsApi $retrievalsApi = null;
    private ?ResponsesApi $responsesApi = null;
    private ?DocumentsApi $documentsApi = null;

    // Fluent configuration defaults
    private ?int $defaultTopK = null;
    private ?bool $defaultRerank = null;
    private ?\Ragie\Retry\RetryPolicy $retryPolicy = null;
    private ?QueryCacheInterface $cache = null;
    private int $cacheTtlSeconds = self::DEFAULT_CACHE_TTL;
    private bool $debug = false;
    private ?MetricsCollector $metricsCollector = null;
    private ?CostTracker $costTracker = null;
    private ?StructuredLogger $structuredLogger = null;

    /**
     * Create a new Ragie client instance
     *
     * @param string $apiKey The Ragie API key for authentication
     * @param string|null $baseUrl Optional base URL override (defaults to https://api.ragie.ai)
     * @param ClientInterface|null $httpClient Optional custom HTTP client (defaults to Guzzle)
     *
     * @throws InvalidQueryException If API key is empty
     */
    public function __construct(
        string $apiKey,
        ?string $baseUrl = null,
        ?ClientInterface $httpClient = null
    ) {
        $trimmed = trim($apiKey);
        if ($trimmed === '') {
            if ($apiKey === '') {
                throw InvalidQueryException::empty();
            }
            throw InvalidQueryException::whitespace();
        }

        $this->configuration = new Configuration();
        $this->configuration->setAccessToken($apiKey);

        if ($baseUrl !== null) {
            $this->configuration->setHost($baseUrl);
        }

        $this->httpClient = $httpClient ?? new GuzzleClient([
            'timeout' => 30,
            'connect_timeout' => 5,
            'headers' => [
                'Connection' => 'keep-alive',
                'Keep-Alive' => '300',
            ],
            'curl' => [
                CURLOPT_TCP_KEEPALIVE => 1,
                CURLOPT_TCP_KEEPIDLE => 120,
            ],
        ]);
    }

    /**
     * Retrieve relevant document chunks for a query
     *
     * This is the primary method for RAG retrieval operations. It finds and returns
     * the most relevant document chunks based on the provided query.
     *
     * @param string $query The search query
     * @param RetrievalOptions|null $options Optional retrieval parameters (filters, top_k, etc.)
     *
     *
     * @throws \Ragie\Api\ApiException If the API request fails
     * @throws InvalidQueryException If query is empty or whitespace
     * @return RetrievalResult The retrieval results with convenient accessors
     *
     * @example
     * ```php
     * // Basic retrieval
     * $result = $ragie->retrieve('What is machine learning?');
     *
     * // With options
     * $options = RetrievalOptions::create()
     *     ->withTopK(20)
     *     ->withRerank()
     *     ->withFilter(['category' => 'docs']);
     * $result = $ragie->retrieve('query', $options);
     * ```
     */
    public function retrieve(string $query, ?RetrievalOptions $options = null): RetrievalResult
    {
        $query = InputSanitizer::sanitizeAndValidate($query, self::MAX_QUERY_LENGTH);

        // Use default options if none provided, applying fluent defaults
        $options = $options ?? $this->createDefaultOptions();

        // Debug: Log query start
        $startTime = microtime(true);
        $debugStartTime = $this->debug ? $startTime : null;
        if ($this->debug && $debugStartTime !== null) {
            error_log("[Ragie Debug] Query: {$query}");
        }

        // Debug: Log options
        if ($this->debug) {
            error_log('[Ragie Debug] Options: ' . json_encode($options->toRetrieveParams($query)));
        }

        $this->structuredLogger?->logRetrievalStart('ragie', $query);

        // Convert to API params
        $retrieveParams = $options->toRetrieveParams($query);

        $cacheKey = null;
        $chunkCount = 0;
        $success = false;
        $costIncurred = false;
        $result = null;
        $cacheHit = false;
        $durationMs = 0;

        try {
            if ($this->cache !== null) {
                $cacheKey = $this->buildCacheKey($retrieveParams);
                if ($this->cache->has($cacheKey)) {
                    $cached = $this->cache->get($cacheKey);
                    if ($cached !== null) {
                        $result = $cached;
                        $cacheHit = true;
                    }
                }
            }

            // Execute with retry policy if configured
            $executeRetrieval = function () use ($retrieveParams): \Ragie\Api\Model\Retrieval {
                $retrieval = $this->getRetrievalsApi()->retrieve($retrieveParams);

                // In practice, errors throw ApiException, so this should always be Retrieval
                if (!$retrieval instanceof \Ragie\Api\Model\Retrieval) {
                    throw new \RuntimeException('Unexpected response type from retrieve API');
                }

                return $retrieval;
            };

            if ($result === null) {
                $retrieval = $this->retryPolicy !== null
                    ? $this->retryPolicy->execute($executeRetrieval)
                    : $executeRetrieval();

                // Wrap in convenience result object
                $result = new RetrievalResult($retrieval);
                $costIncurred = true;

                if ($cacheKey !== null && $this->cache !== null) {
                    $this->cache->set($cacheKey, $result, $this->cacheTtlSeconds);
                }
            }

            $chunkCount = count($result->getChunks());
            $success = true;

            if ($this->debug && $debugStartTime !== null) {
                $durationMs = $this->elapsedMs($debugStartTime);
                error_log(sprintf('[Ragie Debug] Duration: %dms', $durationMs));
                error_log('[Ragie Debug] Chunks returned: ' . $chunkCount);
            }

            $durationMs = $durationMs > 0 ? $durationMs : $this->elapsedMs($startTime);
            $this->structuredLogger?->logRetrievalSuccess('ragie', $query, $durationMs, $chunkCount, $cacheHit);

            return $result;
        } catch (\Throwable $e) {
            $durationMs = $durationMs > 0 ? $durationMs : $this->elapsedMs($startTime);
            $this->structuredLogger?->logRetrievalFailure('ragie', $query, $e, $durationMs);
            throw $e;
        } finally {
            $finalDuration = $durationMs > 0 ? $durationMs : $this->elapsedMs($startTime);

            if ($this->metricsCollector !== null) {
                $this->metricsCollector->recordRetrieval('ragie', $finalDuration, $chunkCount, $success);
            }

            if ($costIncurred && $this->costTracker !== null) {
                $this->costTracker->recordRagieQuery();
            }
        }
    }

    /**
     * Retrieve relevant document chunks asynchronously.
     *
     * Provides a non-blocking variant of {@see retrieve()} that uses Guzzle promises.
     *
     * @param string $query             The search query
     * @param RetrievalOptions|null $options Optional retrieval parameters
     *
     * @throws InvalidQueryException If the query is empty or whitespace
     *
     * @return PromiseInterface Promise resolving to RetrievalResult
     */
    public function retrieveAsync(string $query, ?RetrievalOptions $options = null): PromiseInterface
    {
        $query = InputSanitizer::sanitizeAndValidate($query, self::MAX_QUERY_LENGTH);

        $options = $options ?? $this->createDefaultOptions();

        $startTime = microtime(true);
        $debugStartTime = $this->debug ? $startTime : null;

        if ($this->debug && $debugStartTime !== null) {
            error_log("[Ragie Debug] Query: {$query}");
        }

        if ($this->debug) {
            error_log('[Ragie Debug] Options: ' . json_encode($options->toRetrieveParams($query)));
        }

        $this->structuredLogger?->logRetrievalStart('ragie', $query);

        $retrieveParams = $options->toRetrieveParams($query);

        $cacheKey = null;
        if ($this->cache !== null) {
            $cacheKey = $this->buildCacheKey($retrieveParams);
            if ($this->cache->has($cacheKey)) {
                $cached = $this->cache->get($cacheKey);
                if ($cached !== null) {
                    $chunkCount = count($cached->getChunks());
                    $durationMs = $this->elapsedMs($startTime);

                    if ($this->debug && $debugStartTime !== null) {
                        error_log(sprintf('[Ragie Debug] Duration: %dms', $durationMs));
                        error_log('[Ragie Debug] Chunks returned: ' . $chunkCount);
                    }

                    $this->structuredLogger?->logRetrievalSuccess('ragie', $query, $durationMs, $chunkCount, true);

                    if ($this->metricsCollector !== null) {
                        $this->metricsCollector->recordRetrieval('ragie', $durationMs, $chunkCount, true);
                    }

                    return Create::promiseFor($cached);
                }
            }
        }

        $promise = $this->getRetrievalsApi()->retrieveAsync($retrieveParams);

        return $promise->then(
            function (\Ragie\Api\Model\Retrieval $retrieval) use ($cacheKey, $query, $startTime, $debugStartTime): RetrievalResult {
                $result = new RetrievalResult($retrieval);

                if ($cacheKey !== null && $this->cache !== null) {
                    $this->cache->set($cacheKey, $result, $this->cacheTtlSeconds);
                }

                $chunkCount = count($result->getChunks());
                $durationMs = $this->elapsedMs($startTime);

                if ($this->debug && $debugStartTime !== null) {
                    error_log(sprintf('[Ragie Debug] Duration: %dms', $durationMs));
                    error_log('[Ragie Debug] Chunks returned: ' . $chunkCount);
                }

                $this->structuredLogger?->logRetrievalSuccess('ragie', $query, $durationMs, $chunkCount, false);

                if ($this->metricsCollector !== null) {
                    $this->metricsCollector->recordRetrieval('ragie', $durationMs, $chunkCount, true);
                }

                if ($this->costTracker !== null) {
                    $this->costTracker->recordRagieQuery();
                }

                return $result;
            },
            function ($reason) use ($query, $startTime) {
                $durationMs = $this->elapsedMs($startTime);
                $throwable = $reason instanceof \Throwable
                    ? $reason
                    : new \RuntimeException('Asynchronous retrieval failed');

                $this->structuredLogger?->logRetrievalFailure('ragie', $query, $throwable, $durationMs);

                if ($this->metricsCollector !== null) {
                    $this->metricsCollector->recordRetrieval('ragie', $durationMs, 0, false);
                }

                if ($this->costTracker !== null) {
                    $this->costTracker->recordRagieQuery();
                }

                throw $throwable;
            }
        );
    }

    /**
     * Get the underlying Retrievals API instance
     *
     * Provides direct access to the generated RetrievalsApi for advanced use cases.
     *
     * @return RetrievalsApi
     */
    public function getRetrievalsApi(): RetrievalsApi
    {
        if ($this->retrievalsApi === null) {
            $this->retrievalsApi = new RetrievalsApi(
                $this->httpClient,
                $this->configuration
            );
        }

        return $this->retrievalsApi;
    }

    /**
     * Get the underlying Responses API instance
     *
     * Provides direct access to the generated ResponsesApi for AI response generation.
     *
     * @return ResponsesApi
     */
    public function getResponsesApi(): ResponsesApi
    {
        if ($this->responsesApi === null) {
            $this->responsesApi = new ResponsesApi(
                $this->httpClient,
                $this->configuration
            );
        }

        return $this->responsesApi;
    }

    /**
     * Get the underlying Documents API instance
     *
     * Provides direct access to the generated DocumentsApi for document management operations.
     *
     * @return DocumentsApi
     */
    public function getDocumentsApi(): DocumentsApi
    {
        if ($this->documentsApi === null) {
            $this->documentsApi = new DocumentsApi(
                $this->httpClient,
                $this->configuration
            );
        }

        return $this->documentsApi;
    }

    /**
     * Get the API configuration instance
     *
     * Provides access to the underlying configuration for advanced customization.
     *
     * @return Configuration
     */
    public function getConfiguration(): Configuration
    {
        return $this->configuration;
    }

    /**
     * Set default top_k value for all subsequent retrievals
     *
     * Configures a default number of results to return for all retrieve() calls
     * that don't explicitly specify a top_k value.
     *
     * @param int $topK Default number of chunks to retrieve (must be positive)
     *
     * @return self Returns $this for method chaining
     *
     * @example
     * ```php
     * $ragie = (new Client($apiKey))
     *     ->withDefaultTopK(20)
     *     ->withDefaultRerank();
     *
     * // All subsequent calls use top_k=20 and rerank=true by default
     * $result = $ragie->retrieve('query');
     * ```
     */
    public function withDefaultTopK(int $topK): self
    {
        $this->defaultTopK = $topK;
        return $this;
    }

    /**
     * Set default rerank value for all subsequent retrievals
     *
     * Configures whether to rerank results by default for all retrieve() calls
     * that don't explicitly specify a rerank value.
     *
     * @param bool $rerank Whether to rerank results by default (default: true)
     *
     * @return self Returns $this for method chaining
     *
     * @example
     * ```php
     * $ragie = (new Client($apiKey))
     *     ->withDefaultTopK(15)
     *     ->withDefaultRerank(false);
     *
     * // Fast retrieval without reranking
     * $result = $ragie->retrieve('query');
     * ```
     */
    public function withDefaultRerank(bool $rerank = true): self
    {
        $this->defaultRerank = $rerank;
        return $this;
    }

    /**
     * Enable caching for identical retrieval queries.
     *
     * @param QueryCacheInterface $cache Cache implementation handling persistence
     * @param int $ttlSeconds Default cache lifetime in seconds
     *
     * @return self
     */
    public function withCache(QueryCacheInterface $cache, int $ttlSeconds = self::DEFAULT_CACHE_TTL): self
    {
        $this->cache = $cache;
        $this->cacheTtlSeconds = $ttlSeconds > 0 ? $ttlSeconds : self::DEFAULT_CACHE_TTL;

        return $this;
    }

    /**
     * Attach a metrics collector for retrieval telemetry.
     *
     * @return self
     */
    public function withMetricsCollector(MetricsCollector $metricsCollector): self
    {
        $this->metricsCollector = $metricsCollector;
        return $this;
    }

    /**
     * Attach a cost tracker to measure API spend.
     *
     * @return self
     */
    public function withCostTracker(CostTracker $costTracker): self
    {
        $this->costTracker = $costTracker;
        return $this;
    }

    /**
     * Attach a StructuredLogger instance for PSR-3 logging hooks.
     */
    public function withStructuredLogger(StructuredLogger $logger): self
    {
        $this->structuredLogger = $logger;
        return $this;
    }

    /**
     * Convenience helper for passing a raw PSR-3 logger.
     *
     * @psalm-suppress PossiblyUnusedReturnValue Fluent API consumed by downstream scripts
     */
    public function withLogger(LoggerInterface $logger): self
    {
        return $this->withStructuredLogger(new StructuredLogger($logger));
    }

    /**
     * Set retry policy for handling transient failures
     *
     * Configures exponential backoff retry logic for network errors,
     * server errors (5xx), and rate limits (429).
     *
     * @param \Ragie\Retry\RetryPolicy $retryPolicy Retry policy instance
     * @return self Returns $this for method chaining
     *
     * @example
     * ```php
     * use Ragie\Retry\RetryPolicy;
     *
     * $client = (new Client($apiKey))
     *     ->withRetryPolicy(new RetryPolicy(
     *         maxAttempts: 3,
     *         initialDelayMs: 100,
     *         multiplier: 2.0,
     *         maxDelayMs: 5000
     *     ));
     * ```
     */
    public function withRetryPolicy(\Ragie\Retry\RetryPolicy $retryPolicy): self
    {
        $this->retryPolicy = $retryPolicy;
        return $this;
    }

    /**
     * Enable debug mode with detailed logging
     *
     * When enabled, the client will log detailed information about retrievals
     * including queries, options, timing, and results to error_log().
     *
     * @return self Returns $this for method chaining
     * @psalm-suppress PossiblyUnusedMethod Public API consumed by downstream scripts outside this repo
     *
     * @example
     * ```php
     * $client = (new Client($apiKey))
     *     ->enableDebug();
     *
     * // Debug output will be written to error_log
     * $result = $client->retrieve('test query');
     * ```
     */
    public function enableDebug(): self
    {
        $this->debug = true;
        return $this;
    }

    /**
     * Retrieve multiple queries in batch
     *
     * Processes multiple queries and returns an array of results.
     * Currently processes queries sequentially - may be optimized for parallel processing in the future.
     *
     * @param array<string> $queries Array of search queries
     * @param RetrievalOptions|null $options Optional retrieval parameters applied to all queries
     *
     * @throws \Ragie\Api\ApiException If any API request fails
     * @throws InvalidQueryException If any query is empty or whitespace
     *
     * @return array<RetrievalResult> Array of retrieval results in the same order as queries
     *
     * @example
     * ```php
     * $queries = [
     *     'What is machine learning?',
     *     'Explain neural networks',
     *     'How does gradient descent work?'
     * ];
     *
     * $results = $ragie->retrieveBatch($queries);
     *
     * foreach ($results as $i => $result) {
     *     echo "Query {$i}: " . $queries[$i] . "\n";
     *     echo "Top chunk: " . $result->getChunks()[0]->getText() . "\n\n";
     * }
     * ```
     */
    public function retrieveBatch(array $queries, ?RetrievalOptions $options = null): array
    {
        return array_map(
            fn ($query) => $this->retrieve($query, $options),
            $queries
        );
    }

    /**
     * Retrieve multiple queries concurrently using promises.
     *
     * @param array<string> $queries
     * @param RetrievalOptions|null $options Options applied to every query
     *
     * @return array<RetrievalResult>
     */
    public function retrieveConcurrent(array $queries, ?RetrievalOptions $options = null): array
    {
        $promises = array_map(
            fn ($query): PromiseInterface => $this->retrieveAsync((string) $query, $options),
            $queries
        );

        if ($promises === []) {
            return [];
        }

        return Utils::unwrap($promises);
    }

    /**
     * Create default options from fluent configuration
     *
     * Builds a RetrievalOptions object applying any defaults set via withDefaultTopK() or withDefaultRerank().
     *
     * @return RetrievalOptions Options object with defaults applied
     */
    private function createDefaultOptions(): RetrievalOptions
    {
        $options = RetrievalOptions::create();

        if ($this->defaultTopK !== null) {
            $options = $options->withTopK($this->defaultTopK);
        }

        if ($this->defaultRerank !== null) {
            $options = $options->withRerank($this->defaultRerank);
        }

        return $options;
    }

    private function elapsedMs(float $startTime): int
    {
        return (int) max(0, round((microtime(true) - $startTime) * 1000.0));
    }

    private function buildCacheKey(\Ragie\Api\Model\RetrieveParams $params): string
    {
        $host = (string) $this->configuration->getHost();

        try {
            $payload = (string) json_encode($params, JSON_THROW_ON_ERROR);
        } catch (JsonException) {
            $payload = serialize($params);
        }

        return hash('sha256', $host . '|' . $payload);
    }

    /**
     * @api
     */
    public function getMetricsCollector(): ?MetricsCollector
    {
        return $this->metricsCollector;
    }

    /**
     * @api
     */
    public function getCostTracker(): ?CostTracker
    {
        return $this->costTracker;
    }

    /**
     * @api
     */
    public function getStructuredLogger(): ?StructuredLogger
    {
        return $this->structuredLogger;
    }
}
</document_content>
</document>

<document index="34">
<source>src/Examples/ChunkFormatter.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: src/Examples/ChunkFormatter.php

namespace Ragie\Examples;

use Ragie\Api\Model\ScoredChunk;

/**
 * Formats retrieved chunks for CLI demonstrations.
 */
final class ChunkFormatter
{
    private const DEFAULT_MAX_LENGTH = 180;
    private const MIN_LENGTH = 10;

    public static function formatChunk(ScoredChunk $chunk, int $index, int $maxLength = self::DEFAULT_MAX_LENGTH): string
    {
        $normalizedIndex = max(1, $index);
        $effectiveLength = $maxLength >= self::MIN_LENGTH ? $maxLength : self::DEFAULT_MAX_LENGTH;

        $text = trim((string) $chunk->getText());
        if ($text === '') {
            $text = '[empty chunk text]';
        }

        if (mb_strlen($text) > $effectiveLength) {
            $text = rtrim(mb_substr($text, 0, $effectiveLength - 1)) . 'â€¦';
        }

        $document = $chunk->getDocumentName();
        $documentLabel = ($document !== null && trim($document) !== '') ? $document : 'Unknown document';

        /** @var float|null $score */
        $score = $chunk->getScore();
        $scoreText = $score !== null ? number_format((float) $score, 3) : 'N/A';

        $documentId = trim((string) $chunk->getDocumentId());
        $documentIdLine = $documentId !== '' ? sprintf("\n   Doc ID: %s", $documentId) : '';

        return sprintf(
            "%d. [%s] score=%s%s\n   %s",
            $normalizedIndex,
            $documentLabel,
            $scoreText,
            $documentIdLine,
            $text
        );
    }
}
</document_content>
</document>

<document index="35">
<source>src/Exception/ConfigurationException.php</source>
<document_content>
<?php

// this_file: src/Exception/ConfigurationException.php

declare(strict_types=1);

namespace Ragie\Exception;

use RuntimeException;

/**
 * Thrown when required configuration is missing or invalid.
 *
 * This exception is thrown during initialization when environment variables
 * or configuration values are missing or invalid.
 *
 * @example
 * ```php
 * $apiKey = getenv('RAGIE_API_KEY');
 * if ($apiKey === false || trim($apiKey) === '') {
 *     throw ConfigurationException::missingEnv('RAGIE_API_KEY');
 * }
 * ```
 */
class ConfigurationException extends RuntimeException implements RagieException
{
    /**
     * Create exception for missing required environment variable.
     *
     * @param string $varName Name of the missing environment variable
     * @psalm-suppress PossiblyUnusedMethod Legacy helper retained for backward compatibility.
     */
    public static function missingEnv(string $varName): self
    {
        return new self(sprintf(
            'Required environment variable "%s" is not set',
            $varName
        ));
    }

    /**
     * Create exception for empty environment variable.
     *
     * @param string $varName Name of the empty environment variable
     * @psalm-suppress PossiblyUnusedMethod Legacy helper retained for backward compatibility.
     */
    public static function emptyEnv(string $varName): self
    {
        return new self(sprintf(
            'Environment variable "%s" is set but empty',
            $varName
        ));
    }

    /**
     * Create exception for invalid configuration value.
     *
     * @param string $key Configuration key
     * @param string $reason Why the value is invalid
     * @api
     */
    public static function invalid(string $key, string $reason): self
    {
        return new self(sprintf(
            'Invalid configuration for "%s": %s',
            $key,
            $reason
        ));
    }
}
</document_content>
</document>

<document index="36">
<source>src/Exception/InvalidParameterException.php</source>
<document_content>
<?php

// this_file: src/Exception/InvalidParameterException.php

declare(strict_types=1);

namespace Ragie\Exception;

use InvalidArgumentException;

/**
 * Thrown when invalid parameters are provided to RetrievalOptions.
 *
 * This exception is thrown for various parameter validation failures:
 * - Invalid topK values (must be positive)
 * - Invalid maxChunksPerDocument values (must be positive)
 * - Empty partition strings
 * - Whitespace-only partition strings
 *
 * @example
 * ```php
 * try {
 *     Retrifinal evalOptions::create()->withTopK(-1);
 * } catch (InvalidParameterException $e) {
 *     echo "Invalid parameter: " . $e->getMessage();
 * }
 * ```
 */
class InvalidParameterException extends InvalidArgumentException implements RagieException
{
    /**
     * Create exception for invalid topK value.
     */
    public static function invalidTopK(int $value): self
    {
        return new self("topK must be a positive integer, got {$value}");
    }

    /**
     * Create exception for invalid maxChunksPerDocument value.
     */
    public static function invalidMaxChunks(int $value): self
    {
        return new self("maxChunksPerDocument must be a positive integer, got {$value}");
    }

    /**
     * Create exception for empty partition string.
     */
    public static function emptyPartition(): self
    {
        return new self('partition cannot be empty');
    }

    /**
     * Create exception for whitespace-only partition string.
     */
    public static function whitespacePartition(): self
    {
        return new self('partition cannot consist only of whitespace');
    }
}
</document_content>
</document>

<document index="37">
<source>src/Exception/InvalidQueryException.php</source>
<document_content>
<?php

// this_file: src/Exception/InvalidQueryException.php

declare(strict_types=1);

namespace Ragie\Exception;

use InvalidArgumentException;

/**
 * Thrown when an invalid query is provided to the retrieve() method.
 *
 * Invalid queries include:
 * - Empty strings
 * - Whitespace-only strings
 * - Null values (caught by type system)
 *
 * @example
 * ```php
 * try {
 *   final   $client->retrieve('');  // Empty query
 * } catch (InvalidQueryException $e) {
 *     echo "Invalid query: " . $e->getMessage();
 * }
 * ```
 */
class InvalidQueryException extends InvalidArgumentException implements RagieException
{
    /**
     * Create exception for empty query.
     */
    public static function empty(): self
    {
        return new self('Query cannot be empty');
    }

    /**
     * Create exception for whitespace-only query.
     */
    public static function whitespace(): self
    {
        return new self('Query cannot consist only of whitespace');
    }

    /**
     * Create exception for query that exceeds maximum length.
     *
     * @param int $length Actual query length
     * @param int $maxLength Maximum allowed length
     */
    public static function tooLong(int $length, int $maxLength): self
    {
        return new self(sprintf(
            'Query length (%d characters) exceeds maximum allowed length (%d characters)',
            $length,
            $maxLength
        ));
    }

    /**
     * Create exception for disallowed control characters.
     */
    public static function controlCharacters(): self
    {
        return new self('Query contains invalid control characters');
    }
}
</document_content>
</document>

<document index="38">
<source>src/Exception/RagieException.php</source>
<document_content>
<?php

// this_file: src/Exception/RagieException.php

declare(strict_types=1);

namespace Ragie\Exception;

use Throwable;

/**
 * Base exception interface for all Ragie-specific exceptions.
 *
 * This allows catching all Ragie exceptions with a single catch block:
 * <code>
 * try {
 *     $client->retrieve($query);
 * } catch (RagieException $e) {
 *     // Handle any Ragie-specific error
 * }
 * </code>
 */
interface RagieException extends Throwable
{
}
</document_content>
</document>

<document index="39">
<source>src/Http/ResponseFormatter.php</source>
<document_content>
<?php

declare(strict_types=1);

/**
 * this_file: src/Http/ResponseFormatter.php
 */

namespace Ragie\Http;

/**
 * Utility for formatting consistent HTTP responses
 *
 * Provides standardized success and error response formatting
 * with support for both JSON and plain text output.
 *
 * @example
 * ```php
 * // Success response
 * ResponseFormatter::success(['result' => 'data'], 'json');
 *
 * // Error response
 * ResponseFormatter::error('Not found', 404, 'json');
 * ```
 */
final class ResponseFormatter
{
    /**
     * Format and send a success response
     *
     * @param mixed $data Response data
     * @param string $format Output format ('json' or 'text')
     * @return string Formatted output (for testing)
     */
    public static function success(mixed $data, string $format = 'json'): string
    {
        $output = self::formatSuccess($data, $format);

        if (!defined('PHPUNIT_RUNNING')) {
            if ($format === 'json') {
                header('Content-Type: application/json');
            } else {
                header('Content-Type: text/plain; charset=utf-8');
            }
            echo $output;
            exit(0);
        }

        return $output;
    }

    /**
     * Format and send an error response
     *
     * @param string $message Error message
     * @param int $httpCode HTTP status code
     * @param string $format Output format ('json' or 'text')
     * @param array<string, mixed>|null $details Additional error details
     * @return string Formatted output (for testing)
     */
    public static function error(
        string $message,
        int $httpCode = 500,
        string $format = 'json',
        ?array $details = null
    ): string {
        $output = self::formatError($message, $format, $details);

        if (!defined('PHPUNIT_RUNNING')) {
            http_response_code($httpCode);
            if ($format === 'json') {
                header('Content-Type: application/json');
            } else {
                header('Content-Type: text/plain; charset=utf-8');
            }
            echo $output;
            exit($httpCode >= 500 ? 1 : 0);
        }

        return $output;
    }

    /**
     * Format success response without sending
     *
     * @param mixed $data Response data
     * @param string $format Output format
     * @return string Formatted output
     * @internal
     */
    public static function formatSuccess(mixed $data, string $format = 'json'): string
    {
        if ($format === 'json') {
            return json_encode(['success' => true, 'data' => $data], JSON_THROW_ON_ERROR);
        }

        return is_string($data) ? $data : print_r($data, true);
    }

    /**
     * Format error response without sending
     *
     * @param string $message Error message
     * @param string $format Output format
     * @param array<string, mixed>|null $details Additional details
     * @return string Formatted output
     * @internal
     */
    public static function formatError(
        string $message,
        string $format = 'json',
        ?array $details = null
    ): string {
        if ($format === 'json') {
            $response = [
                'success' => false,
                'error' => $message,
            ];
            if ($details !== null) {
                $response['details'] = $details;
            }
            return json_encode($response, JSON_THROW_ON_ERROR);
        }

        $output = "Error: $message";
        if ($details !== null) {
            $output .= "\n\nDetails:\n" . print_r($details, true);
        }
        return $output;
    }
}
</document_content>
</document>

<document index="40">
<source>src/Logging/StructuredLogger.php</source>
<document_content>
<?php

declare(strict_types=1);

/**
 * this_file: src/Logging/StructuredLogger.php
 */

namespace Ragie\Logging;

use Psr\Log\LoggerInterface;

final class StructuredLogger
{
    public function __construct(private ?LoggerInterface $logger = null)
    {
    }

    /**
     * @param array<string, mixed> $context
     */
    public function logRetrievalStart(string $provider, string $query, array $context = []): void
    {
        $this->logger?->info('ragie.retrieve.start', array_merge($context, [
            'provider' => $provider,
            'query_preview' => $this->preview($query),
            'timestamp_ms' => $this->timestamp(),
        ]));
    }

    public function logRetrievalSuccess(string $provider, string $query, int $durationMs, int $chunkCount, bool $cacheHit): void
    {
        $this->logger?->info('ragie.retrieve.success', [
            'provider' => $provider,
            'query_preview' => $this->preview($query),
            'chunk_count' => $chunkCount,
            'duration_ms' => $durationMs,
            'cache_hit' => $cacheHit,
            'timestamp_ms' => $this->timestamp(),
        ]);
    }

    /**
     * @param array<string, mixed> $context
     */
    public function logRetrievalFailure(string $provider, string $query, \Throwable $exception, int $durationMs, array $context = []): void
    {
        $this->logger?->error('ragie.retrieve.failure', array_merge($context, [
            'provider' => $provider,
            'query_preview' => $this->preview($query),
            'duration_ms' => $durationMs,
            'exception' => get_class($exception),
            'error_message' => $exception->getMessage(),
            'code' => $exception->getCode(),
            'timestamp_ms' => $this->timestamp(),
        ]));
    }

    private function preview(string $value): string
    {
        $flattened = trim((string) preg_replace('/\s+/u', ' ', $value));
        return mb_substr($flattened, 0, 120) ?: '';
    }

    private function timestamp(): int
    {
        return (int) round((float) microtime(true) * 1000.0);
    }
}
</document_content>
</document>

<document index="41">
<source>src/Metrics/CostTracker.php</source>
<document_content>
<?php

declare(strict_types=1);

/**
 * this_file: src/Metrics/CostTracker.php
 */

namespace Ragie\Metrics;

/**
 * Tracks approximate spend for Ragie retrieval calls.
 */
final class CostTracker
{
    private const RAGIE_COST_PER_QUERY = 0.001;

    private float $totalCost = 0.0;
    private int $ragieQueries = 0;

    public function recordRagieQuery(?float $costOverride = null): void
    {
        $this->ragieQueries++;
        $this->totalCost += $costOverride ?? self::RAGIE_COST_PER_QUERY;
    }

    public function getTotalCost(): float
    {
        return round($this->totalCost, 6);
    }

    public function getRagieQueries(): int
    {
        return $this->ragieQueries;
    }

    /**
     * @return array{
     *     total_cost: float,
     *     ragie_queries: int
     * }
     */
    public function getSummary(): array
    {
        return [
            'total_cost' => $this->getTotalCost(),
            'ragie_queries' => $this->ragieQueries,
        ];
    }
}
</document_content>
</document>

<document index="42">
<source>src/Metrics/MetricsCollector.php</source>
<document_content>
<?php

declare(strict_types=1);

/**
 * this_file: src/Metrics/MetricsCollector.php
 */

namespace Ragie\Metrics;

/**
 * Lightweight in-memory collector for retrieval telemetry.
 */
final class MetricsCollector
{
    /**
     * @var array<int, array<string, mixed>>
     */
    private array $events = [];

    public function recordRetrieval(string $source, int|float $durationMs, int $chunkCount, bool $success): void
    {
        $this->events[] = [
            'type' => 'retrieval',
            'source' => $source,
            'duration_ms' => max(0, (int) round($durationMs)),
            'chunk_count' => max(0, $chunkCount),
            'success' => $success,
            'timestamp' => microtime(true),
        ];
    }

    /**
     * @return array<int, array<string, mixed>>
     */
    public function getEvents(): array
    {
        return $this->events;
    }

    /**
     * @return array{
     *     total_requests: int,
     *     successful_requests: int,
     *     avg_duration_ms: int
     * }
     */
    public function getSummary(): array
    {
        $retrievals = array_filter(
            $this->events,
            fn (array $event): bool => ($event['type'] ?? '') === 'retrieval'
        );

        $totalRequests = count($retrievals);
        $successes = count(
            array_filter($retrievals, fn (array $event): bool => ($event['success'] ?? false) === true)
        );
        $avgDuration = $totalRequests > 0
            ? (int) round(array_sum(array_map(
                fn (array $event): int => (int) ($event['duration_ms'] ?? 0),
                $retrievals
            )) / $totalRequests)
            : 0;

        return [
            'total_requests' => $totalRequests,
            'successful_requests' => $successes,
            'avg_duration_ms' => $avgDuration,
        ];
    }
}
</document_content>
</document>

<document index="43">
<source>src/RetrievalOptions.php</source>
<document_content>
<?php

// this_file: src/RetrievalOptions.php

declare(strict_types=1);

namespace Ragie;

use Ragie\Api\Model\RetrieveParams;
use Ragie\Exception\InvalidParameterException;

/**
 * Fluent builder for retrieval parameters
 *
 * Provides a convenient, immutable builder interface for constructing retrieval parameters.
 * Each `with*` method returns a new instance, allowing for safe method chaining.
 *
 * @example
 * ```php
 * use Ragie\RetrievalOptions;
 *
 * $options = RetrievalOptions::create()
 *     ->withTopK(20)
 *     ->withRerank()
 *     ->withFilter(['category' => ['$in' => ['sales', 'marketing']]])
 *     ->withMaxChunksPerDocument(3);
 *
 * $result = $ragie->retrieve('sales strategy', $options);
 * ```
 *
 * @package Ragie
 */
final class RetrievalOptions
{
    private ?int $topK = null;

    /** @var array<string, mixed>|null */
    private ?array $filter = null;
    private ?bool $rerank = null;
    private ?int $maxChunksPerDocument = null;
    private ?string $partition = null;
    private ?bool $recencyBias = null;

    /**
     * Private constructor to enforce use of factory method
     */
    private function __construct()
    {
    }

    /**
     * Create a new RetrievalOptions instance
     *
     * @return self
     */
    public static function create(): self
    {
        return new self();
    }

    /**
     * Set the number of results to return
     *
     * @param int $topK Number of chunks to retrieve (must be positive)
     *
     * @example
     * ```php
     * $options = RetrievalOptions::create()->withTopK(10);
     * // Returns top 10 most relevant chunks
     * ```
     *
     * @throws InvalidParameterException If topK is not positive
     * @return self New instance with the updated value
     */
    public function withTopK(int $topK): self
    {
        if ($topK <= 0) {
            throw InvalidParameterException::invalidTopK($topK);
        }

        $clone = clone $this;
        $clone->topK = $topK;

        return $clone;
    }

    /**
     * Set metadata filter for results
     *
     * Filters results to only include documents matching the specified metadata criteria.
     * See Ragie documentation for filter syntax and supported operators.
     *
     * @param array<string, mixed> $filter Metadata filter criteria
     *
     * @return self New instance with the updated value
     *
     * @example
     * ```php
     * // Equal to
     * ->withFilter(['category' => 'docs'])
     *
     * // In array
     * ->withFilter(['department' => ['$in' => ['sales', 'marketing']]])
     *
     * // Greater than
     * ->withFilter(['priority' => ['$gt' => 5]])
     * ```
     */
    public function withFilter(array $filter): self
    {
        $clone = clone $this;
        $clone->filter = $filter;

        return $clone;
    }

    /**
     * Enable or disable result reranking
     *
     * When enabled, results are reranked using a more sophisticated model for better relevance.
     *
     * @param bool $rerank Whether to rerank results (default: true)
     *
     * @example
     * ```php
     * $options = RetrievalOptions::create()->withRerank();
     * // Enable reranking for more accurate results (slight performance cost)
     *
     * $options = RetrievalOptions::create()->withRerank(false);
     * // Disable reranking for faster retrieval
     * ```
     *
     * @return self New instance with the updated value
     */
    public function withRerank(bool $rerank = true): self
    {
        $clone = clone $this;
        $clone->rerank = $rerank;

        return $clone;
    }

    /**
     * Set maximum chunks per document
     *
     * Limits how many chunks can be returned from a single document.
     *
     * @param int $max Maximum chunks per document (must be positive)
     *
     *
     * @throws InvalidParameterException If max is not positive
     * @return self New instance with the updated value
     */
    public function withMaxChunksPerDocument(int $max): self
    {
        if ($max <= 0) {
            throw InvalidParameterException::invalidMaxChunks($max);
        }

        $clone = clone $this;
        $clone->maxChunksPerDocument = $max;

        return $clone;
    }

    /**
     * Set partition to search within
     *
     * Scopes the search to a specific partition.
     *
     * @param string $partition Partition identifier
     *
     *
     * @throws InvalidParameterException If partition is empty or whitespace
     * @return self New instance with the updated value
     */
    public function withPartition(string $partition): self
    {
        $trimmed = trim($partition);
        if ($trimmed === '') {
            if ($partition === '') {
                throw InvalidParameterException::emptyPartition();
            }
            throw InvalidParameterException::whitespacePartition();
        }

        $clone = clone $this;
        $clone->partition = $partition;

        return $clone;
    }

    /**
     * Enable or disable recency bias
     *
     * When enabled, more recent documents are given higher scores.
     *
     * @param bool $bias Whether to apply recency bias (default: true)
     *
     * @return self New instance with the updated value
     */
    public function withRecencyBias(bool $bias = true): self
    {
        $clone = clone $this;
        $clone->recencyBias = $bias;

        return $clone;
    }

    /**
     * Convert to API RetrieveParams model
     *
     * Internal method that converts this options object into the API's expected parameter format.
     *
     * @param string $query The search query
     *
     * @return RetrieveParams The API parameter object
     *
     * @internal
     */
    public function toRetrieveParams(string $query): RetrieveParams
    {
        $params = new RetrieveParams([
            'query' => $query,
        ]);

        if ($this->topK !== null) {
            $params->setTopK($this->topK);
        }

        if ($this->filter !== null) {
            $params->setFilter($this->filter);
        }

        if ($this->rerank !== null) {
            $params->setRerank($this->rerank);
        }

        if ($this->maxChunksPerDocument !== null) {
            $params->setMaxChunksPerDocument($this->maxChunksPerDocument);
        }

        if ($this->partition !== null) {
            $params->setPartition($this->partition);
        }

        if ($this->recencyBias !== null) {
            $params->setRecencyBias($this->recencyBias);
        }

        return $params;
    }
}
</document_content>
</document>

<document index="44">
<source>src/RetrievalResult.php</source>
<document_content>
<?php

// this_file: src/RetrievalResult.php

declare(strict_types=1);

namespace Ragie;

use Ragie\Api\Model\Retrieval;
use Ragie\Api\Model\ScoredChunk;

/**
 * Convenient wrapper for retrieval results
 *
 * Wraps the API's Retrieval response and provides convenient accessor methods
 * for common operations. Implements Countable for natural count() usage.
 *
 * @example
 * ```php
 * $result = $ragie->retrieve('question');
 *
 * if ($result->isEmpty()) {
 *     echo "No results found\n";
 *     return;
 * }
 *
 * echo "Found {$result->count()} chunks\n";
 *
 * // Get best match
 * $topChunk = $result->getTopChunk();
 * echo "Best: {$topChunk->getText()}\n";
 *
 * // Get all chunk texts
 * $texts = $result->getChunkTexts();
 *
 * // Access full chunk objects
 * foreach ($result->getChunks() as $chunk) {
 *     echo "{$chunk->getDocumentName()}: {$chunk->getText()}\n";
 * }
 * ```
 *
 * @package Ragie
 */
final class RetrievalResult implements \Countable
{
    private Retrieval $retrieval;

    /** @var string[]|null Memoized chunk texts */
    private ?array $chunkTexts = null;

    /** @var string[]|null Memoized document IDs */
    private ?array $documentIds = null;

    /**
     * Wrap an API Retrieval response
     *
     * @param Retrieval $retrieval The underlying API response
     */
    public function __construct(Retrieval $retrieval)
    {
        $this->retrieval = $retrieval;
    }

    /**
     * Get all scored chunks from the retrieval
     *
     * @return ScoredChunk[] Array of scored chunk objects
     */
    public function getChunks(): array
    {
        $chunks = $this->retrieval->getScoredChunks();
        // @phpstan-ignore-next-line getScoredChunks() can return null from generated API
        return $chunks ?? [];
    }

    /**
     * Get the highest scoring chunk
     *
     * Returns null if there are no results.
     *
     * @return ScoredChunk|null The top-scoring chunk, or null if empty
     */
    public function getTopChunk(): ?ScoredChunk
    {
        $chunks = $this->getChunks();

        if (empty($chunks)) {
            return null;
        }

        return $chunks[0];
    }

    /**
     * Get array of just the text content from all chunks
     *
     * Convenient method to extract just the text strings without the full chunk objects.
     * Results are memoized for performance on repeated calls.
     *
     * @return string[] Array of text strings
     */
    public function getChunkTexts(): array
    {
        if ($this->chunkTexts === null) {
            $this->chunkTexts = array_map(
                static function (ScoredChunk $chunk): string {
                    $text = $chunk->getText();
                    // @phpstan-ignore-next-line getText() can return null from generated API
                    return $text ?? '';
                },
                $this->getChunks()
            );
        }

        return $this->chunkTexts;
    }

    /**
     * Get unique document IDs from the results
     *
     * Returns an array of unique document IDs that appear in the results.
     * Results are memoized for performance on repeated calls.
     *
     * @return string[] Array of unique document IDs
     */
    public function getDocumentIds(): array
    {
        if ($this->documentIds === null) {
            $ids = array_map(
                static function (ScoredChunk $chunk): string {
                    $id = $chunk->getDocumentId();
                    // @phpstan-ignore-next-line getDocumentId() can return null from generated API
                    return $id ?? '';
                },
                $this->getChunks()
            );

            $this->documentIds = array_values(array_unique(array_filter($ids)));
        }

        return $this->documentIds;
    }

    /**
     * Check if the result is empty (no chunks found)
     *
     * @return bool True if no results were found
     */
    public function isEmpty(): bool
    {
        return $this->count() === 0;
    }

    /**
     * Get the number of chunks in the result
     *
     * Implements the Countable interface, allowing natural count($result) usage.
     *
     * @return int Number of chunks
     */
    #[\Override]
    public function count(): int
    {
        return count($this->getChunks());
    }

    /**
     * Access the underlying API Retrieval object
     *
     * Provides an escape hatch to access the raw API response when needed.
     *
     * @return Retrieval The underlying API response object
     */
    public function getUnderlyingRetrieval(): Retrieval
    {
        return $this->retrieval;
    }
}
</document_content>
</document>

<document index="45">
<source>src/Retry/RetryPolicy.php</source>
<document_content>
<?php

// this_file: src/Retry/RetryPolicy.php

declare(strict_types=1);

namespace Ragie\Retry;

use GuzzleHttp\Exception\ConnectException;
use Ragie\Api\ApiException;

/**
 * Retry policy with exponential backoff for transient failures
 */
class RetryPolicy
{
    public function __construct(
        private int $maxAttempts = 3,
        private int $initialDelayMs = 100,
        private float $multiplier = 2.0,
        private int $maxDelayMs = 5000,
    ) {
        if ($maxAttempts < 1) {
            throw new \InvalidArgumentException('maxAttempts must be at least 1');
        }
        if ($initialDelayMs < 0) {
            throw new \InvalidArgumentException('initialDelayMs must be non-negative');
        }
        if ($multiplier < 1.0) {
            throw new \InvalidArgumentException('multiplier must be at least 1.0');
        }
        if ($maxDelayMs < $initialDelayMs) {
            throw new \InvalidArgumentException('maxDelayMs must be >= initialDelayMs');
        }
    }

    /**
     * Execute operation with retry logic
     *
     * @template T
     * @param callable(): T $operation
     * @throws \Throwable
     * @return T
     */
    public function execute(callable $operation): mixed
    {
        $attempt = 0;
        $delay = $this->initialDelayMs;
        /** @var \Throwable|null $lastException */
        $lastException = null;

        while ($attempt < $this->maxAttempts) {
            try {
                return $operation();
            } catch (\Throwable $e) {
                $lastException = $e;
                $attempt++;

                // Don't retry if we've exhausted attempts
                if ($attempt >= $this->maxAttempts) {
                    break;
                }

                // Don't retry if the error is not retryable
                if (!$this->isRetryable($e)) {
                    break;
                }

                // Wait before retrying
                usleep($delay * 1000);

                // Exponential backoff
                $delayFloat = (float) $delay * $this->multiplier;
                $delay = (int) min($delayFloat, (float) $this->maxDelayMs);
            }
        }

        // All retries exhausted or non-retryable error
        if ($lastException === null) {
            throw new \LogicException('No exception was thrown during execution');
        }

        throw $lastException;
    }

    /**
     * Determine if an exception is retryable
     *
     * Retryable errors:
     * - Network connection errors (ConnectException or ApiException with code 0)
     * - 5xx server errors
     * - 429 rate limit errors
     *
     * Non-retryable errors:
     * - 4xx client errors (except 429)
     * - Invalid arguments
     * - Logic errors
     */
    private function isRetryable(\Throwable $e): bool
    {
        // Network/connection errors are retryable
        if ($e instanceof ConnectException) {
            return true;
        }

        // API exceptions - check status code
        if ($e instanceof ApiException) {
            $code = $e->getCode();

            // Code 0 typically indicates network/connection error (wrapped ConnectException)
            if ($code === 0) {
                return true;
            }

            // 5xx server errors are retryable
            if ($code >= 500 && $code < 600) {
                return true;
            }

            // 429 rate limit is retryable
            if ($code === 429) {
                return true;
            }

            // Other 4xx errors are not retryable (client errors)
            return false;
        }

        // Other exceptions are not retryable by default
        return false;
    }

    /**
     * Get maximum number of attempts
     */
    public function getMaxAttempts(): int
    {
        return $this->maxAttempts;
    }

    /**
     * Get initial delay in milliseconds
     */
    public function getInitialDelayMs(): int
    {
        return $this->initialDelayMs;
    }

    /**
     * Get backoff multiplier
     */
    public function getMultiplier(): float
    {
        return $this->multiplier;
    }

    /**
     * Get maximum delay in milliseconds
     */
    public function getMaxDelayMs(): int
    {
        return $this->maxDelayMs;
    }
}
</document_content>
</document>

<document index="46">
<source>src/Validation/InputSanitizer.php</source>
<document_content>
<?php

declare(strict_types=1);

/**
 * this_file: src/Validation/InputSanitizer.php
 */

namespace Ragie\Validation;

use Ragie\Exception\InvalidQueryException;

final class InputSanitizer
{
    private const DEFAULT_MAX_LENGTH = 10000;

    /**
     * Remove null bytes and surrounding whitespace while keeping meaningful whitespace intact.
     */
    public static function sanitize(string $query): string
    {
        $clean = str_replace("\0", '', $query);
        $clean = trim($clean);

        if (function_exists('normalizer_normalize') && class_exists(\Normalizer::class)) {
            $normalized = normalizer_normalize($clean, \Normalizer::FORM_C);
            if (is_string($normalized)) {
                $clean = $normalized;
            }
        }

        return $clean;
    }

    /**
     * Sanitize and validate a query, throwing if it remains invalid.
     */
    public static function sanitizeAndValidate(string $query, int $maxLength = self::DEFAULT_MAX_LENGTH): string
    {
        $sanitized = self::sanitize($query);

        if ($sanitized === '') {
            if ($query === '') {
                throw InvalidQueryException::empty();
            }

            throw InvalidQueryException::whitespace();
        }

        if (self::hasControlCharacters($sanitized)) {
            throw InvalidQueryException::controlCharacters();
        }

        if ($maxLength > 0 && mb_strlen($sanitized) > $maxLength) {
            throw InvalidQueryException::tooLong(mb_strlen($sanitized), $maxLength);
        }

        return $sanitized;
    }

    /**
     * Determine whether the string contains disallowed control characters.
     */
    public static function hasControlCharacters(string $query): bool
    {
        return preg_match('/[\x00-\x08\x0B\x0C\x0E-\x1F]/u', $query) === 1;
    }
}
</document_content>
</document>

<document index="47">
<source>test.sh</source>
<document_content>
#!/usr/bin/env bash
# this_file: test.sh

set -euo pipefail

composer install --prefer-dist --no-progress
composer lint
composer stan
composer psalm
composer test
</document_content>
</document>

<document index="48">
<source>tests/Compliance/NamespaceIsolationTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: ragie-php/tests/Compliance/NamespaceIsolationTest.php

namespace Ragie\Tests\Compliance;

use PHPUnit\Framework\TestCase;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;
use SplFileInfo;

final class NamespaceIsolationTest extends TestCase
{
    public function test_source_files_contain_no_paragra_namespaces(): void
    {
        $projectRoot = dirname(__DIR__);
        $sourceDir = $projectRoot . '/src';
        $composerFile = $projectRoot . '/composer.json';

        $filesToScan = $this->gatherPhpFiles($sourceDir);
        $filesToScan[] = new SplFileInfo($composerFile);

        $violations = [];

        foreach ($filesToScan as $file) {
            $contents = file_get_contents($file->getPathname());
            if ($contents === false) {
                self::fail(sprintf('Unable to read %s', $file->getPathname()));
            }

            if (str_contains($contents, 'ParaGra\\')) {
                $violations[] = $file->getPathname();
            }
        }

        $list = $violations === [] ? '' : PHP_EOL . implode(PHP_EOL, $violations);
        self::assertSame([], $violations, 'ParaGra namespace references found in:' . $list);
    }

    /**
     * @return list<SplFileInfo>
     */
    private function gatherPhpFiles(string $directory): array
    {
        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($directory),
            RecursiveIteratorIterator::LEAVES_ONLY,
        );

        $files = [];

        /** @var SplFileInfo $file */
        foreach ($iterator as $file) {
            if ($file->isDir()) {
                continue;
            }

            if ($file->getExtension() !== 'php') {
                continue;
            }

            $files[] = $file;
        }

        return $files;
    }
}
</document_content>
</document>

<document index="49">
<source>tests/Integration/RetryIntegrationTest.php</source>
<document_content>
<?php

// this_file: tests/Integration/RetryIntegrationTest.php

declare(strict_types=1);

namespace Ragie\Tests\Integration;

use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Handler\MockHandler;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\Psr7\Response;
use PHPUnit\Framework\TestCase;
use Ragie\Api\ApiException;
use Ragie\Client;
use Ragie\Retry\RetryPolicy;

class RetryIntegrationTest extends TestCase
{
    public function testClientRetriesOnNetworkError(): void
    {
        // Create mock handler that fails twice then succeeds
        $mock = new MockHandler([
            new ConnectException('Connection timeout', new Request('POST', 'test')),
            new ConnectException('Connection timeout', new Request('POST', 'test')),
            new Response(200, [], json_encode([
                'id' => 'ret_123',
                'query' => 'test query',
                'scored_chunks' => [],
            ])),
        ]);

        $handlerStack = HandlerStack::create($mock);
        $httpClient = new \GuzzleHttp\Client(['handler' => $handlerStack]);

        $client = (new Client('test-key', null, $httpClient))
            ->withRetryPolicy(new RetryPolicy(maxAttempts: 3));

        $result = $client->retrieve('test query');

        // Should succeed after retries
        $this->assertCount(0, $result->getChunks());
    }

    public function testClientRetriesOn500Error(): void
    {
        $mock = new MockHandler([
            new Response(500, [], 'Internal server error'),
            new Response(500, [], 'Internal server error'),
            new Response(200, [], json_encode([
                'id' => 'ret_123',
                'query' => 'test query',
                'scored_chunks' => [],
            ])),
        ]);

        $handlerStack = HandlerStack::create($mock);
        $httpClient = new \GuzzleHttp\Client(['handler' => $handlerStack]);

        $client = (new Client('test-key', null, $httpClient))
            ->withRetryPolicy(new RetryPolicy(maxAttempts: 3));

        $result = $client->retrieve('test query');

        $this->assertCount(0, $result->getChunks());
    }

    public function testClientRetriesOnGatewayTimeout(): void
    {
        $mock = new MockHandler([
            new Response(504, [], 'Gateway timeout'),
            new Response(504, [], 'Gateway timeout'),
            new Response(200, [], json_encode([
                'id' => 'ret_123',
                'query' => 'test query',
                'scored_chunks' => [],
            ])),
        ]);

        $handlerStack = HandlerStack::create($mock);
        $httpClient = new \GuzzleHttp\Client(['handler' => $handlerStack]);

        $client = (new Client('test-key', null, $httpClient))
            ->withRetryPolicy(new RetryPolicy(maxAttempts: 3));

        $result = $client->retrieve('test query');

        $this->assertCount(0, $result->getChunks());
    }

    public function testClientSurfaces429AfterRetryBudgetExhausted(): void
    {
        $mock = new MockHandler([
            new Response(429, [], json_encode(['error' => 'Rate limit exceeded'])),
            new Response(429, [], json_encode(['error' => 'Rate limit exceeded'])),
            new Response(429, [], json_encode(['error' => 'Rate limit exceeded'])),
        ]);

        $handlerStack = HandlerStack::create($mock);
        $httpClient = new \GuzzleHttp\Client(['handler' => $handlerStack]);

        $client = (new Client('test-key', null, $httpClient))
            ->withRetryPolicy(new RetryPolicy(maxAttempts: 3));

        $this->expectException(ApiException::class);
        $this->expectExceptionCode(429);

        $client->retrieve('test query');
    }

    public function testClientDoesNotRetryOn400Error(): void
    {
        $mock = new MockHandler([
            new Response(400, [], json_encode(['error' => 'Bad request'])),
        ]);

        $handlerStack = HandlerStack::create($mock);
        $httpClient = new \GuzzleHttp\Client(['handler' => $handlerStack]);

        $client = (new Client('test-key', null, $httpClient))
            ->withRetryPolicy(new RetryPolicy(maxAttempts: 3));

        $this->expectException(ApiException::class);

        $client->retrieve('test query');

        // Should only call API once (no retry)
        $this->assertCount(0, $mock);
    }

    public function testClientWithoutRetryPolicyDoesNotRetry(): void
    {
        $mock = new MockHandler([
            new Response(500, [], 'Internal server error'),
        ]);

        $handlerStack = HandlerStack::create($mock);
        $httpClient = new \GuzzleHttp\Client(['handler' => $handlerStack]);

        $client = new Client('test-key', null, $httpClient);
        // No retry policy configured

        $this->expectException(ApiException::class);

        $client->retrieve('test query');
    }

    public function testClientThrowsAfterMaxRetries(): void
    {
        $mock = new MockHandler([
            new Response(500, [], 'Internal server error'),
            new Response(500, [], 'Internal server error'),
            new Response(500, [], 'Internal server error'),
            new Response(500, [], 'Internal server error'),
        ]);

        $handlerStack = HandlerStack::create($mock);
        $httpClient = new \GuzzleHttp\Client(['handler' => $handlerStack]);

        $client = (new Client('test-key', null, $httpClient))
            ->withRetryPolicy(new RetryPolicy(maxAttempts: 3));

        $this->expectException(ApiException::class);

        $client->retrieve('test query');
    }
}
</document_content>
</document>

<document index="50">
<source>tests/Logging/SpyLogger.php</source>
<document_content>
<?php

// this_file: tests/Logging/SpyLogger.php

declare(strict_types=1);

namespace Ragie\Tests\Logging;

use Psr\Log\AbstractLogger;

final class SpyLogger extends AbstractLogger
{
    /** @var array<int, array{level: string, message: string, context: array<string, mixed>}> */
    public array $records = [];

    /**
     * @param mixed $level
     * @param mixed $message
     * @param array<array-key, mixed> $context
     */
    #[\Override]
    public function log($level, $message, array $context = []): void
    {
        $this->records[] = [
            'level' => (string) $level,
            'message' => (string) $message,
            'context' => $context,
        ];
    }
}
</document_content>
</document>

<document index="51">
<source>tests/Logging/StructuredLoggerTest.php</source>
<document_content>
<?php

// this_file: tests/Logging/StructuredLoggerTest.php

declare(strict_types=1);

namespace Ragie\Tests\Logging;

use PHPUnit\Framework\TestCase;
use Ragie\Logging\StructuredLogger;

final class StructuredLoggerTest extends TestCase
{
    public function testLogRetrievalSuccessRecordsContext(): void
    {
        $spy = new SpyLogger();
        $logger = new StructuredLogger($spy);

        $logger->logRetrievalSuccess('ragie', 'Explain retrieval augmented generation', 123, 4, true);

        $this->assertNotEmpty($spy->records);
        $record = $spy->records[0];
        $this->assertSame('info', $record['level']);
        $this->assertSame('ragie.retrieve.success', $record['message']);
        $this->assertSame(4, $record['context']['chunk_count']);
        $this->assertSame(123, $record['context']['duration_ms']);
        $this->assertTrue($record['context']['cache_hit']);
    }

    public function testLogRetrievalFailureIncludesException(): void
    {
        $spy = new SpyLogger();
        $logger = new StructuredLogger($spy);
        $error = new \RuntimeException('down');

        $logger->logRetrievalFailure('ragie', 'Explain caches', $error, 75);

        $record = $spy->records[0];
        $this->assertSame('error', $record['level']);
        $this->assertSame('ragie.retrieve.failure', $record['message']);
        $this->assertSame('RuntimeException', $record['context']['exception']);
        $this->assertSame('down', $record['context']['error_message']);
        $this->assertSame(75, $record['context']['duration_ms']);
    }

}
</document_content>
</document>

<document index="52">
<source>tests/Retry/RetryPolicyTest.php</source>
<document_content>
<?php

// this_file: tests/Retry/RetryPolicyTest.php

declare(strict_types=1);

namespace Ragie\Tests\Retry;

use GuzzleHttp\Exception\ConnectException;
use PHPUnit\Framework\TestCase;
use Ragie\Api\ApiException;
use Ragie\Retry\RetryPolicy;

class RetryPolicyTest extends TestCase
{
    public function testExecuteSucceedsOnFirstAttempt(): void
    {
        $policy = new RetryPolicy();
        $callCount = 0;

        $result = $policy->execute(function () use (&$callCount) {
            $callCount++;
            return 'success';
        });

        $this->assertEquals('success', $result);
        $this->assertEquals(1, $callCount);
    }

    public function testExecuteRetriesOnConnectException(): void
    {
        $policy = new RetryPolicy(maxAttempts: 3);
        $callCount = 0;

        $result = $policy->execute(function () use (&$callCount) {
            $callCount++;
            if ($callCount < 3) {
                throw new ConnectException('Connection failed', new \GuzzleHttp\Psr7\Request('GET', 'test'));
            }
            return 'success';
        });

        $this->assertEquals('success', $result);
        $this->assertEquals(3, $callCount);
    }

    public function testExecuteRetriesOn500Error(): void
    {
        $policy = new RetryPolicy(maxAttempts: 3);
        $callCount = 0;

        $result = $policy->execute(function () use (&$callCount) {
            $callCount++;
            if ($callCount < 3) {
                throw new ApiException('Server error', 500);
            }
            return 'success';
        });

        $this->assertEquals('success', $result);
        $this->assertEquals(3, $callCount);
    }

    public function testExecuteRetriesOn429RateLimit(): void
    {
        $policy = new RetryPolicy(maxAttempts: 3);
        $callCount = 0;

        $result = $policy->execute(function () use (&$callCount) {
            $callCount++;
            if ($callCount < 3) {
                throw new ApiException('Rate limit exceeded', 429);
            }
            return 'success';
        });

        $this->assertEquals('success', $result);
        $this->assertEquals(3, $callCount);
    }

    public function testExecuteDoesNotRetryOn400Error(): void
    {
        $policy = new RetryPolicy(maxAttempts: 3);
        $callCount = 0;

        $this->expectException(ApiException::class);
        $this->expectExceptionCode(400);

        try {
            $policy->execute(function () use (&$callCount) {
                $callCount++;
                throw new ApiException('Bad request', 400);
            });
        } finally {
            // Should only be called once (no retry)
            $this->assertEquals(1, $callCount);
        }
    }

    public function testExecuteDoesNotRetryOn401Error(): void
    {
        $policy = new RetryPolicy(maxAttempts: 3);
        $callCount = 0;

        $this->expectException(ApiException::class);
        $this->expectExceptionCode(401);

        try {
            $policy->execute(function () use (&$callCount) {
                $callCount++;
                throw new ApiException('Unauthorized', 401);
            });
        } finally {
            $this->assertEquals(1, $callCount);
        }
    }

    public function testExecuteThrowsAfterMaxAttempts(): void
    {
        $policy = new RetryPolicy(maxAttempts: 3);
        $callCount = 0;

        $this->expectException(ApiException::class);
        $this->expectExceptionMessage('Always fails');

        try {
            $policy->execute(function () use (&$callCount) {
                $callCount++;
                throw new ApiException('Always fails', 500);
            });
        } finally {
            // Should be called exactly maxAttempts times
            $this->assertEquals(3, $callCount);
        }
    }

    public function testExecuteDoesNotRetryOnLogicError(): void
    {
        $policy = new RetryPolicy(maxAttempts: 3);
        $callCount = 0;

        $this->expectException(\LogicException::class);

        try {
            $policy->execute(function () use (&$callCount) {
                $callCount++;
                throw new \LogicException('Logic error');
            });
        } finally {
            $this->assertEquals(1, $callCount);
        }
    }

    public function testConstructorValidatesMaxAttempts(): void
    {
        $this->expectException(\InvalidArgumentException::class);
        $this->expectExceptionMessage('maxAttempts must be at least 1');

        new RetryPolicy(maxAttempts: 0);
    }

    public function testConstructorValidatesInitialDelay(): void
    {
        $this->expectException(\InvalidArgumentException::class);
        $this->expectExceptionMessage('initialDelayMs must be non-negative');

        new RetryPolicy(initialDelayMs: -1);
    }

    public function testConstructorValidatesMultiplier(): void
    {
        $this->expectException(\InvalidArgumentException::class);
        $this->expectExceptionMessage('multiplier must be at least 1.0');

        new RetryPolicy(multiplier: 0.5);
    }

    public function testConstructorValidatesMaxDelay(): void
    {
        $this->expectException(\InvalidArgumentException::class);
        $this->expectExceptionMessage('maxDelayMs must be >= initialDelayMs');

        new RetryPolicy(initialDelayMs: 1000, maxDelayMs: 500);
    }

    public function testGettersReturnConstructorValues(): void
    {
        $policy = new RetryPolicy(
            maxAttempts: 5,
            initialDelayMs: 200,
            multiplier: 3.0,
            maxDelayMs: 10000
        );

        $this->assertEquals(5, $policy->getMaxAttempts());
        $this->assertEquals(200, $policy->getInitialDelayMs());
        $this->assertEquals(3.0, $policy->getMultiplier());
        $this->assertEquals(10000, $policy->getMaxDelayMs());
    }

    public function testDefaultConstructorValues(): void
    {
        $policy = new RetryPolicy();

        $this->assertEquals(3, $policy->getMaxAttempts());
        $this->assertEquals(100, $policy->getInitialDelayMs());
        $this->assertEquals(2.0, $policy->getMultiplier());
        $this->assertEquals(5000, $policy->getMaxDelayMs());
    }

    public function testExecuteRetriesOn503ServiceUnavailable(): void
    {
        $policy = new RetryPolicy(maxAttempts: 2);
        $callCount = 0;

        $result = $policy->execute(function () use (&$callCount) {
            $callCount++;
            if ($callCount < 2) {
                throw new ApiException('Service unavailable', 503);
            }
            return 'recovered';
        });

        $this->assertEquals('recovered', $result);
        $this->assertEquals(2, $callCount);
    }

    public function testExecuteWithSingleAttemptDoesNotRetry(): void
    {
        $policy = new RetryPolicy(maxAttempts: 1);
        $callCount = 0;

        $this->expectException(ApiException::class);

        try {
            $policy->execute(function () use (&$callCount) {
                $callCount++;
                throw new ApiException('Error', 500);
            });
        } finally {
            $this->assertEquals(1, $callCount);
        }
    }

    public function testExecuteRetriesOnCode0NetworkError(): void
    {
        $policy = new RetryPolicy(maxAttempts: 3);
        $callCount = 0;

        $result = $policy->execute(function () use (&$callCount) {
            $callCount++;
            if ($callCount < 3) {
                // Code 0 indicates network error (wrapped ConnectException)
                throw new ApiException('[0] Connection timeout', 0);
            }
            return 'success';
        });

        $this->assertEquals('success', $result);
        $this->assertEquals(3, $callCount);
    }
}
</document_content>
</document>

<document index="53">
<source>tests/fixtures/coverage/empty.xml</source>
<document_content>
<?xml version="1.0" encoding="UTF-8"?>
<!-- this_file: ragie-php/tests/fixtures/coverage/empty.xml -->
<coverage generated="1731880000" timestamp="1731880000">
    <project timestamp="1731880000">
        <metrics statements="0" coveredstatements="0" />
    </project>
</coverage>
</document_content>
</document>

<document index="54">
<source>tests/fixtures/coverage/high.xml</source>
<document_content>
<?xml version="1.0" encoding="UTF-8"?>
<!-- this_file: ragie-php/tests/fixtures/coverage/high.xml -->
<coverage generated="1731880000" timestamp="1731880000">
    <project timestamp="1731880000">
        <metrics statements="200" coveredstatements="190" />
    </project>
</coverage>
</document_content>
</document>

<document index="55">
<source>tests/fixtures/coverage/low.xml</source>
<document_content>
<?xml version="1.0" encoding="UTF-8"?>
<!-- this_file: ragie-php/tests/fixtures/coverage/low.xml -->
<coverage generated="1731880000" timestamp="1731880000">
    <project timestamp="1731880000">
        <metrics statements="120" coveredstatements="72" />
    </project>
</coverage>
</document_content>
</document>

<document index="56">
<source>tests/unit/Benchmark/RetrievalBenchmarkScriptTest.php</source>
<document_content>
<?php

// this_file: tests/unit/Benchmark/RetrievalBenchmarkScriptTest.php

declare(strict_types=1);

namespace Ragie\Tests;

use PHPUnit\Framework\TestCase;

final class RetrievalBenchmarkScriptTest extends TestCase
{
    public function testBenchmarkExitsWithHelpfulErrorWhenApiKeyMissing(): void
    {
        $script = realpath(__DIR__ . '/../../../benchmarks/RetrievalBenchmark.php');
        $this->assertIsString($script, 'Benchmark script path should resolve');

        $descriptorSpec = [
            1 => ['pipe', 'w'],
            2 => ['pipe', 'w'],
        ];

        $process = proc_open(
            escapeshellcmd(\PHP_BINARY) . ' ' . escapeshellarg($script),
            $descriptorSpec,
            $pipes,
            dirname($script),
            $this->buildEnvWithoutApiKey()
        );

        $this->assertIsResource($process, 'Benchmark process failed to start');

        $stdout = stream_get_contents($pipes[1]);
        fclose($pipes[1]);

        $stderr = stream_get_contents($pipes[2]);
        fclose($pipes[2]);

        $exitCode = proc_close($process);

        $this->assertSame(1, $exitCode, 'Benchmark should exit with status 1 when API key missing');
        $this->assertSame('', trim((string) $stdout), 'Benchmark must not emit stdout for missing API key');
        $this->assertStringContainsString('Missing RAGIE_API_KEY', (string) $stderr);
    }

    /**
     * Build a clean environment array without the Ragie API key.
     *
     * @return array<string, string>
     */
    private function buildEnvWithoutApiKey(): array
    {
        $env = [];

        foreach ($_ENV as $key => $value) {
            if (!is_string($key) || !is_string($value)) {
                continue;
            }
            $env[$key] = $value;
        }

        $path = getenv('PATH');
        if (is_string($path)) {
            $env['PATH'] = $path;
        } elseif (!isset($env['PATH'])) {
            $env['PATH'] = '';
        }

        $env['RAGIE_API_KEY'] = '';
        unset($env['RAGIE_BENCH_ITERATIONS'], $env['RAGIE_BENCH_DELAY'], $env['RAGIE_BENCH_QUERIES']);

        return $env;
    }
}
</document_content>
</document>

<document index="57">
<source>tests/unit/Benchmark/TimingSummaryTest.php</source>
<document_content>
<?php

// this_file: tests/unit/Benchmark/TimingSummaryTest.php

declare(strict_types=1);

namespace Ragie\Tests;

use InvalidArgumentException;
use PHPUnit\Framework\TestCase;
use Ragie\Benchmark\TimingSummary;

final class TimingSummaryTest extends TestCase
{
    public function testFromTimingsCalculatesBasicStats(): void
    {
        $summary = TimingSummary::fromTimings([10, 20, 30, 40]);

        $this->assertSame(25.0, $summary->getAverageMs());
        $this->assertSame(10.0, $summary->getMinMs());
        $this->assertSame(40.0, $summary->getMaxMs());
        $this->assertSame(4, $summary->getCount());
    }

    public function testPercentileInterpolationProducesExpectedValues(): void
    {
        $summary = TimingSummary::fromTimings([10, 20, 30, 40, 50]);

        $this->assertSame(30.0, $summary->getPercentileMs(50));
        $this->assertSame(46.0, $summary->getPercentileMs(90));
        $this->assertSame(50.0, $summary->getPercentileMs(100));

        $expected = [
            'count' => 5,
            'average_ms' => 30.0,
            'min_ms' => 10.0,
            'max_ms' => 50.0,
            'p50_ms' => 30.0,
            'p95_ms' => 48.0,
            'p99_ms' => 49.6,
        ];

        $this->assertEqualsWithDelta($expected, $summary->toArray(), 0.0001);
    }

    public function testInvalidInputsThrowExceptions(): void
    {
        $this->expectException(InvalidArgumentException::class);
        TimingSummary::fromTimings([]);
    }

    public function testNegativeTimingsThrowExceptions(): void
    {
        $this->expectException(InvalidArgumentException::class);
        TimingSummary::fromTimings([-1]);
    }

    public function testInvalidPercentileThrows(): void
    {
        $summary = TimingSummary::fromTimings([1]);

        $this->expectException(InvalidArgumentException::class);
        $summary->getPercentileMs(0);
    }
}
</document_content>
</document>

<document index="58">
<source>tests/unit/Cache/InMemoryCacheTest.php</source>
<document_content>
<?php

// this_file: tests/unit/Cache/InMemoryCacheTest.php

declare(strict_types=1);

namespace Ragie\Tests;

use PHPUnit\Framework\TestCase;
use Ragie\Api\Model\Retrieval;
use Ragie\Api\Model\ScoredChunk;
use Ragie\Cache\InMemoryCache;
use Ragie\RetrievalResult;

final class InMemoryCacheTest extends TestCase
{
    public function testSetAndGetStoresResultUntilExpiry(): void
    {
        $clock = new MutableClock(1_000);
        $cache = new InMemoryCache($clock);
        $result = $this->createResult('cached chunk');

        $cache->set('key', $result, 60);

        $this->assertTrue($cache->has('key'));
        $this->assertSame($result, $cache->get('key'));
    }

    public function testHasReturnsFalseWhenExpired(): void
    {
        $clock = new MutableClock(1_000);
        $cache = new InMemoryCache($clock);
        $result = $this->createResult('expired chunk');

        $cache->set('key', $result, 10);

        $this->assertTrue($cache->has('key'), 'Entry should exist before expiry');

        $clock->advance(11);

        $this->assertFalse($cache->has('key'), 'Entry should expire once TTL passed');
        $this->assertNull($cache->get('key'));
    }

    public function testClearRemovesEntries(): void
    {
        $cache = new InMemoryCache();
        $result = $this->createResult('clear me');

        $cache->set('key', $result, 60);
        $cache->clear();

        $this->assertFalse($cache->has('key'));
        $this->assertNull($cache->get('key'));
    }

    private function createResult(string $text): RetrievalResult
    {
        $chunk = new ScoredChunk();
        $chunk->setText($text);
        $chunk->setScore(0.99);

        $retrieval = new Retrieval();
        $retrieval->setScoredChunks([$chunk]);

        return new RetrievalResult($retrieval);
    }
}

final class MutableClock
{
    public function __construct(private int $value)
    {
    }

    public function __invoke(): int
    {
        return $this->value;
    }

    public function advance(int $seconds): void
    {
        $this->value += $seconds;
    }
}
</document_content>
</document>

<document index="59">
<source>tests/unit/Cache/SimpleCacheAdapterTest.php</source>
<document_content>
<?php

// this_file: tests/unit/Cache/SimpleCacheAdapterTest.php

declare(strict_types=1);

namespace Ragie\Tests;

use PHPUnit\Framework\TestCase;
use Psr\SimpleCache\CacheInterface;
use Ragie\Api\Model\Retrieval;
use Ragie\Api\Model\ScoredChunk;
use Ragie\Cache\SimpleCacheQueryCache;
use Ragie\RetrievalResult;

final class SimpleCacheAdapterTest extends TestCase
{
    public function testGetReturnsValueFromWrappedCache(): void
    {
        $result = $this->createResult('from simple cache');
        $simpleCache = $this->createMock(CacheInterface::class);
        $simpleCache->expects($this->once())
            ->method('get')
            ->with('answer_key')
            ->willReturn($result);

        $adapter = new SimpleCacheQueryCache($simpleCache);

        $this->assertSame($result, $adapter->get('answer_key'));
    }

    public function testSetPersistsValueWithTtl(): void
    {
        $result = $this->createResult('stored');
        $simpleCache = $this->createMock(CacheInterface::class);
        $simpleCache->expects($this->once())
            ->method('set')
            ->with('cache_key', $result, 120);

        $adapter = new SimpleCacheQueryCache($simpleCache);
        $adapter->set('cache_key', $result, 120);
    }

    public function testHasDelegatesToCache(): void
    {
        $simpleCache = $this->createMock(CacheInterface::class);
        $simpleCache->expects($this->once())
            ->method('has')
            ->with('cache_key')
            ->willReturn(true);

        $adapter = new SimpleCacheQueryCache($simpleCache);

        $this->assertTrue($adapter->has('cache_key'));
    }

    public function testClearDelegatesToCache(): void
    {
        $simpleCache = $this->createMock(CacheInterface::class);
        $simpleCache->expects($this->once())
            ->method('clear');

        $adapter = new SimpleCacheQueryCache($simpleCache);
        $adapter->clear();
    }

    private function createResult(string $text): RetrievalResult
    {
        $chunk = new ScoredChunk();
        $chunk->setText($text);
        $chunk->setScore(0.87);

        $retrieval = new Retrieval();
        $retrieval->setScoredChunks([$chunk]);

        return new RetrievalResult($retrieval);
    }
}
</document_content>
</document>

<document index="60">
<source>tests/unit/ClientLoggingTest.php</source>
<document_content>
<?php

// this_file: tests/unit/ClientLoggingTest.php

declare(strict_types=1);

namespace Ragie\Tests;

use PHPUnit\Framework\TestCase;
use Ragie\Api\Api\RetrievalsApi;
use Ragie\Api\Model\Retrieval;
use Ragie\Api\Model\ScoredChunk;
use Ragie\Client;
use Ragie\Tests\Logging\SpyLogger;

final class ClientLoggingTest extends TestCase
{
    public function testRetrieveEmitsStructuredLogs(): void
    {
        $retrieval = new Retrieval([
            'scored_chunks' => [new ScoredChunk(['text' => 'chunk', 'score' => 0.9])],
        ]);

        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->once())
            ->method('retrieve')
            ->willReturn($retrieval);

        $spy = new SpyLogger();
        $client = $this->clientWithMockApi($mockApi);
        $client->withLogger($spy);

        $client->retrieve('Explain Ragie');

        $this->assertGreaterThanOrEqual(2, count($spy->records));
        $this->assertSame('ragie.retrieve.start', $spy->records[0]['message']);
        $this->assertSame('ragie.retrieve.success', $spy->records[1]['message']);
        $this->assertArrayHasKey('chunk_count', $spy->records[1]['context']);
    }

    public function testRetrieveFailureIsLogged(): void
    {
        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->once())
            ->method('retrieve')
            ->willThrowException(new \RuntimeException('boom'));

        $spy = new SpyLogger();
        $client = $this->clientWithMockApi($mockApi);
        $client->withLogger($spy);

        $this->expectException(\RuntimeException::class);
        try {
            $client->retrieve('Trigger failure');
        } finally {
            $this->assertGreaterThanOrEqual(2, count($spy->records));
            $this->assertSame('ragie.retrieve.failure', $spy->records[1]['message']);
            $this->assertSame('error', $spy->records[1]['level']);
        }
    }

    private function clientWithMockApi(RetrievalsApi $api): Client
    {
        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $client->setMockRetrievalsApi($api);

        return $client;
    }
}
</document_content>
</document>

<document index="61">
<source>tests/unit/ClientTest.php</source>
<document_content>
<?php

// this_file: tests/unit/ClientTest.php

declare(strict_types=1);

namespace Ragie\Tests;

use GuzzleHttp\Client as GuzzleClient;
use GuzzleHttp\Promise\Create;
use PHPUnit\Framework\TestCase;
use Ragie\Api\Api\DocumentsApi;
use Ragie\Api\Api\RetrievalsApi;
use Ragie\Api\Api\ResponsesApi;
use Ragie\Api\Configuration;
use Ragie\Api\Model\Retrieval;
use Ragie\Api\Model\ScoredChunk;
use Ragie\Cache\InMemoryCache;
use Ragie\Cache\QueryCacheInterface;
use Ragie\Client;
use Ragie\Exception\InvalidQueryException;
use Ragie\Metrics\CostTracker;
use Ragie\Metrics\MetricsCollector;
use Ragie\RetrievalOptions;
use Ragie\RetrievalResult;

final class ClientTest extends TestCase
{
    public function testConstructorAcceptsApiKey(): void
    {
        $client = new Client('test-api-key');

        $this->assertInstanceOf(Client::class, $client);
    }

    public function testConstructorThrowsExceptionForEmptyApiKey(): void
    {
        $this->expectException(InvalidQueryException::class);
        $this->expectExceptionMessage('Query cannot be empty');

        new Client('');
    }

    public function testConstructorThrowsExceptionForWhitespaceApiKey(): void
    {
        $this->expectException(InvalidQueryException::class);
        $this->expectExceptionMessage('Query cannot consist only of whitespace');

        new Client('   ');
    }

    public function testConstructorSetsBaseUrl(): void
    {
        $client = new Client('test-key', 'https://custom.api.url');
        $config = $client->getConfiguration();

        $this->assertSame('https://custom.api.url', $config->getHost());
    }

    public function testConstructorUsesDefaultBaseUrl(): void
    {
        $client = new Client('test-key');
        $config = $client->getConfiguration();

        $this->assertSame('https://api.ragie.ai', $config->getHost());
    }

    public function testGetConfigurationReturnsConfiguration(): void
    {
        $client = new Client('test-key');
        $config = $client->getConfiguration();

        $this->assertInstanceOf(Configuration::class, $config);
        $this->assertSame('test-key', $config->getAccessToken());
    }

    public function testGetRetrievalsApiReturnsApiInstance(): void
    {
        $client = new Client('test-key');
        $api = $client->getRetrievalsApi();

        $this->assertInstanceOf(RetrievalsApi::class, $api);
    }

    public function testGetRetrievalsApiReturnsSameInstance(): void
    {
        $client = new Client('test-key');
        $api1 = $client->getRetrievalsApi();
        $api2 = $client->getRetrievalsApi();

        $this->assertSame($api1, $api2, 'Should return same instance (lazy initialization)');
    }

    public function testGetResponsesApiReturnsApiInstance(): void
    {
        $client = new Client('test-key');
        $api = $client->getResponsesApi();

        $this->assertInstanceOf(ResponsesApi::class, $api);
    }

    public function testGetResponsesApiReturnsSameInstance(): void
    {
        $client = new Client('test-key');
        $api1 = $client->getResponsesApi();
        $api2 = $client->getResponsesApi();

        $this->assertSame($api1, $api2);
    }

    public function testGetDocumentsApiReturnsApiInstance(): void
    {
        $client = new Client('test-key');
        $api = $client->getDocumentsApi();

        $this->assertInstanceOf(DocumentsApi::class, $api);
    }

    public function testGetDocumentsApiReturnsSameInstance(): void
    {
        $client = new Client('test-key');
        $api1 = $client->getDocumentsApi();
        $api2 = $client->getDocumentsApi();

        $this->assertSame($api1, $api2);
    }

    public function testRetrieveThrowsExceptionForEmptyQuery(): void
    {
        $this->expectException(InvalidQueryException::class);
        $this->expectExceptionMessage('Query cannot be empty');

        $client = new Client('test-key');
        $client->retrieve('');
    }

    public function testRetrieveThrowsExceptionForWhitespaceQuery(): void
    {
        $this->expectException(InvalidQueryException::class);
        $this->expectExceptionMessage('Query cannot consist only of whitespace');

        $client = new Client('test-key');
        $client->retrieve('   ');
    }

    public function testRetrieveReturnsRetrievalResult(): void
    {
        // Create mock retrieval response
        $chunk = new ScoredChunk();
        $chunk->setText('Test chunk');
        $chunk->setScore(0.95);

        $retrieval = new Retrieval();
        $retrieval->setScoredChunks([$chunk]);

        // Create a mock RetrievalsApi
        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->once())
            ->method('retrieve')
            ->willReturn($retrieval);

        // Create a test double of Client that returns our mock API
        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $client->setMockRetrievalsApi($mockApi);

        // Test the retrieve method
        $result = $client->retrieve('test query');

        $this->assertInstanceOf(RetrievalResult::class, $result);
        $this->assertCount(1, $result);
        $topChunk = $result->getTopChunk();
        $this->assertNotNull($topChunk);
        $this->assertSame('Test chunk', $topChunk->getText());
    }

    public function testRetrieveUsesCacheForRepeatedQuery(): void
    {
        $chunk = new ScoredChunk();
        $chunk->setText('Cached chunk');
        $chunk->setScore(0.9);

        $retrieval = new Retrieval();
        $retrieval->setScoredChunks([$chunk]);

        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->once())
            ->method('retrieve')
            ->willReturn($retrieval);

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $client->setMockRetrievalsApi($mockApi);
        $client->withCache(new InMemoryCache());

        $first = $client->retrieve('cache me');
        $second = $client->retrieve('cache me');

        $this->assertSame($first, $second);
    }

    public function testRetrieveUsesDefaultOptions(): void
    {
        // Create empty retrieval
        $retrieval = new Retrieval();

        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->once())
            ->method('retrieve')
            ->with($this->callback(function ($params) {
                // Verify it's a valid RetrieveParams with the query
                return $params->getQuery() === 'test query';
            }))
            ->willReturn($retrieval);

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $client->setMockRetrievalsApi($mockApi);
        $result = $client->retrieve('test query');

        $this->assertInstanceOf(RetrievalResult::class, $result);
    }

    public function testRetrieveUsesDifferentCacheKeyWhenOptionsChange(): void
    {
        $firstChunk = new ScoredChunk();
        $firstChunk->setText('first');
        $firstChunk->setScore(0.8);

        $secondChunk = new ScoredChunk();
        $secondChunk->setText('second');
        $secondChunk->setScore(0.81);

        $firstRetrieval = new Retrieval();
        $firstRetrieval->setScoredChunks([$firstChunk]);

        $secondRetrieval = new Retrieval();
        $secondRetrieval->setScoredChunks([$secondChunk]);

        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->exactly(2))
            ->method('retrieve')
            ->willReturnOnConsecutiveCalls($firstRetrieval, $secondRetrieval);

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $cache = new class () implements QueryCacheInterface {
            /** @var array<string, RetrievalResult> */
            private array $store = [];

            #[\Override]
            public function get(string $key): ?RetrievalResult
            {
                return $this->store[$key] ?? null;
            }

            #[\Override]
            public function set(string $key, RetrievalResult $result, int $ttl): void
            {
                $this->store[$key] = $result;
            }

            #[\Override]
            public function has(string $key): bool
            {
                return array_key_exists($key, $this->store);
            }

            #[\Override]
            public function clear(): void
            {
                $this->store = [];
            }
        };

        $client->setMockRetrievalsApi($mockApi);
        $client->withCache($cache);

        $firstOptions = RetrievalOptions::create()->withTopK(3);
        $secondOptions = RetrievalOptions::create()->withTopK(5);

        $first = $client->retrieve('query', $firstOptions);
        $second = $client->retrieve('query', $secondOptions);

        $this->assertNotSame($first, $second);
        $this->assertSame('first', $first->getTopChunk()?->getText());
        $this->assertSame('second', $second->getTopChunk()?->getText());
    }

    public function testWithCacheFallsBackToDefaultTtlWhenInvalidValueProvided(): void
    {
        $retrieval = new Retrieval();

        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->once())
            ->method('retrieve')
            ->willReturn($retrieval);

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $cache = new class () implements QueryCacheInterface {
            /** @var array<string, RetrievalResult> */
            private array $store = [];

            public ?int $lastTtl = null;

            #[\Override]
            public function get(string $key): ?RetrievalResult
            {
                return $this->store[$key] ?? null;
            }

            #[\Override]
            public function set(string $key, RetrievalResult $result, int $ttl): void
            {
                $this->store[$key] = $result;
                $this->lastTtl = $ttl;
            }

            #[\Override]
            public function has(string $key): bool
            {
                return array_key_exists($key, $this->store);
            }

            #[\Override]
            public function clear(): void
            {
                $this->store = [];
            }
        };

        $client->setMockRetrievalsApi($mockApi);

        $client
            ->withCache($cache, -10)
            ->retrieve('force default ttl');

        $reflection = new \ReflectionClass(Client::class);
        $expectedTtl = $reflection->getConstant('DEFAULT_CACHE_TTL');

        $this->assertSame($expectedTtl, $cache->lastTtl);
    }

    public function testRetrieveUsesProvidedOptions(): void
    {
        $retrieval = new Retrieval();

        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->once())
            ->method('retrieve')
            ->with($this->callback(function ($params) {
                // Verify options were applied
                return $params->getQuery() === 'test query'
                    && $params->getTopK() === 20
                    && $params->getRerank() === true;
            }))
            ->willReturn($retrieval);

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $client->setMockRetrievalsApi($mockApi);

        $options = RetrievalOptions::create()
            ->withTopK(20)
            ->withRerank();

        $result = $client->retrieve('test query', $options);

        $this->assertInstanceOf(RetrievalResult::class, $result);
    }

    public function testConstructorAcceptsCustomHttpClient(): void
    {
        $customClient = new GuzzleClient();
        $client = new Client('test-key', null, $customClient);

        $this->assertInstanceOf(Client::class, $client);
    }

    // Fluent configuration tests

    public function testWithDefaultTopKReturnsClient(): void
    {
        $client = new Client('test-key');
        $result = $client->withDefaultTopK(20);

        $this->assertSame($client, $result, 'Should return self for method chaining');
    }

    public function testWithDefaultRerankReturnsClient(): void
    {
        $client = new Client('test-key');
        $result = $client->withDefaultRerank();

        $this->assertSame($client, $result, 'Should return self for method chaining');
    }

    public function testWithDefaultRerankWithFalseReturnsClient(): void
    {
        $client = new Client('test-key');
        $result = $client->withDefaultRerank(false);

        $this->assertSame($client, $result, 'Should return self for method chaining');
    }

    public function testFluentConfigurationChaining(): void
    {
        $client = new Client('test-key');
        $result = $client
            ->withDefaultTopK(15)
            ->withDefaultRerank(false);

        $this->assertSame($client, $result, 'Should support method chaining');
    }

    public function testRetrieveAppliesDefaultTopK(): void
    {
        $retrieval = new Retrieval();

        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->once())
            ->method('retrieve')
            ->with($this->callback(function ($params) {
                return $params->getQuery() === 'test query'
                    && $params->getTopK() === 25;
            }))
            ->willReturn($retrieval);

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $client->setMockRetrievalsApi($mockApi);
        $client->withDefaultTopK(25);
        $result = $client->retrieve('test query');

        $this->assertInstanceOf(RetrievalResult::class, $result);
    }

    public function testRetrieveAppliesDefaultRerank(): void
    {
        $retrieval = new Retrieval();

        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->once())
            ->method('retrieve')
            ->with($this->callback(function ($params) {
                return $params->getQuery() === 'test query'
                    && $params->getRerank() === true;
            }))
            ->willReturn($retrieval);

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $client->setMockRetrievalsApi($mockApi);
        $client->withDefaultRerank(true);
        $result = $client->retrieve('test query');

        $this->assertInstanceOf(RetrievalResult::class, $result);
    }

    public function testRetrieveAppliesBothDefaults(): void
    {
        $retrieval = new Retrieval();

        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->once())
            ->method('retrieve')
            ->with($this->callback(function ($params) {
                return $params->getQuery() === 'test query'
                    && $params->getTopK() === 30
                    && $params->getRerank() === false;
            }))
            ->willReturn($retrieval);

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $client->setMockRetrievalsApi($mockApi);
        $client
            ->withDefaultTopK(30)
            ->withDefaultRerank(false);
        $result = $client->retrieve('test query');

        $this->assertInstanceOf(RetrievalResult::class, $result);
    }

    public function testRetrieveExplicitOptionsOverrideDefaults(): void
    {
        $retrieval = new Retrieval();

        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->once())
            ->method('retrieve')
            ->with($this->callback(function ($params) {
                // Explicit options should override defaults
                return $params->getQuery() === 'test query'
                    && $params->getTopK() === 50  // Explicit, not default 30
                    && $params->getRerank() === true; // Explicit, not default false
            }))
            ->willReturn($retrieval);

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $client->setMockRetrievalsApi($mockApi);
        $client
            ->withDefaultTopK(30)
            ->withDefaultRerank(false);

        // Explicit options should override defaults
        $options = RetrievalOptions::create()
            ->withTopK(50)
            ->withRerank(true);

        $result = $client->retrieve('test query', $options);

        $this->assertInstanceOf(RetrievalResult::class, $result);
    }

    // Batch retrieval tests

    public function testRetrieveBatchWithEmptyArray(): void
    {
        $client = new Client('test-key');
        $results = $client->retrieveBatch([]);

        $this->assertCount(0, $results);
    }

    public function testRetrieveBatchWithSingleQuery(): void
    {
        $retrieval = new Retrieval();

        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->once())
            ->method('retrieve')
            ->willReturn($retrieval);

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $client->setMockRetrievalsApi($mockApi);
        $results = $client->retrieveBatch(['test query']);

        $this->assertCount(1, $results);
        $this->assertInstanceOf(RetrievalResult::class, $results[0]);
    }

    public function testRetrieveBatchWithMultipleQueries(): void
    {
        $retrieval = new Retrieval();

        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->exactly(3))
            ->method('retrieve')
            ->willReturn($retrieval);

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $client->setMockRetrievalsApi($mockApi);
        $results = $client->retrieveBatch([
            'What is machine learning?',
            'Explain neural networks',
            'How does gradient descent work?'
        ]);

        $this->assertCount(3, $results);
        $this->assertInstanceOf(RetrievalResult::class, $results[0]);
        $this->assertInstanceOf(RetrievalResult::class, $results[1]);
        $this->assertInstanceOf(RetrievalResult::class, $results[2]);
    }

    public function testRetrieveBatchAppliesOptionsToAllQueries(): void
    {
        $retrieval = new Retrieval();

        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->exactly(2))
            ->method('retrieve')
            ->with($this->callback(function ($params) {
                // All queries should have the same options applied
                return $params->getTopK() === 15
                    && $params->getRerank() === true;
            }))
            ->willReturn($retrieval);

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $client->setMockRetrievalsApi($mockApi);

        $options = RetrievalOptions::create()
            ->withTopK(15)
            ->withRerank(true);

        $results = $client->retrieveBatch([
            'Query 1',
            'Query 2'
        ], $options);

        $this->assertCount(2, $results);
    }

    public function testRetrieveBatchAppliesDefaultOptions(): void
    {
        $retrieval = new Retrieval();

        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->exactly(2))
            ->method('retrieve')
            ->with($this->callback(function ($params) {
                // Defaults should be applied to batch queries
                return $params->getTopK() === 40
                    && $params->getRerank() === true;
            }))
            ->willReturn($retrieval);

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $client->setMockRetrievalsApi($mockApi);
        $client
            ->withDefaultTopK(40)
            ->withDefaultRerank(true);

        $results = $client->retrieveBatch([
            'Query 1',
            'Query 2'
        ]);

        $this->assertCount(2, $results);
    }

    public function testRetrieveBatchThrowsOnInvalidQuery(): void
    {
        $this->expectException(InvalidQueryException::class);
        $this->expectExceptionMessage('Query cannot be empty');

        $retrieval = new Retrieval();

        $mockApi = $this->createMock(RetrievalsApi::class);
        // First query succeeds, second query should fail validation
        $mockApi->expects($this->once())
            ->method('retrieve')
            ->willReturn($retrieval);

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $client->setMockRetrievalsApi($mockApi);
        $client->retrieveBatch([
            'Valid query',
            '',  // Empty query should throw during validation
        ]);
    }

    public function testRetrieveBatchPreservesQueryOrder(): void
    {
        // Create distinct retrievals for each query to verify order
        $retrieval1 = new Retrieval();
        $chunk1 = new ScoredChunk();
        $chunk1->setText('Result 1');
        $retrieval1->setScoredChunks([$chunk1]);

        $retrieval2 = new Retrieval();
        $chunk2 = new ScoredChunk();
        $chunk2->setText('Result 2');
        $retrieval2->setScoredChunks([$chunk2]);

        $retrieval3 = new Retrieval();
        $chunk3 = new ScoredChunk();
        $chunk3->setText('Result 3');
        $retrieval3->setScoredChunks([$chunk3]);

        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->exactly(3))
            ->method('retrieve')
            ->willReturnOnConsecutiveCalls($retrieval1, $retrieval2, $retrieval3);

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $client->setMockRetrievalsApi($mockApi);
        $results = $client->retrieveBatch([
            'Query 1',
            'Query 2',
            'Query 3'
        ]);

        $this->assertCount(3, $results);
        $this->assertSame('Result 1', $results[0]->getTopChunk()?->getText());
        $this->assertSame('Result 2', $results[1]->getTopChunk()?->getText());
        $this->assertSame('Result 3', $results[2]->getTopChunk()?->getText());
    }

    public function testRetrieveEmitsMetricsAndCostOnSuccess(): void
    {
        $chunk = new ScoredChunk();
        $chunk->setText('telemetry chunk');
        $chunk->setScore(0.8);

        $retrieval = new Retrieval();
        $retrieval->setScoredChunks([$chunk]);

        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->once())
            ->method('retrieve')
            ->willReturn($retrieval);

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $metrics = new MetricsCollector();
        $costTracker = new CostTracker();

        $client->setMockRetrievalsApi($mockApi);
        $client->withMetricsCollector($metrics)->withCostTracker($costTracker);

        $client->retrieve('telemetry?');

        $events = array_values($metrics->getEvents());
        $this->assertNotEmpty($events);
        $this->assertSame('ragie', $events[0]['source']);
        $this->assertTrue($events[0]['success']);
        $this->assertSame(1, $events[0]['chunk_count']);
        $this->assertSame(1, $costTracker->getRagieQueries());
        $this->assertGreaterThan(0.0, $costTracker->getTotalCost());
    }

    public function testRetrieveEmitsFailureMetricWhenExceptionThrown(): void
    {
        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->once())
            ->method('retrieve')
            ->willThrowException(new \RuntimeException('boom'));

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $metrics = new MetricsCollector();
        $costTracker = new CostTracker();

        $client->setMockRetrievalsApi($mockApi);
        $client->withMetricsCollector($metrics)->withCostTracker($costTracker);

        try {
            $client->retrieve('should fail');
            $this->fail('Expected RuntimeException');
        } catch (\RuntimeException $e) {
            $this->assertSame('boom', $e->getMessage());
        }

        $summary = $metrics->getSummary();
        $this->assertSame(1, $summary['total_requests']);
        $this->assertSame(0, $summary['successful_requests']);
        $this->assertSame(0, $costTracker->getRagieQueries());
    }

    public function testRetrieveAsyncResolvesToRetrievalResult(): void
    {
        $chunk = new ScoredChunk();
        $chunk->setText('Async result');
        $chunk->setScore(0.91);

        $retrieval = new Retrieval();
        $retrieval->setScoredChunks([$chunk]);

        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->once())
            ->method('retrieveAsync')
            ->willReturn(Create::promiseFor($retrieval));

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $client->setMockRetrievalsApi($mockApi);

        $result = $client->retrieveAsync('async query')->wait();

        $this->assertInstanceOf(RetrievalResult::class, $result);
        $this->assertSame('Async result', $result->getTopChunk()?->getText());
    }

    public function testRetrieveAsyncUsesCacheForSubsequentCalls(): void
    {
        $chunk = new ScoredChunk();
        $chunk->setText('Cached async result');
        $chunk->setScore(0.5);

        $retrieval = new Retrieval();
        $retrieval->setScoredChunks([$chunk]);

        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->once())
            ->method('retrieveAsync')
            ->willReturn(Create::promiseFor($retrieval));

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $client->setMockRetrievalsApi($mockApi);
        $client->withCache(new InMemoryCache());

        $first = $client->retrieveAsync('async cached query')->wait();
        $second = $client->retrieveAsync('async cached query')->wait();

        $this->assertSame('Cached async result', $first->getTopChunk()?->getText());
        $this->assertSame('Cached async result', $second->getTopChunk()?->getText());
    }

    public function testRetrieveAsyncPropagatesExceptions(): void
    {
        $mockApi = $this->createMock(RetrievalsApi::class);
        $mockApi->expects($this->once())
            ->method('retrieveAsync')
            ->willReturn(Create::rejectionFor(new \RuntimeException('async boom')));

        $client = new class ('test-key') extends Client {
            private ?RetrievalsApi $mockApi = null;

            public function setMockRetrievalsApi(RetrievalsApi $api): void
            {
                $this->mockApi = $api;
            }

            #[\Override]
            public function getRetrievalsApi(): RetrievalsApi
            {
                return $this->mockApi ?? parent::getRetrievalsApi();
            }
        };

        $client->setMockRetrievalsApi($mockApi);

        $this->expectException(\RuntimeException::class);
        $this->expectExceptionMessage('async boom');

        $client->retrieveAsync('fails now')->wait();
    }

    public function testRetrieveConcurrentReturnsResultsInOriginalOrder(): void
    {
        $client = new class ('test-key') extends Client {
            #[\Override]
            public function retrieveAsync(string $query, ?RetrievalOptions $options = null): \GuzzleHttp\Promise\PromiseInterface
            {
                $chunk = new ScoredChunk();
                $chunk->setText($query);
                $retrieval = new Retrieval();
                $retrieval->setScoredChunks([$chunk]);

                return Create::promiseFor(new RetrievalResult($retrieval));
            }
        };

        $queries = ['first question', 'second question', 'third question'];

        $results = $client->retrieveConcurrent($queries);

        $this->assertCount(3, $results);
        $this->assertSame('first question', $results[0]->getTopChunk()?->getText());
        $this->assertSame('second question', $results[1]->getTopChunk()?->getText());
        $this->assertSame('third question', $results[2]->getTopChunk()?->getText());
    }
}
</document_content>
</document>

<document index="62">
<source>tests/unit/ClientValidationTest.php</source>
<document_content>
<?php

// this_file: tests/unit/ClientValidationTest.php

declare(strict_types=1);

namespace Ragie\Tests;

use PHPUnit\Framework\TestCase;
use Ragie\Client;
use Ragie\Exception\InvalidQueryException;

class ClientValidationTest extends TestCase
{
    private Client $client;

    #[\Override]
    protected function setUp(): void
    {
        // Create client with dummy API key (won't make real requests in validation tests)
        $this->client = new Client('test_api_key_for_validation');
    }

    public function test_retrieve_throws_on_empty_query(): void
    {
        $this->expectException(InvalidQueryException::class);
        $this->expectExceptionMessage('Query cannot be empty');

        $this->client->retrieve('');
    }

    public function test_retrieve_throws_on_whitespace_only_query(): void
    {
        $this->expectException(InvalidQueryException::class);
        $this->expectExceptionMessage('Query cannot consist only of whitespace');

        $this->client->retrieve('   ');
    }

    public function test_retrieve_throws_on_query_exceeding_max_length(): void
    {
        $this->expectException(InvalidQueryException::class);
        $this->expectExceptionMessage('Query length (10001 characters) exceeds maximum allowed length (10000 characters)');

        // Create a query that's exactly 10001 characters
        $longQuery = str_repeat('a', 10001);
        $this->client->retrieve($longQuery);
    }

    public function test_retrieve_accepts_query_at_max_length(): void
    {
        // Create a query that's exactly 10000 characters
        $maxQuery = str_repeat('a', 10000);

        // Should not throw InvalidQueryException (validation passes)
        // Will throw API exception, but that's expected
        try {
            $this->client->retrieve($maxQuery);
            $this->fail('Expected API exception to be thrown');
        } catch (InvalidQueryException $e) {
            $this->fail('Query at max length should pass validation, got: ' . $e->getMessage());
        } catch (\Throwable $e) {
            // Expected - API call fails, but validation passed
            $this->assertNotInstanceOf(InvalidQueryException::class, $e);
        }
    }

    public function test_retrieve_accepts_valid_short_query(): void
    {
        // Valid query should pass validation (will fail at API call)
        try {
            $this->client->retrieve('valid query');
            $this->fail('Expected API exception to be thrown');
        } catch (InvalidQueryException $e) {
            $this->fail('Valid query should pass validation, got: ' . $e->getMessage());
        } catch (\Throwable $e) {
            // Expected - API call fails, but validation passed
            $this->assertNotInstanceOf(InvalidQueryException::class, $e);
        }
    }

    public function test_retrieve_throws_on_control_characters(): void
    {
        $this->expectException(InvalidQueryException::class);
        $this->expectExceptionMessage('control characters');

        $this->client->retrieve("Hello\x07World");
    }
}
</document_content>
</document>

<document index="63">
<source>tests/unit/Dev/Coverage/CoverageThresholdCheckerTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: ragie-php/tests/unit/Dev/Coverage/CoverageThresholdCheckerTest.php

namespace Ragie\Tests\Unit\Dev\Coverage;

use PHPUnit\Framework\TestCase;
use Ragie\Dev\Coverage\CoverageThresholdChecker;
use RuntimeException;

final class CoverageThresholdCheckerTest extends TestCase
{
    private CoverageThresholdChecker $checker;

    #[\Override]
    protected function setUp(): void
    {
        $this->checker = new CoverageThresholdChecker();
    }

    public function testCalculate_whenReportValid_thenReturnsRoundedPercent(): void
    {
        $path = __DIR__ . '/../../../fixtures/coverage/high.xml';
        $coverage = $this->checker->calculate($path);

        self::assertSame(95.0, $coverage, 'Expected to return rounded coverage percentage.');
    }

    public function testCalculate_whenStatementsZero_thenReturnsHundredPercent(): void
    {
        $path = __DIR__ . '/../../../fixtures/coverage/empty.xml';
        $coverage = $this->checker->calculate($path);

        self::assertSame(100.0, $coverage, 'No statements should be treated as full coverage.');
    }

    public function testAssertMinimum_whenBelowThreshold_thenThrows(): void
    {
        $path = __DIR__ . '/../../../fixtures/coverage/low.xml';

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('Coverage 60.00% is below the required 80.00% threshold.');

        $this->checker->assertMinimum($path, 80.0);
    }

    public function testAssertMinimum_whenWithinThreshold_thenReturnsCoverage(): void
    {
        $path = __DIR__ . '/../../../fixtures/coverage/high.xml';

        $result = $this->checker->assertMinimum($path, 80.0);

        self::assertSame(95.0, $result);
    }

    public function testAssertMinimum_whenThresholdOutsideBounds_thenThrows(): void
    {
        $path = __DIR__ . '/../../../fixtures/coverage/high.xml';

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('Coverage threshold must be between 0 and 100.');

        $this->checker->assertMinimum($path, 120.0);
    }
}
</document_content>
</document>

<document index="64">
<source>tests/unit/Examples/ChunkFormatterTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: tests/unit/Examples/ChunkFormatterTest.php

namespace Ragie\Tests\Examples;

use PHPUnit\Framework\TestCase;
use Ragie\Api\Model\ScoredChunk;
use Ragie\Examples\ChunkFormatter;

final class ChunkFormatterTest extends TestCase
{
    public function testFormatChunkTruncatesTextAndDisplaysMetadata(): void
    {
        $chunk = new ScoredChunk();
        $chunk->setText(str_repeat('A', 200));
        $chunk->setDocumentName('Docs/Guide.md');
        $chunk->setDocumentId('doc-123');
        $chunk->setScore(0.95234);

        $formatted = ChunkFormatter::formatChunk($chunk, 1, 50);

        $this->assertStringStartsWith('1. [Docs/Guide.md] score=0.952', $formatted);
        $this->assertStringContainsString('Doc ID: doc-123', $formatted);
        $this->assertStringContainsString('â€¦', $formatted, 'Long text should be truncated with ellipsis');
    }

    public function testFormatChunkHandlesMissingFieldsGracefully(): void
    {
        $chunk = new ScoredChunk();
        // Leave text, document, and score unset to simulate incomplete payload

        $formatted = ChunkFormatter::formatChunk($chunk, 3);

        $this->assertStringStartsWith('3. [Unknown document] score=N/A', $formatted);
        $this->assertStringContainsString('[empty chunk text]', $formatted);
    }

    public function testFormatChunkNormalizesIndexAndLength(): void
    {
        $chunk = new ScoredChunk();
        $chunk->setText('Short text');

        $formatted = ChunkFormatter::formatChunk($chunk, 0, -10);

        $this->assertStringStartsWith('1.', $formatted, 'Index should be normalized to at least 1');
        $this->assertStringContainsString('Short text', $formatted);
    }
}
</document_content>
</document>

<document index="65">
<source>tests/unit/Http/ResponseFormatterTest.php</source>
<document_content>
<?php

declare(strict_types=1);

/**
 * this_file: tests/Http/ResponseFormatterTest.php
 */

namespace Ragie\Tests\Http;

use PHPUnit\Framework\TestCase;
use Ragie\Http\ResponseFormatter;

// Define constant to prevent exit() in tests
if (!defined('PHPUNIT_RUNNING')) {
    define('PHPUNIT_RUNNING', true);
}

final class ResponseFormatterTest extends TestCase
{
    public function testSuccessJsonResponse(): void
    {
        $output = ResponseFormatter::success(['result' => 'test data'], 'json');
        $decoded = json_decode($output, true);

        $this->assertTrue($decoded['success']);
        $this->assertEquals(['result' => 'test data'], $decoded['data']);
    }

    public function testSuccessTextResponse(): void
    {
        $output = ResponseFormatter::success('Plain text result', 'text');

        $this->assertEquals('Plain text result', $output);
    }

    public function testSuccessWithArrayInTextMode(): void
    {
        $output = ResponseFormatter::success(['key' => 'value'], 'text');

        $this->assertStringContainsString('[key]', $output);
        $this->assertStringContainsString('value', $output);
    }

    public function testErrorJsonResponse(): void
    {
        $output = ResponseFormatter::error('Test error message', 404, 'json');
        $decoded = json_decode($output, true);

        $this->assertFalse($decoded['success']);
        $this->assertEquals('Test error message', $decoded['error']);
        $this->assertArrayNotHasKey('details', $decoded);
    }

    public function testErrorJsonWithDetails(): void
    {
        $output = ResponseFormatter::error(
            'Validation failed',
            400,
            'json',
            ['field' => 'email', 'reason' => 'invalid format']
        );
        $decoded = json_decode($output, true);

        $this->assertFalse($decoded['success']);
        $this->assertEquals('Validation failed', $decoded['error']);
        $this->assertArrayHasKey('details', $decoded);
        $this->assertEquals('email', $decoded['details']['field']);
        $this->assertEquals('invalid format', $decoded['details']['reason']);
    }

    public function testErrorTextResponse(): void
    {
        $output = ResponseFormatter::error('Simple error', 500, 'text');

        $this->assertStringStartsWith('Error: Simple error', $output);
        $this->assertStringNotContainsString('Details:', $output);
    }

    public function testErrorTextWithDetails(): void
    {
        $output = ResponseFormatter::error(
            'Database error',
            500,
            'text',
            ['query' => 'SELECT *', 'code' => 1045]
        );

        $this->assertStringContainsString('Error: Database error', $output);
        $this->assertStringContainsString('Details:', $output);
        $this->assertStringContainsString('query', $output);
        $this->assertStringContainsString('SELECT *', $output);
    }

    public function testSuccessDefaultFormat(): void
    {
        $output = ResponseFormatter::success(['test' => 'data']);

        $this->assertJson($output);
    }
}
</document_content>
</document>

<document index="66">
<source>tests/unit/Metrics/CostTrackerTest.php</source>
<document_content>
<?php

// this_file: tests/unit/Metrics/CostTrackerTest.php

declare(strict_types=1);

namespace Ragie\Tests;

use PHPUnit\Framework\TestCase;
use Ragie\Metrics\CostTracker;

final class CostTrackerTest extends TestCase
{
    public function testRecordRagieQueryAccumulatesCost(): void
    {
        $tracker = new CostTracker();

        $tracker->recordRagieQuery();
        $tracker->recordRagieQuery(0.005);

        $this->assertSame(2, $tracker->getRagieQueries());
        $this->assertGreaterThan(0.0, $tracker->getTotalCost());

        $summary = $tracker->getSummary();
        $this->assertSame(2, $summary['ragie_queries']);
        $this->assertEquals($tracker->getTotalCost(), $summary['total_cost']);
    }

}
</document_content>
</document>

<document index="67">
<source>tests/unit/Metrics/MetricsCollectorTest.php</source>
<document_content>
<?php

// this_file: tests/unit/Metrics/MetricsCollectorTest.php

declare(strict_types=1);

namespace Ragie\Tests;

use PHPUnit\Framework\TestCase;
use Ragie\Metrics\MetricsCollector;

final class MetricsCollectorTest extends TestCase
{
    public function testRecordRetrievalAndSummary(): void
    {
        $collector = new MetricsCollector();
        $collector->recordRetrieval('ragie', 120.4, 3, true);
        $collector->recordRetrieval('ragie', 250, 0, false);

        $events = $collector->getEvents();

        $this->assertCount(2, $events);
        $this->assertSame('ragie', $events[0]['source']);
        $this->assertSame(3, $events[0]['chunk_count']);
        $this->assertFalse($events[1]['success']);

        $summary = $collector->getSummary();
        $this->assertSame(2, $summary['total_requests']);
        $this->assertSame(1, $summary['successful_requests']);
        $this->assertGreaterThan(0, $summary['avg_duration_ms']);
    }
}
</document_content>
</document>

<document index="68">
<source>tests/unit/OpenApiArtifactsTest.php</source>
<document_content>
<?php

// this_file: tests/unit/OpenApiArtifactsTest.php

declare(strict_types=1);

use PHPUnit\Framework\TestCase;

/**
 * @coversNothing
 * @psalm-suppress UnusedClass Tests are discovered via PHPUnit configuration.
 */
final class OpenApiArtifactsTest extends TestCase
{
    private function projectRoot(): string
    {
        return dirname(__DIR__, 2);
    }

    public function testOpenApiChecksumMatchesSpec(): void
    {
        $specPath = $this->projectRoot() . '/openapi.json';
        $checksumPath = $this->projectRoot() . '/openapi.sha256';

        self::assertFileExists($specPath, 'Spec file openapi.json is missing.');
        self::assertFileExists($checksumPath, 'Checksum file openapi.sha256 is missing.');

        $expected = trim((string) file_get_contents($checksumPath));
        $actual = hash_file('sha256', $specPath);

        self::assertSame(
            $expected,
            $actual,
            'openapi.sha256 checksum does not match the local spec. Regenerate the checksum after updating the spec.'
        );
    }

    public function testOpenApiToolsConfigConfiguresRagieNamespaces(): void
    {
        $configPath = $this->projectRoot() . '/openapitools.json';
        self::assertFileExists($configPath, 'Expected openapitools.json to be present.');

        $config = json_decode((string) file_get_contents($configPath), true, 512, JSON_THROW_ON_ERROR);

        $additional = $config['additionalProperties'] ?? [];
        self::assertSame('Ragie\\Api', $additional['invokerPackage'] ?? null, 'invokerPackage must be Ragie\\Api');
        self::assertSame('Api', $additional['apiPackage'] ?? null, 'apiPackage must be Api');
        self::assertSame('Model', $additional['modelPackage'] ?? null, 'modelPackage must be Model');
        self::assertArrayHasKey('packageVersion', $additional, 'packageVersion must be pinned to track releases.');

        $global = $config['globalProperties'] ?? [];
        self::assertSame('false', $global['apiDocs'] ?? null, 'Generator should skip API docs output.');
        self::assertSame('false', $global['modelDocs'] ?? null, 'Generator should skip model docs output.');
        self::assertSame('php', $config['generatorName'] ?? null, 'generatorName must be php.');
    }

    public function testBuildScriptUsesLocalSpec(): void
    {
        $scriptPath = $this->projectRoot() . '/build_generatapi.sh';
        self::assertFileExists($scriptPath, 'build_generatapi.sh is missing.');

        $contents = (string) file_get_contents($scriptPath);
        self::assertStringContainsString('openapi.json', $contents, 'Script must use the local openapi.json.');
        self::assertStringNotContainsString('https://api.ragie.ai/openapi.json', $contents, 'Script should not pull the remote spec directly.');
    }

    public function testRegenStampTracksChecksumAndTimestamp(): void
    {
        $stampPath = $this->projectRoot() . '/src/Ragie/Api/.regen-stamp';
        self::assertFileExists($stampPath, '.regen-stamp is missing. Run build_generatapi.sh after updating the spec.');

        $stampContent = trim((string) file_get_contents($stampPath));
        self::assertNotSame('', $stampContent, '.regen-stamp must contain metadata.');

        $data = [];
        foreach (preg_split('/\r\n|\r|\n/', $stampContent) as $line) {
            if ($line === '') {
                continue;
            }
            [$key, $value] = array_pad(explode('=', $line, 2), 2, '');
            $data[$key] = $value;
        }

        self::assertArrayHasKey('spec_sha', $data, '.regen-stamp must record spec_sha.');
        self::assertArrayHasKey('generated_at', $data, '.regen-stamp must record generated_at timestamp.');

        $expectedSha = trim((string) file_get_contents($this->projectRoot() . '/openapi.sha256'));
        self::assertSame(
            $expectedSha,
            $data['spec_sha'],
            '.regen-stamp spec_sha must match openapi.sha256.'
        );

        $timestamp = \DateTimeImmutable::createFromFormat(\DateTimeInterface::ATOM, $data['generated_at']);
        self::assertInstanceOf(
            \DateTimeImmutable::class,
            $timestamp,
            '.regen-stamp generated_at must be a valid ISO-8601 timestamp.'
        );
    }
}
</document_content>
</document>

<document index="69">
<source>tests/unit/RetrievalOptionsTest.php</source>
<document_content>
<?php

// this_file: tests/RetrievalOptionsTest.php

declare(strict_types=1);

namespace Ragie\Tests;

use PHPUnit\Framework\TestCase;
use Ragie\Exception\InvalidParameterException;
use Ragie\RetrievalOptions;

final class RetrievalOptionsTest extends TestCase
{
    public function testCreateReturnsNewInstance(): void
    {
        $options = RetrievalOptions::create();

        $this->assertInstanceOf(RetrievalOptions::class, $options);
    }

    public function testWithTopKReturnsNewInstance(): void
    {
        $original = RetrievalOptions::create();
        $modified = $original->withTopK(20);

        $this->assertNotSame($original, $modified, 'withTopK should return a new instance');
    }

    public function testWithTopKInvalidValue(): void
    {
        $this->expectException(InvalidParameterException::class);
        $this->expectExceptionMessage('topK must be a positive integer, got 0');

        RetrievalOptions::create()->withTopK(0);
    }

    public function testWithTopKNegativeValue(): void
    {
        $this->expectException(InvalidParameterException::class);
        $this->expectExceptionMessage('topK must be a positive integer, got -1');

        RetrievalOptions::create()->withTopK(-1);
    }

    public function testWithFilterReturnsNewInstance(): void
    {
        $original = RetrievalOptions::create();
        $modified = $original->withFilter(['category' => 'docs']);

        $this->assertNotSame($original, $modified);
    }

    public function testWithRerankReturnsNewInstance(): void
    {
        $original = RetrievalOptions::create();
        $modified = $original->withRerank();

        $this->assertNotSame($original, $modified);
    }

    public function testWithMaxChunksPerDocumentReturnsNewInstance(): void
    {
        $original = RetrievalOptions::create();
        $modified = $original->withMaxChunksPerDocument(5);

        $this->assertNotSame($original, $modified);
    }

    public function testWithMaxChunksPerDocumentInvalidValue(): void
    {
        $this->expectException(InvalidParameterException::class);
        $this->expectExceptionMessage('maxChunksPerDocument must be a positive integer, got 0');

        RetrievalOptions::create()->withMaxChunksPerDocument(0);
    }

    public function testWithPartitionReturnsNewInstance(): void
    {
        $original = RetrievalOptions::create();
        $modified = $original->withPartition('test-partition');

        $this->assertNotSame($original, $modified);
    }

    public function testWithPartitionEmptyString(): void
    {
        $this->expectException(InvalidParameterException::class);
        $this->expectExceptionMessage('partition cannot be empty');

        RetrievalOptions::create()->withPartition('');
    }

    public function testWithPartitionWhitespace(): void
    {
        $this->expectException(InvalidParameterException::class);
        $this->expectExceptionMessage('partition cannot consist only of whitespace');

        RetrievalOptions::create()->withPartition('   ');
    }

    public function testWithRecencyBiasReturnsNewInstance(): void
    {
        $original = RetrievalOptions::create();
        $modified = $original->withRecencyBias();

        $this->assertNotSame($original, $modified);
    }

    public function testMethodChaining(): void
    {
        $options = RetrievalOptions::create()
            ->withTopK(20)
            ->withRerank()
            ->withFilter(['category' => 'docs'])
            ->withMaxChunksPerDocument(3)
            ->withPartition('test')
            ->withRecencyBias();

        $this->assertInstanceOf(RetrievalOptions::class, $options);
    }

    public function testToRetrieveParamsWithMinimalOptions(): void
    {
        $options = RetrievalOptions::create();
        $params = $options->toRetrieveParams('test query');

        $this->assertSame('test query', $params->getQuery());
    }

    public function testToRetrieveParamsWithAllOptions(): void
    {
        $filter = ['category' => ['$in' => ['sales', 'marketing']]];

        $options = RetrievalOptions::create()
            ->withTopK(25)
            ->withFilter($filter)
            ->withRerank(true)
            ->withMaxChunksPerDocument(5)
            ->withPartition('my-partition')
            ->withRecencyBias(true);

        $params = $options->toRetrieveParams('my query');

        $this->assertSame('my query', $params->getQuery());
        $this->assertSame(25, $params->getTopK());
        $this->assertSame($filter, $params->getFilter());
        $this->assertTrue($params->getRerank());
        $this->assertSame(5, $params->getMaxChunksPerDocument());
        $this->assertSame('my-partition', $params->getPartition());
        $this->assertTrue($params->getRecencyBias());
    }

    public function testToRetrieveParamsWithRerankFalse(): void
    {
        $options = RetrievalOptions::create()
            ->withRerank(false);

        $params = $options->toRetrieveParams('query');

        $this->assertFalse($params->getRerank());
    }

    public function testToRetrieveParamsWithRecencyBiasFalse(): void
    {
        $options = RetrievalOptions::create()
            ->withRecencyBias(false);

        $params = $options->toRetrieveParams('query');

        $this->assertFalse($params->getRecencyBias());
    }
}
</document_content>
</document>

<document index="70">
<source>tests/unit/RetrievalResultTest.php</source>
<document_content>
<?php

// this_file: tests/RetrievalResultTest.php

declare(strict_types=1);

namespace Ragie\Tests;

use PHPUnit\Framework\TestCase;
use Ragie\Api\Model\Retrieval;
use Ragie\Api\Model\ScoredChunk;
use Ragie\RetrievalResult;

final class RetrievalResultTest extends TestCase
{
    public function testConstructorAcceptsRetrieval(): void
    {
        $retrieval = new Retrieval();
        $result = new RetrievalResult($retrieval);

        $this->assertInstanceOf(RetrievalResult::class, $result);
    }

    public function testGetChunksReturnsEmptyArrayForNoResults(): void
    {
        $retrieval = new Retrieval();
        $result = new RetrievalResult($retrieval);

        $this->assertSame([], $result->getChunks());
    }

    public function testGetChunksReturnsArrayOfScoredChunks(): void
    {
        $chunk1 = new ScoredChunk();
        $chunk1->setText('First chunk');
        $chunk1->setScore(0.95);

        $chunk2 = new ScoredChunk();
        $chunk2->setText('Second chunk');
        $chunk2->setScore(0.85);

        $retrieval = new Retrieval();
        $retrieval->setScoredChunks([$chunk1, $chunk2]);

        $result = new RetrievalResult($retrieval);
        $chunks = $result->getChunks();

        $this->assertCount(2, $chunks);
        $this->assertInstanceOf(ScoredChunk::class, $chunks[0]);
        $this->assertInstanceOf(ScoredChunk::class, $chunks[1]);
        $this->assertSame('First chunk', $chunks[0]->getText());
        $this->assertSame('Second chunk', $chunks[1]->getText());
    }

    public function testGetTopChunkReturnsNullForEmptyResult(): void
    {
        $retrieval = new Retrieval();
        $result = new RetrievalResult($retrieval);

        $this->assertNull($result->getTopChunk());
    }

    public function testGetTopChunkReturnsFirstChunk(): void
    {
        $chunk1 = new ScoredChunk();
        $chunk1->setText('Best match');
        $chunk1->setScore(0.98);

        $chunk2 = new ScoredChunk();
        $chunk2->setText('Second match');
        $chunk2->setScore(0.75);

        $retrieval = new Retrieval();
        $retrieval->setScoredChunks([$chunk1, $chunk2]);

        $result = new RetrievalResult($retrieval);
        $topChunk = $result->getTopChunk();

        $this->assertInstanceOf(ScoredChunk::class, $topChunk);
        $this->assertSame('Best match', $topChunk->getText());
        $this->assertSame(0.98, $topChunk->getScore());
    }

    public function testGetChunkTextsReturnsEmptyArrayForNoResults(): void
    {
        $retrieval = new Retrieval();
        $result = new RetrievalResult($retrieval);

        $this->assertSame([], $result->getChunkTexts());
    }

    public function testGetChunkTextsExtractsTextStrings(): void
    {
        $chunk1 = new ScoredChunk();
        $chunk1->setText('First text');

        $chunk2 = new ScoredChunk();
        $chunk2->setText('Second text');

        $chunk3 = new ScoredChunk();
        $chunk3->setText('Third text');

        $retrieval = new Retrieval();
        $retrieval->setScoredChunks([$chunk1, $chunk2, $chunk3]);

        $result = new RetrievalResult($retrieval);
        $texts = $result->getChunkTexts();

        $this->assertSame(['First text', 'Second text', 'Third text'], $texts);
    }

    public function testGetDocumentIdsReturnsEmptyArrayForNoResults(): void
    {
        $retrieval = new Retrieval();
        $result = new RetrievalResult($retrieval);

        $this->assertSame([], $result->getDocumentIds());
    }

    public function testGetDocumentIdsReturnsUniqueIds(): void
    {
        $chunk1 = new ScoredChunk();
        $chunk1->setDocumentId('doc-123');

        $chunk2 = new ScoredChunk();
        $chunk2->setDocumentId('doc-456');

        $chunk3 = new ScoredChunk();
        $chunk3->setDocumentId('doc-123'); // Duplicate

        $retrieval = new Retrieval();
        $retrieval->setScoredChunks([$chunk1, $chunk2, $chunk3]);

        $result = new RetrievalResult($retrieval);
        $ids = $result->getDocumentIds();

        $this->assertCount(2, $ids);
        $this->assertContains('doc-123', $ids);
        $this->assertContains('doc-456', $ids);
    }

    public function testIsEmptyReturnsTrueForNoResults(): void
    {
        $retrieval = new Retrieval();
        $result = new RetrievalResult($retrieval);

        $this->assertTrue($result->isEmpty());
    }

    public function testIsEmptyReturnsFalseForResults(): void
    {
        $chunk = new ScoredChunk();
        $chunk->setText('Some text');

        $retrieval = new Retrieval();
        $retrieval->setScoredChunks([$chunk]);

        $result = new RetrievalResult($retrieval);

        $this->assertFalse($result->isEmpty());
    }

    public function testCountReturnsZeroForEmptyResult(): void
    {
        $retrieval = new Retrieval();
        $result = new RetrievalResult($retrieval);

        $this->assertSame(0, $result->count());
        $this->assertCount(0, $result); // Test Countable interface
    }

    public function testCountReturnsCorrectNumber(): void
    {
        $chunk1 = new ScoredChunk();
        $chunk2 = new ScoredChunk();
        $chunk3 = new ScoredChunk();

        $retrieval = new Retrieval();
        $retrieval->setScoredChunks([$chunk1, $chunk2, $chunk3]);

        $result = new RetrievalResult($retrieval);

        $this->assertSame(3, $result->count());
        $this->assertCount(3, $result); // Test Countable interface
    }

    public function testGetUnderlyingRetrievalReturnsOriginalObject(): void
    {
        $retrieval = new Retrieval();
        $result = new RetrievalResult($retrieval);

        $this->assertSame($retrieval, $result->getUnderlyingRetrieval());
    }

    public function testGetChunkTextsHandlesNullText(): void
    {
        $chunk = new ScoredChunk();
        // Don't set text - should be null

        $retrieval = new Retrieval();
        $retrieval->setScoredChunks([$chunk]);

        $result = new RetrievalResult($retrieval);
        $texts = $result->getChunkTexts();

        $this->assertSame([''], $texts);
    }

    public function testGetDocumentIdsFiltersOutNullIds(): void
    {
        $chunk1 = new ScoredChunk();
        $chunk1->setDocumentId('doc-123');

        $chunk2 = new ScoredChunk();
        // Don't set document ID - should be null

        $retrieval = new Retrieval();
        $retrieval->setScoredChunks([$chunk1, $chunk2]);

        $result = new RetrievalResult($retrieval);
        $ids = $result->getDocumentIds();

        $this->assertSame(['doc-123'], $ids);
    }

    public function testHandlesNullScoredChunksGracefully(): void
    {
        // Simulates API returning null instead of an array
        $retrieval = new Retrieval();
        // Don't set scored chunks - will be null

        $result = new RetrievalResult($retrieval);

        // Should not throw exceptions and return empty arrays
        $this->assertSame([], $result->getChunks());
        $this->assertSame([], $result->getChunkTexts());
        $this->assertSame([], $result->getDocumentIds());
        $this->assertNull($result->getTopChunk());
        $this->assertTrue($result->isEmpty());
        $this->assertSame(0, $result->count());
    }

    public function testHandlesChunksWithAllNullFieldsGracefully(): void
    {
        // Simulates API returning chunks with null fields
        $chunk1 = new ScoredChunk();
        // Don't set any fields - all null

        $chunk2 = new ScoredChunk();
        // Don't set any fields - all null

        $retrieval = new Retrieval();
        $retrieval->setScoredChunks([$chunk1, $chunk2]);

        $result = new RetrievalResult($retrieval);

        // Should handle null fields without throwing exceptions
        $this->assertCount(2, $result->getChunks());
        $this->assertSame(['', ''], $result->getChunkTexts());
        $this->assertSame([], $result->getDocumentIds());
        $this->assertFalse($result->isEmpty());
        $this->assertSame(2, $result->count());
    }

    public function testHandlesMixedNullAndValidDataGracefully(): void
    {
        // Mix of valid data and nulls - simulates partially malformed API response
        $chunk1 = new ScoredChunk();
        $chunk1->setText('Valid text');
        $chunk1->setDocumentId('doc-1');
        $chunk1->setScore(0.95);

        $chunk2 = new ScoredChunk();
        // Only set score, leave others null
        $chunk2->setScore(0.85);

        $chunk3 = new ScoredChunk();
        $chunk3->setText('Another valid text');
        // No document ID or score

        $retrieval = new Retrieval();
        $retrieval->setScoredChunks([$chunk1, $chunk2, $chunk3]);

        $result = new RetrievalResult($retrieval);

        // Should extract what's available and handle nulls gracefully
        $this->assertCount(3, $result->getChunks());
        $this->assertSame(['Valid text', '', 'Another valid text'], $result->getChunkTexts());
        $this->assertSame(['doc-1'], $result->getDocumentIds());
        $this->assertFalse($result->isEmpty());
        $this->assertSame(3, $result->count());
    }
}
</document_content>
</document>

<document index="71">
<source>tests/unit/Validation/InputSanitizerTest.php</source>
<document_content>
<?php

declare(strict_types=1);

/**
 * this_file: tests/unit/Validation/InputSanitizerTest.php
 */

namespace Ragie\Tests\Unit\Validation;

use PHPUnit\Framework\TestCase;
use Ragie\Exception\InvalidQueryException;
use Ragie\Validation\InputSanitizer;

final class InputSanitizerTest extends TestCase
{
    public function testSanitizeRemovesNullBytesAndTrims(): void
    {
        $dirty = "  \0Hello World\0  ";

        $sanitized = InputSanitizer::sanitize($dirty);

        $this->assertSame('Hello World', $sanitized);
    }

    public function testSanitizeLeavesAllowedWhitespaceInside(): void
    {
        $dirty = " Hello   Ragie \t Rocks ";

        $sanitized = InputSanitizer::sanitize($dirty);

        $this->assertSame("Hello   Ragie \t Rocks", $sanitized);
    }

    public function testSanitizeAndValidateReturnsCleanedString(): void
    {
        $result = InputSanitizer::sanitizeAndValidate("  Ask\nRagie  ");

        $this->assertSame("Ask\nRagie", $result);
    }

    public function testSanitizeAndValidateRejectsControlCharacters(): void
    {
        $this->expectException(InvalidQueryException::class);
        $this->expectExceptionMessage('control characters');

        InputSanitizer::sanitizeAndValidate("Hello\x07World");
    }

    public function testSanitizeAndValidateRejectsWhitespaceOnlyInput(): void
    {
        $this->expectException(InvalidQueryException::class);
        $this->expectExceptionMessage('whitespace');

        InputSanitizer::sanitizeAndValidate("    ");
    }

    public function testSanitizeAndValidateRejectsEmptyInput(): void
    {
        $this->expectException(InvalidQueryException::class);
        $this->expectExceptionMessage('empty');

        InputSanitizer::sanitizeAndValidate('');
    }

    public function testSanitizeAndValidateRespectsMaxLength(): void
    {
        $this->expectException(InvalidQueryException::class);
        $this->expectExceptionMessage('exceeds');

        InputSanitizer::sanitizeAndValidate(str_repeat('a', 5), 4);
    }
}
</document_content>
</document>

<document index="72">
<source>verify-deployment.php</source>
<document_content>
#!/usr/bin/env php
<?php

// this_file: verify-deployment.php

declare(strict_types=1);

/**
 * Post-Deployment Verification Script
 *
 * Tests remote RAG endpoints to ensure deployment was successful.
 * Run this after deploying to production to verify functionality.
 *
 * Usage:
 *   php verify-deployment.php [base-url]
 *
 * Example:
 *   php verify-deployment.php https://ask.vexy.art
 */

const TIMEOUT_SECONDS = 30;
const TEST_QUERY = 'What is Ragie?';

class Colors
{
    public const RESET = "\033[0m";
    public const RED = "\033[31m";
    public const GREEN = "\033[32m";
    public const YELLOW = "\033[33m";
    public const BLUE = "\033[34m";
    public const BOLD = "\033[1m";
}

class VerificationTest
{
    public function __construct(
        public readonly string $name,
        public readonly string $url,
        public readonly int $expectedStatus,
        public readonly array $expectedFields = [],
        public readonly ?int $maxResponseTime = null
    ) {
    }
}

function colored(string $text, string $color): string
{
    return $color . $text . Colors::RESET;
}

function success(string $message): void
{
    echo colored('âœ“', Colors::GREEN) . ' ' . $message . PHP_EOL;
}

function error(string $message): void
{
    echo colored('âœ—', Colors::RED) . ' ' . $message . PHP_EOL;
}

function info(string $message): void
{
    echo colored('â„¹', Colors::BLUE) . ' ' . $message . PHP_EOL;
}

function warning(string $message): void
{
    echo colored('âš ', Colors::YELLOW) . ' ' . $message . PHP_EOL;
}

function runTest(VerificationTest $test): bool
{
    echo PHP_EOL . colored('Testing: ', Colors::BOLD) . $test->name . PHP_EOL;
    echo '  URL: ' . $test->url . PHP_EOL;

    $startTime = microtime(true);

    $ch = curl_init($test->url);
    curl_setopt_array($ch, [
        CURLOPT_RETURNTRANSFER => true,
        CURLOPT_TIMEOUT => TIMEOUT_SECONDS,
        CURLOPT_FOLLOWLOCATION => true,
        CURLOPT_SSL_VERIFYPEER => true,
        CURLOPT_HEADER => false,
        CURLOPT_USERAGENT => 'ragie-php-verification/1.0',
    ]);

    $response = curl_exec($ch);
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    $curlError = curl_error($ch);
    $responseTime = (microtime(true) - $startTime) * 1000;
    curl_close($ch);

    $passed = true;

    // Check for cURL errors
    if ($curlError) {
        error("cURL error: {$curlError}");
        return false;
    }

    // Check HTTP status
    if ($httpCode !== $test->expectedStatus) {
        error("HTTP status: expected {$test->expectedStatus}, got {$httpCode}");
        $passed = false;
    } else {
        success("HTTP status: {$httpCode}");
    }

    // Check response time
    if ($test->maxResponseTime !== null && $responseTime > $test->maxResponseTime) {
        warning(sprintf('Response time: %.0fms (exceeds max %dms)', $responseTime, $test->maxResponseTime));
    } else {
        success(sprintf('Response time: %.0fms', $responseTime));
    }

    // Check response content
    if ($response === false || $response === '') {
        error('Empty response body');
        return false;
    }

    // Try to decode JSON
    $data = json_decode($response, true);
    if (json_last_error() === JSON_ERROR_NONE) {
        success('Valid JSON response');

        // Check expected fields
        foreach ($test->expectedFields as $field) {
            if (isset($data[$field])) {
                success("Field '{$field}' present");
            } else {
                error("Field '{$field}' missing");
                $passed = false;
            }
        }

        // Show sample data
        if (isset($data['count'])) {
            info("Retrieved {$data['count']} chunks");
        }
        if (isset($data['execution_time_ms'])) {
            info("Server execution: {$data['execution_time_ms']}ms");
        }
        if (isset($data['rag_source'])) {
            info("RAG source: {$data['rag_source']}");
        }
    } else {
        warning('Non-JSON response (may be expected for HTML endpoints)');
    }

    return $passed;
}

function main(array $argv): int
{
    $baseUrl = $argv[1] ?? 'https://ask.vexy.art';
    $baseUrl = rtrim($baseUrl, '/');

    echo colored('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', Colors::BOLD) . PHP_EOL;
    echo colored('  RAG Endpoint Deployment Verification', Colors::BOLD) . PHP_EOL;
    echo colored('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', Colors::BOLD) . PHP_EOL;
    echo PHP_EOL;
    info("Base URL: {$baseUrl}");
    info('Test query: ' . TEST_QUERY);

    $tests = [
        new VerificationTest(
            name: 'RAG Endpoint - JSON Format',
            url: $baseUrl . '/rag/?text=' . urlencode(TEST_QUERY) . '&format=json',
            expectedStatus: 200,
            expectedFields: ['success', 'chunks', 'count', 'execution_time_ms', 'rag_source'],
            maxResponseTime: 5000
        ),
        new VerificationTest(
            name: 'RAG Endpoint - Text Format',
            url: $baseUrl . '/rag/?text=' . urlencode(TEST_QUERY),
            expectedStatus: 200,
            maxResponseTime: 5000
        ),
        new VerificationTest(
            name: 'RAG Endpoint - Missing Query Parameter',
            url: $baseUrl . '/rag/',
            expectedStatus: 400,
            expectedFields: ['error']
        ),
        new VerificationTest(
            name: 'Main Chatbot Interface',
            url: $baseUrl . '/',
            expectedStatus: 200
        ),
    ];

    $results = [];
    foreach ($tests as $test) {
        $results[] = runTest($test);
    }

    echo PHP_EOL;
    echo colored('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', Colors::BOLD) . PHP_EOL;

    $passed = count(array_filter($results));
    $total = count($results);

    if ($passed === $total) {
        success("All {$total} tests passed!");
        return 0;
    }

    error("{$passed}/{$total} tests passed");
    return 1;
}

exit(main($argv));
</document_content>
</document>

</documents>