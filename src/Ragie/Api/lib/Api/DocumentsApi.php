<?php
/**
 * DocumentsApi
 * PHP version 8.1
 *
 * @category Class
 * @package  Ragie\Api
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Ragie API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Ragie\Api\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Ragie\Api\ApiException;
use Ragie\Api\Configuration;
use Ragie\Api\FormDataProcessor;
use Ragie\Api\HeaderSelector;
use Ragie\Api\ObjectSerializer;

/**
 * DocumentsApi Class Doc Comment
 *
 * @category Class
 * @package  Ragie\Api
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DocumentsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createDocument' => [
            'multipart/form-data',
        ],
        'createDocumentFromUrl' => [
            'application/json',
        ],
        'createDocumentRaw' => [
            'application/json',
        ],
        'deleteDocument' => [
            'application/json',
        ],
        'getDocument' => [
            'application/json',
        ],
        'getDocumentChunk' => [
            'application/json',
        ],
        'getDocumentChunkContent' => [
            'application/json',
        ],
        'getDocumentChunks' => [
            'application/json',
        ],
        'getDocumentContent' => [
            'application/json',
        ],
        'getDocumentSource' => [
            'application/json',
        ],
        'getDocumentSummary' => [
            'application/json',
        ],
        'listDocuments' => [
            'application/json',
        ],
        'patchDocumentMetadata' => [
            'application/json',
        ],
        'updateDocumentFile' => [
            'multipart/form-data',
        ],
        'updateDocumentFromUrl' => [
            'application/json',
        ],
        'updateDocumentRaw' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createDocument
     *
     * Create Document
     *
     * @param  \SplFileObject $file The binary file to upload, extract, and index for retrieval. The following file types are supported: Plain Text: &#x60;.eml&#x60; &#x60;.html&#x60; &#x60;.json&#x60; &#x60;.md&#x60; &#x60;.msg&#x60; &#x60;.rst&#x60; &#x60;.rtf&#x60; &#x60;.txt&#x60; &#x60;.xml&#x60; Images: &#x60;.png&#x60; &#x60;.webp&#x60; &#x60;.jpg&#x60; &#x60;.jpeg&#x60; &#x60;.tiff&#x60; &#x60;.bmp&#x60; &#x60;.heic&#x60; Documents: &#x60;.csv&#x60; &#x60;.doc&#x60; &#x60;.docx&#x60; &#x60;.epub&#x60; &#x60;.epub+zip&#x60; &#x60;.odt&#x60; &#x60;.pdf&#x60; &#x60;.ppt&#x60; &#x60;.pptx&#x60; &#x60;.tsv&#x60; &#x60;.xlsx&#x60; &#x60;.xls&#x60;. PDF files over 2000 pages are not supported in hi_res mode. (required)
     * @param  \Ragie\Api\Model\Mode2|null $mode mode (optional)
     * @param  array<string,\Ragie\Api\Model\MetadataValue1>|null $metadata Metadata for the document. Keys must be strings. Values may be strings, numbers, booleans, or lists of strings. Numbers may be integers or floating point and will be converted to 64 bit floating point. 1000 total values are allowed. Each item in an array counts towards the total. The following keys are reserved for internal use: &#x60;document_id&#x60;, &#x60;document_type&#x60;, &#x60;document_source&#x60;, &#x60;document_name&#x60;, &#x60;document_uploaded_at&#x60;, &#x60;start_time&#x60;, &#x60;end_time&#x60;. (optional)
     * @param  string|null $external_id An optional identifier for the document. A common value might be an id in an external system or the URL where the source file may be found. (optional)
     * @param  string|null $name An optional name for the document. If set, the document will have this name. Otherwise it will default to the file&#39;s name. (optional)
     * @param  string|null $partition An optional partition identifier. Documents can be scoped to a partition. Partitions must be lowercase alphanumeric and may only include the special characters &#x60;_&#x60; and &#x60;-&#x60;.  A partition is created any time a document is created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocument'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Ragie\Api\Model\Document|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError
     */
    public function createDocument($file, $mode = null, $metadata = null, $external_id = null, $name = null, $partition = null, string $contentType = self::contentTypes['createDocument'][0])
    {
        list($response) = $this->createDocumentWithHttpInfo($file, $mode, $metadata, $external_id, $name, $partition, $contentType);
        return $response;
    }

    /**
     * Operation createDocumentWithHttpInfo
     *
     * Create Document
     *
     * @param  \SplFileObject $file The binary file to upload, extract, and index for retrieval. The following file types are supported: Plain Text: &#x60;.eml&#x60; &#x60;.html&#x60; &#x60;.json&#x60; &#x60;.md&#x60; &#x60;.msg&#x60; &#x60;.rst&#x60; &#x60;.rtf&#x60; &#x60;.txt&#x60; &#x60;.xml&#x60; Images: &#x60;.png&#x60; &#x60;.webp&#x60; &#x60;.jpg&#x60; &#x60;.jpeg&#x60; &#x60;.tiff&#x60; &#x60;.bmp&#x60; &#x60;.heic&#x60; Documents: &#x60;.csv&#x60; &#x60;.doc&#x60; &#x60;.docx&#x60; &#x60;.epub&#x60; &#x60;.epub+zip&#x60; &#x60;.odt&#x60; &#x60;.pdf&#x60; &#x60;.ppt&#x60; &#x60;.pptx&#x60; &#x60;.tsv&#x60; &#x60;.xlsx&#x60; &#x60;.xls&#x60;. PDF files over 2000 pages are not supported in hi_res mode. (required)
     * @param  \Ragie\Api\Model\Mode2|null $mode (optional)
     * @param  array<string,\Ragie\Api\Model\MetadataValue1>|null $metadata Metadata for the document. Keys must be strings. Values may be strings, numbers, booleans, or lists of strings. Numbers may be integers or floating point and will be converted to 64 bit floating point. 1000 total values are allowed. Each item in an array counts towards the total. The following keys are reserved for internal use: &#x60;document_id&#x60;, &#x60;document_type&#x60;, &#x60;document_source&#x60;, &#x60;document_name&#x60;, &#x60;document_uploaded_at&#x60;, &#x60;start_time&#x60;, &#x60;end_time&#x60;. (optional)
     * @param  string|null $external_id An optional identifier for the document. A common value might be an id in an external system or the URL where the source file may be found. (optional)
     * @param  string|null $name An optional name for the document. If set, the document will have this name. Otherwise it will default to the file&#39;s name. (optional)
     * @param  string|null $partition An optional partition identifier. Documents can be scoped to a partition. Partitions must be lowercase alphanumeric and may only include the special characters &#x60;_&#x60; and &#x60;-&#x60;.  A partition is created any time a document is created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocument'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Ragie\Api\Model\Document|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDocumentWithHttpInfo($file, $mode = null, $metadata = null, $external_id = null, $name = null, $partition = null, string $contentType = self::contentTypes['createDocument'][0])
    {
        $request = $this->createDocumentRequest($file, $mode, $metadata, $external_id, $name, $partition, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\Document',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Ragie\Api\Model\Document',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createDocumentAsync
     *
     * Create Document
     *
     * @param  \SplFileObject $file The binary file to upload, extract, and index for retrieval. The following file types are supported: Plain Text: &#x60;.eml&#x60; &#x60;.html&#x60; &#x60;.json&#x60; &#x60;.md&#x60; &#x60;.msg&#x60; &#x60;.rst&#x60; &#x60;.rtf&#x60; &#x60;.txt&#x60; &#x60;.xml&#x60; Images: &#x60;.png&#x60; &#x60;.webp&#x60; &#x60;.jpg&#x60; &#x60;.jpeg&#x60; &#x60;.tiff&#x60; &#x60;.bmp&#x60; &#x60;.heic&#x60; Documents: &#x60;.csv&#x60; &#x60;.doc&#x60; &#x60;.docx&#x60; &#x60;.epub&#x60; &#x60;.epub+zip&#x60; &#x60;.odt&#x60; &#x60;.pdf&#x60; &#x60;.ppt&#x60; &#x60;.pptx&#x60; &#x60;.tsv&#x60; &#x60;.xlsx&#x60; &#x60;.xls&#x60;. PDF files over 2000 pages are not supported in hi_res mode. (required)
     * @param  \Ragie\Api\Model\Mode2|null $mode (optional)
     * @param  array<string,\Ragie\Api\Model\MetadataValue1>|null $metadata Metadata for the document. Keys must be strings. Values may be strings, numbers, booleans, or lists of strings. Numbers may be integers or floating point and will be converted to 64 bit floating point. 1000 total values are allowed. Each item in an array counts towards the total. The following keys are reserved for internal use: &#x60;document_id&#x60;, &#x60;document_type&#x60;, &#x60;document_source&#x60;, &#x60;document_name&#x60;, &#x60;document_uploaded_at&#x60;, &#x60;start_time&#x60;, &#x60;end_time&#x60;. (optional)
     * @param  string|null $external_id An optional identifier for the document. A common value might be an id in an external system or the URL where the source file may be found. (optional)
     * @param  string|null $name An optional name for the document. If set, the document will have this name. Otherwise it will default to the file&#39;s name. (optional)
     * @param  string|null $partition An optional partition identifier. Documents can be scoped to a partition. Partitions must be lowercase alphanumeric and may only include the special characters &#x60;_&#x60; and &#x60;-&#x60;.  A partition is created any time a document is created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDocumentAsync($file, $mode = null, $metadata = null, $external_id = null, $name = null, $partition = null, string $contentType = self::contentTypes['createDocument'][0])
    {
        return $this->createDocumentAsyncWithHttpInfo($file, $mode, $metadata, $external_id, $name, $partition, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDocumentAsyncWithHttpInfo
     *
     * Create Document
     *
     * @param  \SplFileObject $file The binary file to upload, extract, and index for retrieval. The following file types are supported: Plain Text: &#x60;.eml&#x60; &#x60;.html&#x60; &#x60;.json&#x60; &#x60;.md&#x60; &#x60;.msg&#x60; &#x60;.rst&#x60; &#x60;.rtf&#x60; &#x60;.txt&#x60; &#x60;.xml&#x60; Images: &#x60;.png&#x60; &#x60;.webp&#x60; &#x60;.jpg&#x60; &#x60;.jpeg&#x60; &#x60;.tiff&#x60; &#x60;.bmp&#x60; &#x60;.heic&#x60; Documents: &#x60;.csv&#x60; &#x60;.doc&#x60; &#x60;.docx&#x60; &#x60;.epub&#x60; &#x60;.epub+zip&#x60; &#x60;.odt&#x60; &#x60;.pdf&#x60; &#x60;.ppt&#x60; &#x60;.pptx&#x60; &#x60;.tsv&#x60; &#x60;.xlsx&#x60; &#x60;.xls&#x60;. PDF files over 2000 pages are not supported in hi_res mode. (required)
     * @param  \Ragie\Api\Model\Mode2|null $mode (optional)
     * @param  array<string,\Ragie\Api\Model\MetadataValue1>|null $metadata Metadata for the document. Keys must be strings. Values may be strings, numbers, booleans, or lists of strings. Numbers may be integers or floating point and will be converted to 64 bit floating point. 1000 total values are allowed. Each item in an array counts towards the total. The following keys are reserved for internal use: &#x60;document_id&#x60;, &#x60;document_type&#x60;, &#x60;document_source&#x60;, &#x60;document_name&#x60;, &#x60;document_uploaded_at&#x60;, &#x60;start_time&#x60;, &#x60;end_time&#x60;. (optional)
     * @param  string|null $external_id An optional identifier for the document. A common value might be an id in an external system or the URL where the source file may be found. (optional)
     * @param  string|null $name An optional name for the document. If set, the document will have this name. Otherwise it will default to the file&#39;s name. (optional)
     * @param  string|null $partition An optional partition identifier. Documents can be scoped to a partition. Partitions must be lowercase alphanumeric and may only include the special characters &#x60;_&#x60; and &#x60;-&#x60;.  A partition is created any time a document is created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDocumentAsyncWithHttpInfo($file, $mode = null, $metadata = null, $external_id = null, $name = null, $partition = null, string $contentType = self::contentTypes['createDocument'][0])
    {
        $returnType = '\Ragie\Api\Model\Document';
        $request = $this->createDocumentRequest($file, $mode, $metadata, $external_id, $name, $partition, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDocument'
     *
     * @param  \SplFileObject $file The binary file to upload, extract, and index for retrieval. The following file types are supported: Plain Text: &#x60;.eml&#x60; &#x60;.html&#x60; &#x60;.json&#x60; &#x60;.md&#x60; &#x60;.msg&#x60; &#x60;.rst&#x60; &#x60;.rtf&#x60; &#x60;.txt&#x60; &#x60;.xml&#x60; Images: &#x60;.png&#x60; &#x60;.webp&#x60; &#x60;.jpg&#x60; &#x60;.jpeg&#x60; &#x60;.tiff&#x60; &#x60;.bmp&#x60; &#x60;.heic&#x60; Documents: &#x60;.csv&#x60; &#x60;.doc&#x60; &#x60;.docx&#x60; &#x60;.epub&#x60; &#x60;.epub+zip&#x60; &#x60;.odt&#x60; &#x60;.pdf&#x60; &#x60;.ppt&#x60; &#x60;.pptx&#x60; &#x60;.tsv&#x60; &#x60;.xlsx&#x60; &#x60;.xls&#x60;. PDF files over 2000 pages are not supported in hi_res mode. (required)
     * @param  \Ragie\Api\Model\Mode2|null $mode (optional)
     * @param  array<string,\Ragie\Api\Model\MetadataValue1>|null $metadata Metadata for the document. Keys must be strings. Values may be strings, numbers, booleans, or lists of strings. Numbers may be integers or floating point and will be converted to 64 bit floating point. 1000 total values are allowed. Each item in an array counts towards the total. The following keys are reserved for internal use: &#x60;document_id&#x60;, &#x60;document_type&#x60;, &#x60;document_source&#x60;, &#x60;document_name&#x60;, &#x60;document_uploaded_at&#x60;, &#x60;start_time&#x60;, &#x60;end_time&#x60;. (optional)
     * @param  string|null $external_id An optional identifier for the document. A common value might be an id in an external system or the URL where the source file may be found. (optional)
     * @param  string|null $name An optional name for the document. If set, the document will have this name. Otherwise it will default to the file&#39;s name. (optional)
     * @param  string|null $partition An optional partition identifier. Documents can be scoped to a partition. Partitions must be lowercase alphanumeric and may only include the special characters &#x60;_&#x60; and &#x60;-&#x60;.  A partition is created any time a document is created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDocumentRequest($file, $mode = null, $metadata = null, $external_id = null, $name = null, $partition = null, string $contentType = self::contentTypes['createDocument'][0])
    {

        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling createDocument'
            );
        }







        $resourcePath = '/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'mode' => $mode,
            'metadata' => $metadata,
            'file' => $file,
            'external_id' => $external_id,
            'name' => $name,
            'partition' => $partition,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDocumentFromUrl
     *
     * Create Document From Url
     *
     * @param  \Ragie\Api\Model\CreateDocumentFromUrlParams $create_document_from_url_params create_document_from_url_params (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocumentFromUrl'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Ragie\Api\Model\Document|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError
     */
    public function createDocumentFromUrl($create_document_from_url_params, string $contentType = self::contentTypes['createDocumentFromUrl'][0])
    {
        list($response) = $this->createDocumentFromUrlWithHttpInfo($create_document_from_url_params, $contentType);
        return $response;
    }

    /**
     * Operation createDocumentFromUrlWithHttpInfo
     *
     * Create Document From Url
     *
     * @param  \Ragie\Api\Model\CreateDocumentFromUrlParams $create_document_from_url_params (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocumentFromUrl'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Ragie\Api\Model\Document|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDocumentFromUrlWithHttpInfo($create_document_from_url_params, string $contentType = self::contentTypes['createDocumentFromUrl'][0])
    {
        $request = $this->createDocumentFromUrlRequest($create_document_from_url_params, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\Document',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Ragie\Api\Model\Document',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createDocumentFromUrlAsync
     *
     * Create Document From Url
     *
     * @param  \Ragie\Api\Model\CreateDocumentFromUrlParams $create_document_from_url_params (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocumentFromUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDocumentFromUrlAsync($create_document_from_url_params, string $contentType = self::contentTypes['createDocumentFromUrl'][0])
    {
        return $this->createDocumentFromUrlAsyncWithHttpInfo($create_document_from_url_params, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDocumentFromUrlAsyncWithHttpInfo
     *
     * Create Document From Url
     *
     * @param  \Ragie\Api\Model\CreateDocumentFromUrlParams $create_document_from_url_params (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocumentFromUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDocumentFromUrlAsyncWithHttpInfo($create_document_from_url_params, string $contentType = self::contentTypes['createDocumentFromUrl'][0])
    {
        $returnType = '\Ragie\Api\Model\Document';
        $request = $this->createDocumentFromUrlRequest($create_document_from_url_params, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDocumentFromUrl'
     *
     * @param  \Ragie\Api\Model\CreateDocumentFromUrlParams $create_document_from_url_params (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocumentFromUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDocumentFromUrlRequest($create_document_from_url_params, string $contentType = self::contentTypes['createDocumentFromUrl'][0])
    {

        // verify the required parameter 'create_document_from_url_params' is set
        if ($create_document_from_url_params === null || (is_array($create_document_from_url_params) && count($create_document_from_url_params) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_document_from_url_params when calling createDocumentFromUrl'
            );
        }


        $resourcePath = '/documents/url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_document_from_url_params)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_document_from_url_params));
            } else {
                $httpBody = $create_document_from_url_params;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDocumentRaw
     *
     * Create Document Raw
     *
     * @param  \Ragie\Api\Model\CreateDocumentRawParams $create_document_raw_params create_document_raw_params (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocumentRaw'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Ragie\Api\Model\Document|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError
     */
    public function createDocumentRaw($create_document_raw_params, string $contentType = self::contentTypes['createDocumentRaw'][0])
    {
        list($response) = $this->createDocumentRawWithHttpInfo($create_document_raw_params, $contentType);
        return $response;
    }

    /**
     * Operation createDocumentRawWithHttpInfo
     *
     * Create Document Raw
     *
     * @param  \Ragie\Api\Model\CreateDocumentRawParams $create_document_raw_params (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocumentRaw'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Ragie\Api\Model\Document|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDocumentRawWithHttpInfo($create_document_raw_params, string $contentType = self::contentTypes['createDocumentRaw'][0])
    {
        $request = $this->createDocumentRawRequest($create_document_raw_params, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\Document',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Ragie\Api\Model\Document',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createDocumentRawAsync
     *
     * Create Document Raw
     *
     * @param  \Ragie\Api\Model\CreateDocumentRawParams $create_document_raw_params (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocumentRaw'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDocumentRawAsync($create_document_raw_params, string $contentType = self::contentTypes['createDocumentRaw'][0])
    {
        return $this->createDocumentRawAsyncWithHttpInfo($create_document_raw_params, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDocumentRawAsyncWithHttpInfo
     *
     * Create Document Raw
     *
     * @param  \Ragie\Api\Model\CreateDocumentRawParams $create_document_raw_params (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocumentRaw'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDocumentRawAsyncWithHttpInfo($create_document_raw_params, string $contentType = self::contentTypes['createDocumentRaw'][0])
    {
        $returnType = '\Ragie\Api\Model\Document';
        $request = $this->createDocumentRawRequest($create_document_raw_params, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDocumentRaw'
     *
     * @param  \Ragie\Api\Model\CreateDocumentRawParams $create_document_raw_params (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDocumentRaw'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDocumentRawRequest($create_document_raw_params, string $contentType = self::contentTypes['createDocumentRaw'][0])
    {

        // verify the required parameter 'create_document_raw_params' is set
        if ($create_document_raw_params === null || (is_array($create_document_raw_params) && count($create_document_raw_params) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_document_raw_params when calling createDocumentRaw'
            );
        }


        $resourcePath = '/documents/raw';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_document_raw_params)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_document_raw_params));
            } else {
                $httpBody = $create_document_raw_params;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDocument
     *
     * Delete Document
     *
     * @param  string $document_id The id of the document. (required)
     * @param  bool|null $async If true, performs document deletion asynchronously (optional)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDocument'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Ragie\Api\Model\DocumentDelete|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\DocumentDelete|\Ragie\Api\Model\HTTPValidationError
     */
    public function deleteDocument($document_id, $async = null, $partition = null, string $contentType = self::contentTypes['deleteDocument'][0])
    {
        list($response) = $this->deleteDocumentWithHttpInfo($document_id, $async, $partition, $contentType);
        return $response;
    }

    /**
     * Operation deleteDocumentWithHttpInfo
     *
     * Delete Document
     *
     * @param  string $document_id The id of the document. (required)
     * @param  bool|null $async If true, performs document deletion asynchronously (optional)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDocument'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Ragie\Api\Model\DocumentDelete|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\DocumentDelete|\Ragie\Api\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDocumentWithHttpInfo($document_id, $async = null, $partition = null, string $contentType = self::contentTypes['deleteDocument'][0])
    {
        $request = $this->deleteDocumentRequest($document_id, $async, $partition, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\DocumentDelete',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 202:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\DocumentDelete',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Ragie\Api\Model\DocumentDelete',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\DocumentDelete',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\DocumentDelete',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteDocumentAsync
     *
     * Delete Document
     *
     * @param  string $document_id The id of the document. (required)
     * @param  bool|null $async If true, performs document deletion asynchronously (optional)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentAsync($document_id, $async = null, $partition = null, string $contentType = self::contentTypes['deleteDocument'][0])
    {
        return $this->deleteDocumentAsyncWithHttpInfo($document_id, $async, $partition, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDocumentAsyncWithHttpInfo
     *
     * Delete Document
     *
     * @param  string $document_id The id of the document. (required)
     * @param  bool|null $async If true, performs document deletion asynchronously (optional)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentAsyncWithHttpInfo($document_id, $async = null, $partition = null, string $contentType = self::contentTypes['deleteDocument'][0])
    {
        $returnType = '\Ragie\Api\Model\DocumentDelete';
        $request = $this->deleteDocumentRequest($document_id, $async, $partition, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDocument'
     *
     * @param  string $document_id The id of the document. (required)
     * @param  bool|null $async If true, performs document deletion asynchronously (optional)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteDocumentRequest($document_id, $async = null, $partition = null, string $contentType = self::contentTypes['deleteDocument'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling deleteDocument'
            );
        }




        $resourcePath = '/documents/{document_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $async,
            'async', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($partition !== null) {
            $headerParams['partition'] = ObjectSerializer::toHeaderValue($partition);
        }

        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'document_id' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocument
     *
     * Get Document
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocument'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Ragie\Api\Model\DocumentGet|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError
     */
    public function getDocument($document_id, $partition = null, string $contentType = self::contentTypes['getDocument'][0])
    {
        list($response) = $this->getDocumentWithHttpInfo($document_id, $partition, $contentType);
        return $response;
    }

    /**
     * Operation getDocumentWithHttpInfo
     *
     * Get Document
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocument'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Ragie\Api\Model\DocumentGet|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentWithHttpInfo($document_id, $partition = null, string $contentType = self::contentTypes['getDocument'][0])
    {
        $request = $this->getDocumentRequest($document_id, $partition, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\DocumentGet',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Ragie\Api\Model\DocumentGet',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\DocumentGet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getDocumentAsync
     *
     * Get Document
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAsync($document_id, $partition = null, string $contentType = self::contentTypes['getDocument'][0])
    {
        return $this->getDocumentAsyncWithHttpInfo($document_id, $partition, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentAsyncWithHttpInfo
     *
     * Get Document
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAsyncWithHttpInfo($document_id, $partition = null, string $contentType = self::contentTypes['getDocument'][0])
    {
        $returnType = '\Ragie\Api\Model\DocumentGet';
        $request = $this->getDocumentRequest($document_id, $partition, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocument'
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDocumentRequest($document_id, $partition = null, string $contentType = self::contentTypes['getDocument'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling getDocument'
            );
        }



        $resourcePath = '/documents/{document_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($partition !== null) {
            $headerParams['partition'] = ObjectSerializer::toHeaderValue($partition);
        }

        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'document_id' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentChunk
     *
     * Get Document Chunk
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string $chunk_id The ID of the chunk. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentChunk'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Ragie\Api\Model\DocumentChunkDetail|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError
     */
    public function getDocumentChunk($document_id, $chunk_id, $partition = null, string $contentType = self::contentTypes['getDocumentChunk'][0])
    {
        list($response) = $this->getDocumentChunkWithHttpInfo($document_id, $chunk_id, $partition, $contentType);
        return $response;
    }

    /**
     * Operation getDocumentChunkWithHttpInfo
     *
     * Get Document Chunk
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string $chunk_id The ID of the chunk. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentChunk'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Ragie\Api\Model\DocumentChunkDetail|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentChunkWithHttpInfo($document_id, $chunk_id, $partition = null, string $contentType = self::contentTypes['getDocumentChunk'][0])
    {
        $request = $this->getDocumentChunkRequest($document_id, $chunk_id, $partition, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\DocumentChunkDetail',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Ragie\Api\Model\DocumentChunkDetail',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\DocumentChunkDetail',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getDocumentChunkAsync
     *
     * Get Document Chunk
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string $chunk_id The ID of the chunk. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentChunk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentChunkAsync($document_id, $chunk_id, $partition = null, string $contentType = self::contentTypes['getDocumentChunk'][0])
    {
        return $this->getDocumentChunkAsyncWithHttpInfo($document_id, $chunk_id, $partition, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentChunkAsyncWithHttpInfo
     *
     * Get Document Chunk
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string $chunk_id The ID of the chunk. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentChunk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentChunkAsyncWithHttpInfo($document_id, $chunk_id, $partition = null, string $contentType = self::contentTypes['getDocumentChunk'][0])
    {
        $returnType = '\Ragie\Api\Model\DocumentChunkDetail';
        $request = $this->getDocumentChunkRequest($document_id, $chunk_id, $partition, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentChunk'
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string $chunk_id The ID of the chunk. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentChunk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDocumentChunkRequest($document_id, $chunk_id, $partition = null, string $contentType = self::contentTypes['getDocumentChunk'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling getDocumentChunk'
            );
        }

        // verify the required parameter 'chunk_id' is set
        if ($chunk_id === null || (is_array($chunk_id) && count($chunk_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chunk_id when calling getDocumentChunk'
            );
        }



        $resourcePath = '/documents/{document_id}/chunks/{chunk_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($partition !== null) {
            $headerParams['partition'] = ObjectSerializer::toHeaderValue($partition);
        }

        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'document_id' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }
        // path params
        if ($chunk_id !== null) {
            $resourcePath = str_replace(
                '{' . 'chunk_id' . '}',
                ObjectSerializer::toPathValue($chunk_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentChunkContent
     *
     * Get Document Chunk Content
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string $chunk_id The ID of the chunk. (required)
     * @param  string|null $media_type The desired media type of the content to return described as a mime type. An error will be returned if the requested media type is not supported for the chunk&#39;s document type. (optional)
     * @param  bool|null $download Whether to return the content as a file download or a raw stream. If set to &#x60;true&#x60;, the content will be returned as a named file for download. (optional, default to false)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string|null $range range (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentChunkContent'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError
     */
    public function getDocumentChunkContent($document_id, $chunk_id, $media_type = null, $download = false, $partition = null, $range = null, string $contentType = self::contentTypes['getDocumentChunkContent'][0])
    {
        list($response) = $this->getDocumentChunkContentWithHttpInfo($document_id, $chunk_id, $media_type, $download, $partition, $range, $contentType);
        return $response;
    }

    /**
     * Operation getDocumentChunkContentWithHttpInfo
     *
     * Get Document Chunk Content
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string $chunk_id The ID of the chunk. (required)
     * @param  string|null $media_type The desired media type of the content to return described as a mime type. An error will be returned if the requested media type is not supported for the chunk&#39;s document type. (optional)
     * @param  bool|null $download Whether to return the content as a file download or a raw stream. If set to &#x60;true&#x60;, the content will be returned as a named file for download. (optional, default to false)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string|null $range (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentChunkContent'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentChunkContentWithHttpInfo($document_id, $chunk_id, $media_type = null, $download = false, $partition = null, $range = null, string $contentType = self::contentTypes['getDocumentChunkContent'][0])
    {
        $request = $this->getDocumentChunkContentRequest($document_id, $chunk_id, $media_type, $download, $partition, $range, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getDocumentChunkContentAsync
     *
     * Get Document Chunk Content
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string $chunk_id The ID of the chunk. (required)
     * @param  string|null $media_type The desired media type of the content to return described as a mime type. An error will be returned if the requested media type is not supported for the chunk&#39;s document type. (optional)
     * @param  bool|null $download Whether to return the content as a file download or a raw stream. If set to &#x60;true&#x60;, the content will be returned as a named file for download. (optional, default to false)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string|null $range (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentChunkContent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentChunkContentAsync($document_id, $chunk_id, $media_type = null, $download = false, $partition = null, $range = null, string $contentType = self::contentTypes['getDocumentChunkContent'][0])
    {
        return $this->getDocumentChunkContentAsyncWithHttpInfo($document_id, $chunk_id, $media_type, $download, $partition, $range, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentChunkContentAsyncWithHttpInfo
     *
     * Get Document Chunk Content
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string $chunk_id The ID of the chunk. (required)
     * @param  string|null $media_type The desired media type of the content to return described as a mime type. An error will be returned if the requested media type is not supported for the chunk&#39;s document type. (optional)
     * @param  bool|null $download Whether to return the content as a file download or a raw stream. If set to &#x60;true&#x60;, the content will be returned as a named file for download. (optional, default to false)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string|null $range (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentChunkContent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentChunkContentAsyncWithHttpInfo($document_id, $chunk_id, $media_type = null, $download = false, $partition = null, $range = null, string $contentType = self::contentTypes['getDocumentChunkContent'][0])
    {
        $returnType = 'mixed';
        $request = $this->getDocumentChunkContentRequest($document_id, $chunk_id, $media_type, $download, $partition, $range, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentChunkContent'
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string $chunk_id The ID of the chunk. (required)
     * @param  string|null $media_type The desired media type of the content to return described as a mime type. An error will be returned if the requested media type is not supported for the chunk&#39;s document type. (optional)
     * @param  bool|null $download Whether to return the content as a file download or a raw stream. If set to &#x60;true&#x60;, the content will be returned as a named file for download. (optional, default to false)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string|null $range (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentChunkContent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDocumentChunkContentRequest($document_id, $chunk_id, $media_type = null, $download = false, $partition = null, $range = null, string $contentType = self::contentTypes['getDocumentChunkContent'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling getDocumentChunkContent'
            );
        }

        // verify the required parameter 'chunk_id' is set
        if ($chunk_id === null || (is_array($chunk_id) && count($chunk_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chunk_id when calling getDocumentChunkContent'
            );
        }






        $resourcePath = '/documents/{document_id}/chunks/{chunk_id}/content';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_type,
            'media_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $download,
            'download', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($partition !== null) {
            $headerParams['partition'] = ObjectSerializer::toHeaderValue($partition);
        }
        // header params
        if ($range !== null) {
            $headerParams['range'] = ObjectSerializer::toHeaderValue($range);
        }

        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'document_id' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }
        // path params
        if ($chunk_id !== null) {
            $resourcePath = str_replace(
                '{' . 'chunk_id' . '}',
                ObjectSerializer::toPathValue($chunk_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/octet-stream', 'audio/mpeg', 'text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentChunks
     *
     * Get Document Chunks
     *
     * @param  string $document_id The id of the document. (required)
     * @param  int|null $start_index The inclusive starting index of the chunk range to list. If omitted and &#x60;end_index&#x60; is present effectively limits results to at most one chunk matching &#x60;end_index&#x60;. If both &#x60;start_index&#x60; and &#x60;end_index&#x60; are omitted, results are not limited by index. (optional)
     * @param  int|null $end_index The inclusive ending index of the chunk range to list. If omitted and &#x60;start_index&#x60; is present effectively limits results to at most one chunk matching &#x60;start_index&#x60;. If both &#x60;start_index&#x60; and &#x60;end_index&#x60; are omitted, results are not limited by index. (optional)
     * @param  string|null $cursor An opaque cursor for pagination (optional)
     * @param  int|null $page_size The number of items per page (must be greater than 0 and less than or equal to 100) (optional, default to 10)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentChunks'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Ragie\Api\Model\DocumentChunkList|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError
     */
    public function getDocumentChunks($document_id, $start_index = null, $end_index = null, $cursor = null, $page_size = 10, $partition = null, string $contentType = self::contentTypes['getDocumentChunks'][0])
    {
        list($response) = $this->getDocumentChunksWithHttpInfo($document_id, $start_index, $end_index, $cursor, $page_size, $partition, $contentType);
        return $response;
    }

    /**
     * Operation getDocumentChunksWithHttpInfo
     *
     * Get Document Chunks
     *
     * @param  string $document_id The id of the document. (required)
     * @param  int|null $start_index The inclusive starting index of the chunk range to list. If omitted and &#x60;end_index&#x60; is present effectively limits results to at most one chunk matching &#x60;end_index&#x60;. If both &#x60;start_index&#x60; and &#x60;end_index&#x60; are omitted, results are not limited by index. (optional)
     * @param  int|null $end_index The inclusive ending index of the chunk range to list. If omitted and &#x60;start_index&#x60; is present effectively limits results to at most one chunk matching &#x60;start_index&#x60;. If both &#x60;start_index&#x60; and &#x60;end_index&#x60; are omitted, results are not limited by index. (optional)
     * @param  string|null $cursor An opaque cursor for pagination (optional)
     * @param  int|null $page_size The number of items per page (must be greater than 0 and less than or equal to 100) (optional, default to 10)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentChunks'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Ragie\Api\Model\DocumentChunkList|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentChunksWithHttpInfo($document_id, $start_index = null, $end_index = null, $cursor = null, $page_size = 10, $partition = null, string $contentType = self::contentTypes['getDocumentChunks'][0])
    {
        $request = $this->getDocumentChunksRequest($document_id, $start_index, $end_index, $cursor, $page_size, $partition, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\DocumentChunkList',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Ragie\Api\Model\DocumentChunkList',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\DocumentChunkList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getDocumentChunksAsync
     *
     * Get Document Chunks
     *
     * @param  string $document_id The id of the document. (required)
     * @param  int|null $start_index The inclusive starting index of the chunk range to list. If omitted and &#x60;end_index&#x60; is present effectively limits results to at most one chunk matching &#x60;end_index&#x60;. If both &#x60;start_index&#x60; and &#x60;end_index&#x60; are omitted, results are not limited by index. (optional)
     * @param  int|null $end_index The inclusive ending index of the chunk range to list. If omitted and &#x60;start_index&#x60; is present effectively limits results to at most one chunk matching &#x60;start_index&#x60;. If both &#x60;start_index&#x60; and &#x60;end_index&#x60; are omitted, results are not limited by index. (optional)
     * @param  string|null $cursor An opaque cursor for pagination (optional)
     * @param  int|null $page_size The number of items per page (must be greater than 0 and less than or equal to 100) (optional, default to 10)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentChunks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentChunksAsync($document_id, $start_index = null, $end_index = null, $cursor = null, $page_size = 10, $partition = null, string $contentType = self::contentTypes['getDocumentChunks'][0])
    {
        return $this->getDocumentChunksAsyncWithHttpInfo($document_id, $start_index, $end_index, $cursor, $page_size, $partition, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentChunksAsyncWithHttpInfo
     *
     * Get Document Chunks
     *
     * @param  string $document_id The id of the document. (required)
     * @param  int|null $start_index The inclusive starting index of the chunk range to list. If omitted and &#x60;end_index&#x60; is present effectively limits results to at most one chunk matching &#x60;end_index&#x60;. If both &#x60;start_index&#x60; and &#x60;end_index&#x60; are omitted, results are not limited by index. (optional)
     * @param  int|null $end_index The inclusive ending index of the chunk range to list. If omitted and &#x60;start_index&#x60; is present effectively limits results to at most one chunk matching &#x60;start_index&#x60;. If both &#x60;start_index&#x60; and &#x60;end_index&#x60; are omitted, results are not limited by index. (optional)
     * @param  string|null $cursor An opaque cursor for pagination (optional)
     * @param  int|null $page_size The number of items per page (must be greater than 0 and less than or equal to 100) (optional, default to 10)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentChunks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentChunksAsyncWithHttpInfo($document_id, $start_index = null, $end_index = null, $cursor = null, $page_size = 10, $partition = null, string $contentType = self::contentTypes['getDocumentChunks'][0])
    {
        $returnType = '\Ragie\Api\Model\DocumentChunkList';
        $request = $this->getDocumentChunksRequest($document_id, $start_index, $end_index, $cursor, $page_size, $partition, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentChunks'
     *
     * @param  string $document_id The id of the document. (required)
     * @param  int|null $start_index The inclusive starting index of the chunk range to list. If omitted and &#x60;end_index&#x60; is present effectively limits results to at most one chunk matching &#x60;end_index&#x60;. If both &#x60;start_index&#x60; and &#x60;end_index&#x60; are omitted, results are not limited by index. (optional)
     * @param  int|null $end_index The inclusive ending index of the chunk range to list. If omitted and &#x60;start_index&#x60; is present effectively limits results to at most one chunk matching &#x60;start_index&#x60;. If both &#x60;start_index&#x60; and &#x60;end_index&#x60; are omitted, results are not limited by index. (optional)
     * @param  string|null $cursor An opaque cursor for pagination (optional)
     * @param  int|null $page_size The number of items per page (must be greater than 0 and less than or equal to 100) (optional, default to 10)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentChunks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDocumentChunksRequest($document_id, $start_index = null, $end_index = null, $cursor = null, $page_size = 10, $partition = null, string $contentType = self::contentTypes['getDocumentChunks'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling getDocumentChunks'
            );
        }




        if ($page_size !== null && $page_size > 100) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling DocumentsApi.getDocumentChunks, must be smaller than or equal to 100.');
        }
        if ($page_size !== null && $page_size < 1) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling DocumentsApi.getDocumentChunks, must be bigger than or equal to 1.');
        }
        


        $resourcePath = '/documents/{document_id}/chunks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'start_index', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_index,
            'end_index', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cursor,
            'cursor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($partition !== null) {
            $headerParams['partition'] = ObjectSerializer::toHeaderValue($partition);
        }

        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'document_id' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentContent
     *
     * Get Document Content
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\MediaType|null $media_type The desired media type of the content to return described as a mime type. An error will be returned if the requested media type is not supported for the document&#39;s type. (optional)
     * @param  bool|null $download Whether to return the content as a file download or a raw stream. If set to &#x60;true&#x60;, the content will be returned as a named file for download. (optional, default to false)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string|null $range range (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentContent'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Ragie\Api\Model\DocumentWithContent|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError
     */
    public function getDocumentContent($document_id, $media_type = null, $download = false, $partition = null, $range = null, string $contentType = self::contentTypes['getDocumentContent'][0])
    {
        list($response) = $this->getDocumentContentWithHttpInfo($document_id, $media_type, $download, $partition, $range, $contentType);
        return $response;
    }

    /**
     * Operation getDocumentContentWithHttpInfo
     *
     * Get Document Content
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\MediaType|null $media_type The desired media type of the content to return described as a mime type. An error will be returned if the requested media type is not supported for the document&#39;s type. (optional)
     * @param  bool|null $download Whether to return the content as a file download or a raw stream. If set to &#x60;true&#x60;, the content will be returned as a named file for download. (optional, default to false)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string|null $range (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentContent'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Ragie\Api\Model\DocumentWithContent|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentContentWithHttpInfo($document_id, $media_type = null, $download = false, $partition = null, $range = null, string $contentType = self::contentTypes['getDocumentContent'][0])
    {
        $request = $this->getDocumentContentRequest($document_id, $media_type, $download, $partition, $range, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\DocumentWithContent',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Ragie\Api\Model\DocumentWithContent',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\DocumentWithContent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getDocumentContentAsync
     *
     * Get Document Content
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\MediaType|null $media_type The desired media type of the content to return described as a mime type. An error will be returned if the requested media type is not supported for the document&#39;s type. (optional)
     * @param  bool|null $download Whether to return the content as a file download or a raw stream. If set to &#x60;true&#x60;, the content will be returned as a named file for download. (optional, default to false)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string|null $range (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentContent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentContentAsync($document_id, $media_type = null, $download = false, $partition = null, $range = null, string $contentType = self::contentTypes['getDocumentContent'][0])
    {
        return $this->getDocumentContentAsyncWithHttpInfo($document_id, $media_type, $download, $partition, $range, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentContentAsyncWithHttpInfo
     *
     * Get Document Content
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\MediaType|null $media_type The desired media type of the content to return described as a mime type. An error will be returned if the requested media type is not supported for the document&#39;s type. (optional)
     * @param  bool|null $download Whether to return the content as a file download or a raw stream. If set to &#x60;true&#x60;, the content will be returned as a named file for download. (optional, default to false)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string|null $range (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentContent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentContentAsyncWithHttpInfo($document_id, $media_type = null, $download = false, $partition = null, $range = null, string $contentType = self::contentTypes['getDocumentContent'][0])
    {
        $returnType = '\Ragie\Api\Model\DocumentWithContent';
        $request = $this->getDocumentContentRequest($document_id, $media_type, $download, $partition, $range, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentContent'
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\MediaType|null $media_type The desired media type of the content to return described as a mime type. An error will be returned if the requested media type is not supported for the document&#39;s type. (optional)
     * @param  bool|null $download Whether to return the content as a file download or a raw stream. If set to &#x60;true&#x60;, the content will be returned as a named file for download. (optional, default to false)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string|null $range (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentContent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDocumentContentRequest($document_id, $media_type = null, $download = false, $partition = null, $range = null, string $contentType = self::contentTypes['getDocumentContent'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling getDocumentContent'
            );
        }






        $resourcePath = '/documents/{document_id}/content';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_type,
            'media_type', // param base name
            'anyOf&lt;string,string&gt;', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $download,
            'download', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($partition !== null) {
            $headerParams['partition'] = ObjectSerializer::toHeaderValue($partition);
        }
        // header params
        if ($range !== null) {
            $headerParams['range'] = ObjectSerializer::toHeaderValue($range);
        }

        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'document_id' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentSource
     *
     * Get Document Source
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentSource'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError
     */
    public function getDocumentSource($document_id, $partition = null, string $contentType = self::contentTypes['getDocumentSource'][0])
    {
        list($response) = $this->getDocumentSourceWithHttpInfo($document_id, $partition, $contentType);
        return $response;
    }

    /**
     * Operation getDocumentSourceWithHttpInfo
     *
     * Get Document Source
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentSource'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentSourceWithHttpInfo($document_id, $partition = null, string $contentType = self::contentTypes['getDocumentSource'][0])
    {
        $request = $this->getDocumentSourceRequest($document_id, $partition, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getDocumentSourceAsync
     *
     * Get Document Source
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentSource'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentSourceAsync($document_id, $partition = null, string $contentType = self::contentTypes['getDocumentSource'][0])
    {
        return $this->getDocumentSourceAsyncWithHttpInfo($document_id, $partition, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentSourceAsyncWithHttpInfo
     *
     * Get Document Source
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentSource'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentSourceAsyncWithHttpInfo($document_id, $partition = null, string $contentType = self::contentTypes['getDocumentSource'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getDocumentSourceRequest($document_id, $partition, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentSource'
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentSource'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDocumentSourceRequest($document_id, $partition = null, string $contentType = self::contentTypes['getDocumentSource'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling getDocumentSource'
            );
        }



        $resourcePath = '/documents/{document_id}/source';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($partition !== null) {
            $headerParams['partition'] = ObjectSerializer::toHeaderValue($partition);
        }

        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'document_id' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocumentSummary
     *
     * Get Document Summary
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentSummary'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Ragie\Api\Model\DocumentSummary|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError
     */
    public function getDocumentSummary($document_id, $partition = null, string $contentType = self::contentTypes['getDocumentSummary'][0])
    {
        list($response) = $this->getDocumentSummaryWithHttpInfo($document_id, $partition, $contentType);
        return $response;
    }

    /**
     * Operation getDocumentSummaryWithHttpInfo
     *
     * Get Document Summary
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentSummary'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Ragie\Api\Model\DocumentSummary|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentSummaryWithHttpInfo($document_id, $partition = null, string $contentType = self::contentTypes['getDocumentSummary'][0])
    {
        $request = $this->getDocumentSummaryRequest($document_id, $partition, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\DocumentSummary',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Ragie\Api\Model\DocumentSummary',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\DocumentSummary',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getDocumentSummaryAsync
     *
     * Get Document Summary
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentSummary'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentSummaryAsync($document_id, $partition = null, string $contentType = self::contentTypes['getDocumentSummary'][0])
    {
        return $this->getDocumentSummaryAsyncWithHttpInfo($document_id, $partition, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentSummaryAsyncWithHttpInfo
     *
     * Get Document Summary
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentSummary'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentSummaryAsyncWithHttpInfo($document_id, $partition = null, string $contentType = self::contentTypes['getDocumentSummary'][0])
    {
        $returnType = '\Ragie\Api\Model\DocumentSummary';
        $request = $this->getDocumentSummaryRequest($document_id, $partition, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocumentSummary'
     *
     * @param  string $document_id The id of the document. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocumentSummary'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDocumentSummaryRequest($document_id, $partition = null, string $contentType = self::contentTypes['getDocumentSummary'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling getDocumentSummary'
            );
        }



        $resourcePath = '/documents/{document_id}/summary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($partition !== null) {
            $headerParams['partition'] = ObjectSerializer::toHeaderValue($partition);
        }

        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'document_id' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listDocuments
     *
     * List Documents
     *
     * @param  string|null $cursor An opaque cursor for pagination (optional)
     * @param  int|null $page_size The number of items per page (must be greater than 0 and less than or equal to 100) (optional, default to 10)
     * @param  string|null $filter The metadata search filter. Returns only items which match the filter. The following filter operators are supported: $eq - Equal to (number, string, boolean), $ne - Not equal to (number, string, boolean), $gt - Greater than (number), $gte - Greater than or equal to (number), $lt - Less than (number), $lte - Less than or equal to (number), $in - In array (string or number), $nin - Not in array (string or number). The operators can be combined with AND and OR. Read [Metadata &amp; Filters guide](https://docs.ragie.ai/docs/metadata-filters) for more details and examples. (optional)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDocuments'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Ragie\Api\Model\DocumentList|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError
     */
    public function listDocuments($cursor = null, $page_size = 10, $filter = null, $partition = null, string $contentType = self::contentTypes['listDocuments'][0])
    {
        list($response) = $this->listDocumentsWithHttpInfo($cursor, $page_size, $filter, $partition, $contentType);
        return $response;
    }

    /**
     * Operation listDocumentsWithHttpInfo
     *
     * List Documents
     *
     * @param  string|null $cursor An opaque cursor for pagination (optional)
     * @param  int|null $page_size The number of items per page (must be greater than 0 and less than or equal to 100) (optional, default to 10)
     * @param  string|null $filter The metadata search filter. Returns only items which match the filter. The following filter operators are supported: $eq - Equal to (number, string, boolean), $ne - Not equal to (number, string, boolean), $gt - Greater than (number), $gte - Greater than or equal to (number), $lt - Less than (number), $lte - Less than or equal to (number), $in - In array (string or number), $nin - Not in array (string or number). The operators can be combined with AND and OR. Read [Metadata &amp; Filters guide](https://docs.ragie.ai/docs/metadata-filters) for more details and examples. (optional)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDocuments'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Ragie\Api\Model\DocumentList|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function listDocumentsWithHttpInfo($cursor = null, $page_size = 10, $filter = null, $partition = null, string $contentType = self::contentTypes['listDocuments'][0])
    {
        $request = $this->listDocumentsRequest($cursor, $page_size, $filter, $partition, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\DocumentList',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Ragie\Api\Model\DocumentList',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\DocumentList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listDocumentsAsync
     *
     * List Documents
     *
     * @param  string|null $cursor An opaque cursor for pagination (optional)
     * @param  int|null $page_size The number of items per page (must be greater than 0 and less than or equal to 100) (optional, default to 10)
     * @param  string|null $filter The metadata search filter. Returns only items which match the filter. The following filter operators are supported: $eq - Equal to (number, string, boolean), $ne - Not equal to (number, string, boolean), $gt - Greater than (number), $gte - Greater than or equal to (number), $lt - Less than (number), $lte - Less than or equal to (number), $in - In array (string or number), $nin - Not in array (string or number). The operators can be combined with AND and OR. Read [Metadata &amp; Filters guide](https://docs.ragie.ai/docs/metadata-filters) for more details and examples. (optional)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDocumentsAsync($cursor = null, $page_size = 10, $filter = null, $partition = null, string $contentType = self::contentTypes['listDocuments'][0])
    {
        return $this->listDocumentsAsyncWithHttpInfo($cursor, $page_size, $filter, $partition, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listDocumentsAsyncWithHttpInfo
     *
     * List Documents
     *
     * @param  string|null $cursor An opaque cursor for pagination (optional)
     * @param  int|null $page_size The number of items per page (must be greater than 0 and less than or equal to 100) (optional, default to 10)
     * @param  string|null $filter The metadata search filter. Returns only items which match the filter. The following filter operators are supported: $eq - Equal to (number, string, boolean), $ne - Not equal to (number, string, boolean), $gt - Greater than (number), $gte - Greater than or equal to (number), $lt - Less than (number), $lte - Less than or equal to (number), $in - In array (string or number), $nin - Not in array (string or number). The operators can be combined with AND and OR. Read [Metadata &amp; Filters guide](https://docs.ragie.ai/docs/metadata-filters) for more details and examples. (optional)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDocumentsAsyncWithHttpInfo($cursor = null, $page_size = 10, $filter = null, $partition = null, string $contentType = self::contentTypes['listDocuments'][0])
    {
        $returnType = '\Ragie\Api\Model\DocumentList';
        $request = $this->listDocumentsRequest($cursor, $page_size, $filter, $partition, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listDocuments'
     *
     * @param  string|null $cursor An opaque cursor for pagination (optional)
     * @param  int|null $page_size The number of items per page (must be greater than 0 and less than or equal to 100) (optional, default to 10)
     * @param  string|null $filter The metadata search filter. Returns only items which match the filter. The following filter operators are supported: $eq - Equal to (number, string, boolean), $ne - Not equal to (number, string, boolean), $gt - Greater than (number), $gte - Greater than or equal to (number), $lt - Less than (number), $lte - Less than or equal to (number), $in - In array (string or number), $nin - Not in array (string or number). The operators can be combined with AND and OR. Read [Metadata &amp; Filters guide](https://docs.ragie.ai/docs/metadata-filters) for more details and examples. (optional)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listDocumentsRequest($cursor = null, $page_size = 10, $filter = null, $partition = null, string $contentType = self::contentTypes['listDocuments'][0])
    {


        if ($page_size !== null && $page_size > 100) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling DocumentsApi.listDocuments, must be smaller than or equal to 100.');
        }
        if ($page_size !== null && $page_size < 1) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling DocumentsApi.listDocuments, must be bigger than or equal to 1.');
        }
        



        $resourcePath = '/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cursor,
            'cursor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter,
            'filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($partition !== null) {
            $headerParams['partition'] = ObjectSerializer::toHeaderValue($partition);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchDocumentMetadata
     *
     * Patch Document Metadata
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\PatchDocumentMetadataParams $patch_document_metadata_params patch_document_metadata_params (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchDocumentMetadata'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Ragie\Api\Model\ResponsePatchdocumentmetadata|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError
     */
    public function patchDocumentMetadata($document_id, $patch_document_metadata_params, $partition = null, string $contentType = self::contentTypes['patchDocumentMetadata'][0])
    {
        list($response) = $this->patchDocumentMetadataWithHttpInfo($document_id, $patch_document_metadata_params, $partition, $contentType);
        return $response;
    }

    /**
     * Operation patchDocumentMetadataWithHttpInfo
     *
     * Patch Document Metadata
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\PatchDocumentMetadataParams $patch_document_metadata_params (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchDocumentMetadata'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Ragie\Api\Model\ResponsePatchdocumentmetadata|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchDocumentMetadataWithHttpInfo($document_id, $patch_document_metadata_params, $partition = null, string $contentType = self::contentTypes['patchDocumentMetadata'][0])
    {
        $request = $this->patchDocumentMetadataRequest($document_id, $patch_document_metadata_params, $partition, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ResponsePatchdocumentmetadata',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Ragie\Api\Model\ResponsePatchdocumentmetadata',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ResponsePatchdocumentmetadata',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation patchDocumentMetadataAsync
     *
     * Patch Document Metadata
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\PatchDocumentMetadataParams $patch_document_metadata_params (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchDocumentMetadata'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchDocumentMetadataAsync($document_id, $patch_document_metadata_params, $partition = null, string $contentType = self::contentTypes['patchDocumentMetadata'][0])
    {
        return $this->patchDocumentMetadataAsyncWithHttpInfo($document_id, $patch_document_metadata_params, $partition, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchDocumentMetadataAsyncWithHttpInfo
     *
     * Patch Document Metadata
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\PatchDocumentMetadataParams $patch_document_metadata_params (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchDocumentMetadata'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchDocumentMetadataAsyncWithHttpInfo($document_id, $patch_document_metadata_params, $partition = null, string $contentType = self::contentTypes['patchDocumentMetadata'][0])
    {
        $returnType = '\Ragie\Api\Model\ResponsePatchdocumentmetadata';
        $request = $this->patchDocumentMetadataRequest($document_id, $patch_document_metadata_params, $partition, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchDocumentMetadata'
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\PatchDocumentMetadataParams $patch_document_metadata_params (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchDocumentMetadata'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patchDocumentMetadataRequest($document_id, $patch_document_metadata_params, $partition = null, string $contentType = self::contentTypes['patchDocumentMetadata'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling patchDocumentMetadata'
            );
        }

        // verify the required parameter 'patch_document_metadata_params' is set
        if ($patch_document_metadata_params === null || (is_array($patch_document_metadata_params) && count($patch_document_metadata_params) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $patch_document_metadata_params when calling patchDocumentMetadata'
            );
        }



        $resourcePath = '/documents/{document_id}/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($partition !== null) {
            $headerParams['partition'] = ObjectSerializer::toHeaderValue($partition);
        }

        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'document_id' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patch_document_metadata_params)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patch_document_metadata_params));
            } else {
                $httpBody = $patch_document_metadata_params;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDocumentFile
     *
     * Update Document File
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \SplFileObject $file The binary file to upload, extract, and index for retrieval. The following file types are supported: Plain Text: &#x60;.eml&#x60; &#x60;.html&#x60; &#x60;.json&#x60; &#x60;.md&#x60; &#x60;.msg&#x60; &#x60;.rst&#x60; &#x60;.rtf&#x60; &#x60;.txt&#x60; &#x60;.xml&#x60; Images: &#x60;.png&#x60; &#x60;.webp&#x60; &#x60;.jpg&#x60; &#x60;.jpeg&#x60; &#x60;.tiff&#x60; &#x60;.bmp&#x60; &#x60;.heic&#x60; Documents: &#x60;.csv&#x60; &#x60;.doc&#x60; &#x60;.docx&#x60; &#x60;.epub&#x60; &#x60;.epub+zip&#x60; &#x60;.odt&#x60; &#x60;.pdf&#x60; &#x60;.ppt&#x60; &#x60;.pptx&#x60; &#x60;.tsv&#x60; &#x60;.xlsx&#x60; &#x60;.xls&#x60;. PDF files over 2000 pages are not supported in hi_res mode. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  \Ragie\Api\Model\Mode2|null $mode mode (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocumentFile'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Ragie\Api\Model\DocumentFileUpdate|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError
     */
    public function updateDocumentFile($document_id, $file, $partition = null, $mode = null, string $contentType = self::contentTypes['updateDocumentFile'][0])
    {
        list($response) = $this->updateDocumentFileWithHttpInfo($document_id, $file, $partition, $mode, $contentType);
        return $response;
    }

    /**
     * Operation updateDocumentFileWithHttpInfo
     *
     * Update Document File
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \SplFileObject $file The binary file to upload, extract, and index for retrieval. The following file types are supported: Plain Text: &#x60;.eml&#x60; &#x60;.html&#x60; &#x60;.json&#x60; &#x60;.md&#x60; &#x60;.msg&#x60; &#x60;.rst&#x60; &#x60;.rtf&#x60; &#x60;.txt&#x60; &#x60;.xml&#x60; Images: &#x60;.png&#x60; &#x60;.webp&#x60; &#x60;.jpg&#x60; &#x60;.jpeg&#x60; &#x60;.tiff&#x60; &#x60;.bmp&#x60; &#x60;.heic&#x60; Documents: &#x60;.csv&#x60; &#x60;.doc&#x60; &#x60;.docx&#x60; &#x60;.epub&#x60; &#x60;.epub+zip&#x60; &#x60;.odt&#x60; &#x60;.pdf&#x60; &#x60;.ppt&#x60; &#x60;.pptx&#x60; &#x60;.tsv&#x60; &#x60;.xlsx&#x60; &#x60;.xls&#x60;. PDF files over 2000 pages are not supported in hi_res mode. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  \Ragie\Api\Model\Mode2|null $mode (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocumentFile'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Ragie\Api\Model\DocumentFileUpdate|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDocumentFileWithHttpInfo($document_id, $file, $partition = null, $mode = null, string $contentType = self::contentTypes['updateDocumentFile'][0])
    {
        $request = $this->updateDocumentFileRequest($document_id, $file, $partition, $mode, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\DocumentFileUpdate',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Ragie\Api\Model\DocumentFileUpdate',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\DocumentFileUpdate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateDocumentFileAsync
     *
     * Update Document File
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \SplFileObject $file The binary file to upload, extract, and index for retrieval. The following file types are supported: Plain Text: &#x60;.eml&#x60; &#x60;.html&#x60; &#x60;.json&#x60; &#x60;.md&#x60; &#x60;.msg&#x60; &#x60;.rst&#x60; &#x60;.rtf&#x60; &#x60;.txt&#x60; &#x60;.xml&#x60; Images: &#x60;.png&#x60; &#x60;.webp&#x60; &#x60;.jpg&#x60; &#x60;.jpeg&#x60; &#x60;.tiff&#x60; &#x60;.bmp&#x60; &#x60;.heic&#x60; Documents: &#x60;.csv&#x60; &#x60;.doc&#x60; &#x60;.docx&#x60; &#x60;.epub&#x60; &#x60;.epub+zip&#x60; &#x60;.odt&#x60; &#x60;.pdf&#x60; &#x60;.ppt&#x60; &#x60;.pptx&#x60; &#x60;.tsv&#x60; &#x60;.xlsx&#x60; &#x60;.xls&#x60;. PDF files over 2000 pages are not supported in hi_res mode. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  \Ragie\Api\Model\Mode2|null $mode (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocumentFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDocumentFileAsync($document_id, $file, $partition = null, $mode = null, string $contentType = self::contentTypes['updateDocumentFile'][0])
    {
        return $this->updateDocumentFileAsyncWithHttpInfo($document_id, $file, $partition, $mode, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDocumentFileAsyncWithHttpInfo
     *
     * Update Document File
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \SplFileObject $file The binary file to upload, extract, and index for retrieval. The following file types are supported: Plain Text: &#x60;.eml&#x60; &#x60;.html&#x60; &#x60;.json&#x60; &#x60;.md&#x60; &#x60;.msg&#x60; &#x60;.rst&#x60; &#x60;.rtf&#x60; &#x60;.txt&#x60; &#x60;.xml&#x60; Images: &#x60;.png&#x60; &#x60;.webp&#x60; &#x60;.jpg&#x60; &#x60;.jpeg&#x60; &#x60;.tiff&#x60; &#x60;.bmp&#x60; &#x60;.heic&#x60; Documents: &#x60;.csv&#x60; &#x60;.doc&#x60; &#x60;.docx&#x60; &#x60;.epub&#x60; &#x60;.epub+zip&#x60; &#x60;.odt&#x60; &#x60;.pdf&#x60; &#x60;.ppt&#x60; &#x60;.pptx&#x60; &#x60;.tsv&#x60; &#x60;.xlsx&#x60; &#x60;.xls&#x60;. PDF files over 2000 pages are not supported in hi_res mode. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  \Ragie\Api\Model\Mode2|null $mode (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocumentFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDocumentFileAsyncWithHttpInfo($document_id, $file, $partition = null, $mode = null, string $contentType = self::contentTypes['updateDocumentFile'][0])
    {
        $returnType = '\Ragie\Api\Model\DocumentFileUpdate';
        $request = $this->updateDocumentFileRequest($document_id, $file, $partition, $mode, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDocumentFile'
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \SplFileObject $file The binary file to upload, extract, and index for retrieval. The following file types are supported: Plain Text: &#x60;.eml&#x60; &#x60;.html&#x60; &#x60;.json&#x60; &#x60;.md&#x60; &#x60;.msg&#x60; &#x60;.rst&#x60; &#x60;.rtf&#x60; &#x60;.txt&#x60; &#x60;.xml&#x60; Images: &#x60;.png&#x60; &#x60;.webp&#x60; &#x60;.jpg&#x60; &#x60;.jpeg&#x60; &#x60;.tiff&#x60; &#x60;.bmp&#x60; &#x60;.heic&#x60; Documents: &#x60;.csv&#x60; &#x60;.doc&#x60; &#x60;.docx&#x60; &#x60;.epub&#x60; &#x60;.epub+zip&#x60; &#x60;.odt&#x60; &#x60;.pdf&#x60; &#x60;.ppt&#x60; &#x60;.pptx&#x60; &#x60;.tsv&#x60; &#x60;.xlsx&#x60; &#x60;.xls&#x60;. PDF files over 2000 pages are not supported in hi_res mode. (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  \Ragie\Api\Model\Mode2|null $mode (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocumentFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateDocumentFileRequest($document_id, $file, $partition = null, $mode = null, string $contentType = self::contentTypes['updateDocumentFile'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling updateDocumentFile'
            );
        }

        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling updateDocumentFile'
            );
        }




        $resourcePath = '/documents/{document_id}/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($partition !== null) {
            $headerParams['partition'] = ObjectSerializer::toHeaderValue($partition);
        }

        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'document_id' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }

        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'mode' => $mode,
            'file' => $file,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDocumentFromUrl
     *
     * Update Document Url
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\UpdateDocumentFromUrlParams $update_document_from_url_params update_document_from_url_params (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocumentFromUrl'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Ragie\Api\Model\DocumentUrlUpdate|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError
     */
    public function updateDocumentFromUrl($document_id, $update_document_from_url_params, $partition = null, string $contentType = self::contentTypes['updateDocumentFromUrl'][0])
    {
        list($response) = $this->updateDocumentFromUrlWithHttpInfo($document_id, $update_document_from_url_params, $partition, $contentType);
        return $response;
    }

    /**
     * Operation updateDocumentFromUrlWithHttpInfo
     *
     * Update Document Url
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\UpdateDocumentFromUrlParams $update_document_from_url_params (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocumentFromUrl'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Ragie\Api\Model\DocumentUrlUpdate|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDocumentFromUrlWithHttpInfo($document_id, $update_document_from_url_params, $partition = null, string $contentType = self::contentTypes['updateDocumentFromUrl'][0])
    {
        $request = $this->updateDocumentFromUrlRequest($document_id, $update_document_from_url_params, $partition, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\DocumentUrlUpdate',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Ragie\Api\Model\DocumentUrlUpdate',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\DocumentUrlUpdate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateDocumentFromUrlAsync
     *
     * Update Document Url
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\UpdateDocumentFromUrlParams $update_document_from_url_params (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocumentFromUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDocumentFromUrlAsync($document_id, $update_document_from_url_params, $partition = null, string $contentType = self::contentTypes['updateDocumentFromUrl'][0])
    {
        return $this->updateDocumentFromUrlAsyncWithHttpInfo($document_id, $update_document_from_url_params, $partition, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDocumentFromUrlAsyncWithHttpInfo
     *
     * Update Document Url
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\UpdateDocumentFromUrlParams $update_document_from_url_params (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocumentFromUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDocumentFromUrlAsyncWithHttpInfo($document_id, $update_document_from_url_params, $partition = null, string $contentType = self::contentTypes['updateDocumentFromUrl'][0])
    {
        $returnType = '\Ragie\Api\Model\DocumentUrlUpdate';
        $request = $this->updateDocumentFromUrlRequest($document_id, $update_document_from_url_params, $partition, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDocumentFromUrl'
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\UpdateDocumentFromUrlParams $update_document_from_url_params (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocumentFromUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateDocumentFromUrlRequest($document_id, $update_document_from_url_params, $partition = null, string $contentType = self::contentTypes['updateDocumentFromUrl'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling updateDocumentFromUrl'
            );
        }

        // verify the required parameter 'update_document_from_url_params' is set
        if ($update_document_from_url_params === null || (is_array($update_document_from_url_params) && count($update_document_from_url_params) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_document_from_url_params when calling updateDocumentFromUrl'
            );
        }



        $resourcePath = '/documents/{document_id}/url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($partition !== null) {
            $headerParams['partition'] = ObjectSerializer::toHeaderValue($partition);
        }

        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'document_id' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_document_from_url_params)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_document_from_url_params));
            } else {
                $httpBody = $update_document_from_url_params;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDocumentRaw
     *
     * Update Document Raw
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\UpdateDocumentRawParams $update_document_raw_params update_document_raw_params (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocumentRaw'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Ragie\Api\Model\DocumentRawUpdate|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError
     */
    public function updateDocumentRaw($document_id, $update_document_raw_params, $partition = null, string $contentType = self::contentTypes['updateDocumentRaw'][0])
    {
        list($response) = $this->updateDocumentRawWithHttpInfo($document_id, $update_document_raw_params, $partition, $contentType);
        return $response;
    }

    /**
     * Operation updateDocumentRawWithHttpInfo
     *
     * Update Document Raw
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\UpdateDocumentRawParams $update_document_raw_params (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocumentRaw'] to see the possible values for this operation
     *
     * @throws \Ragie\Api\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Ragie\Api\Model\DocumentRawUpdate|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\ErrorMessage|\Ragie\Api\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDocumentRawWithHttpInfo($document_id, $update_document_raw_params, $partition = null, string $contentType = self::contentTypes['updateDocumentRaw'][0])
    {
        $request = $this->updateDocumentRawRequest($document_id, $update_document_raw_params, $partition, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\DocumentRawUpdate',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\ErrorMessage',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\Ragie\Api\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Ragie\Api\Model\DocumentRawUpdate',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\DocumentRawUpdate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ragie\Api\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateDocumentRawAsync
     *
     * Update Document Raw
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\UpdateDocumentRawParams $update_document_raw_params (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocumentRaw'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDocumentRawAsync($document_id, $update_document_raw_params, $partition = null, string $contentType = self::contentTypes['updateDocumentRaw'][0])
    {
        return $this->updateDocumentRawAsyncWithHttpInfo($document_id, $update_document_raw_params, $partition, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDocumentRawAsyncWithHttpInfo
     *
     * Update Document Raw
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\UpdateDocumentRawParams $update_document_raw_params (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocumentRaw'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDocumentRawAsyncWithHttpInfo($document_id, $update_document_raw_params, $partition = null, string $contentType = self::contentTypes['updateDocumentRaw'][0])
    {
        $returnType = '\Ragie\Api\Model\DocumentRawUpdate';
        $request = $this->updateDocumentRawRequest($document_id, $update_document_raw_params, $partition, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDocumentRaw'
     *
     * @param  string $document_id The id of the document. (required)
     * @param  \Ragie\Api\Model\UpdateDocumentRawParams $update_document_raw_params (required)
     * @param  string|null $partition An optional partition to scope the request to. If omitted, accounts created after 1/9/2025 will have the request scoped to the default partition, while older accounts will have the request scoped to all partitions. Older accounts may opt in to strict partition scoping by contacting support@ragie.ai. Older accounts using the partitions feature are strongly recommended to scope the request to a partition. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDocumentRaw'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateDocumentRawRequest($document_id, $update_document_raw_params, $partition = null, string $contentType = self::contentTypes['updateDocumentRaw'][0])
    {

        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling updateDocumentRaw'
            );
        }

        // verify the required parameter 'update_document_raw_params' is set
        if ($update_document_raw_params === null || (is_array($update_document_raw_params) && count($update_document_raw_params) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_document_raw_params when calling updateDocumentRaw'
            );
        }



        $resourcePath = '/documents/{document_id}/raw';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($partition !== null) {
            $headerParams['partition'] = ObjectSerializer::toHeaderValue($partition);
        }

        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'document_id' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_document_raw_params)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_document_raw_params));
            } else {
                $httpBody = $update_document_raw_params;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
